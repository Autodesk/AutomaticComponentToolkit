/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildbindingjava.go
// functions to generate dynamic Java-bindings of a library's API using Java Native Access (JNA).
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path"
	"sort"
	"strconv"
	"strings"
)

type JavaParameter struct {
	ParamType             string
	ParamName             string
	ParamComment          string
	ParamConvention       string
	ParamTypeNoConvention string
}

type JavaReturn struct {
	ParamName        string
	ParamType        string
	ParamValue       string
	ParamDescription string
}

// BuildBindingJavaDynamic builds dynamic Java-bindings of a library's API using Java Native Access (JNA).
func BuildBindingJavaDynamic(component ComponentDefinition, outputFolder string, outputFolderExample string, indent string, version int) error {
	forceRecreation := false
	namespace := component.NameSpace
	libraryname := component.LibraryName
	JavaFolder := path.Join(outputFolder, strings.ToLower(namespace))
	err := os.MkdirAll(JavaFolder, os.ModePerm)
	if err != nil {
		return err
	}

	JavaWrapperName := namespace + "Wrapper"
	JavaWrapperPath := path.Join(JavaFolder, JavaWrapperName+".java")
	log.Printf("Creating \"%s\"", JavaWrapperPath)
	JavaWrapperFile, err := CreateLanguageFile(JavaWrapperPath, indent)
	if err != nil {
		return err
	}

	JavaWrapperFile.WriteJavaLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Java file in order to allow an easy\n use of %s", libraryname),
		true)

	err = buildJavaWrapper(component, JavaWrapperFile, indent)
	if err != nil {
		return err
	}

	JavaExceptionName := namespace + "Exception"
	JavaExceptionPath := path.Join(JavaFolder, JavaExceptionName+".java")
	log.Printf("Creating \"%s\"", JavaExceptionPath)
	JavaExceptionFile, err1 := CreateLanguageFile(JavaExceptionPath, indent)
	if err1 != nil {
		return err1
	}

	JavaExceptionFile.WriteJavaLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Java file in order to allow an easy\n use of %s", libraryname),
		true)

	err = buildJavaException(component, JavaExceptionFile, indent)
	if err != nil {
		return err
	}

	for i := 0; i < len(component.Structs); i++ {
		structinfo := component.Structs[i]
		JavaStructPath := path.Join(JavaFolder, structinfo.Name+".java")
		log.Printf("Creating \"%s\"", JavaStructPath)

		JavaStructFile, err := CreateLanguageFile(JavaStructPath, indent)
		if err != nil {
			return err
		}

		JavaStructFile.WriteJavaLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated Java file in order to allow an easy\n use of %s", libraryname),
			true)

		err = buildJavaStruct(component, JavaStructFile, indent, structinfo)
		if err != nil {
			return err
		}
	}

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		JavaClassPath := path.Join(JavaFolder, class.ClassName+".java")
		log.Printf("Creating \"%s\"", JavaClassPath)

		JavaClassFile, err := CreateLanguageFile(JavaClassPath, indent)
		if err != nil {
			return err
		}

		JavaClassFile.WriteJavaLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated Java file in order to allow an easy\n use of %s", libraryname),
			true)

		err = buildJavaClass(component, JavaClassFile, indent, class, version)
		if err != nil {
			return err
		}
	}

	JavaBuildName := "build_jar.sh"
	JavaBuildPath := path.Join(outputFolder, JavaBuildName)
	log.Printf("Creating \"%s\"", JavaBuildPath)
	JavaWrapperFile, err2 := CreateLanguageFile(JavaBuildPath, indent)
	if err2 != nil {
		return err2
	}
	err = buildJavaBuildScript(component, JavaWrapperFile)
	if err != nil {
		return err
	}

	if len(outputFolderExample) > 0 {
		DynamicJavaExample := path.Join(outputFolderExample, namespace+"_Example"+".java")
		if forceRecreation || !FileExists(DynamicJavaExample) {
			log.Printf("Creating \"%s\"", DynamicJavaExample)
			DynJavaExampleFile, err := CreateLanguageFile(DynamicJavaExample, indent)
			DynJavaExampleFile.WriteJavaLicenseHeader(component,
				fmt.Sprintf("This is an autogenerated Java application that demonstrates the\n usage of the Java bindings of %s", libraryname),
				true)
			err = buildDynamicJavaExample(component, DynJavaExampleFile, outputFolder)
			if err != nil {
				return err
			}
		} else {
			log.Printf("Omitting recreation of Java example \"%s\"", DynamicJavaExample)
		}

		JavaBuildName := "build.sh"
		JavaBuildPath := path.Join(outputFolderExample, JavaBuildName)
		if forceRecreation || !FileExists(JavaBuildPath) {
			log.Printf("Creating \"%s\"", JavaBuildPath)
			JavaWrapperFile, err2 := CreateLanguageFile(JavaBuildPath, indent)
			if err2 != nil {
				return err2
			}
			err = buildJavaBuildExampleScript(component, JavaWrapperFile, version)
			if err != nil {
				return err
			}
		} else {
			log.Printf("Omitting recreation of Java example build file\"%s\"", JavaBuildPath)
		}

	}

	return nil
}

func decorateSpecialFunction(name string) string {
	name = MakeFirstLowerCase(name)
	if name == "clone" || name == "toString" || name == "equals" ||
		name == "hashCode" || name == "finalize" || name == "wait" ||
		name == "notify" || name == "notifyAll" || name == "getClass" {
		return name + "_"
	}
	return name
}

func buildDynamicJavaExample(component ComponentDefinition, w LanguageWriter, outputFolder string) error {
	NameSpace := component.NameSpace

	var VersionMethod *ComponentDefinitionMethod
	var PrereleaseMethod *ComponentDefinitionMethod
	var BuildInfoMethod *ComponentDefinitionMethod
	for j := 0; j < len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]
		isSpecialFunction, err := CheckHeaderSpecialFunction(method, component.Global)
		if err != nil {
			return err
		}
		if isSpecialFunction == eSpecialMethodVersion {
			VersionMethod = &component.Global.Methods[j]
		}
		if isSpecialFunction == eSpecialMethodPrerelease {
			PrereleaseMethod = &component.Global.Methods[j]
		}
		if isSpecialFunction == eSpecialMethodBuildinfo {
			BuildInfoMethod = &component.Global.Methods[j]
		}
	}

	w.Writeln("")
	w.Writeln("import %s.*;", strings.ToLower(NameSpace))
	w.Writeln("")

	w.Writeln("public class %s_Example {", NameSpace)
	w.Writeln("")
	w.Writeln("  public static String libpath = \"\"; // TODO add the location of the shared library binary here")
	w.Writeln("")
	w.Writeln("  public static void main(String[] args) throws %sException {", NameSpace)
	w.Writeln("    %sWrapper wrapper = new %sWrapper(libpath);", NameSpace, NameSpace)
	w.Writeln("    ")
	w.Writeln("    %sWrapper.%sResult version = wrapper.%s();", NameSpace, component.Global.VersionMethod, MakeFirstLowerCase(component.Global.VersionMethod))
	w.Writeln("    System.out.print(\"%s version: \" + version.%s + \".\" + version.%s + \".\" + version.%s);",
		NameSpace, VersionMethod.Params[0].ParamName, VersionMethod.Params[1].ParamName, VersionMethod.Params[2].ParamName)
	if PrereleaseMethod != nil {
		w.Writeln("    %sWrapper.%sResult prerelease = wrapper.%s();", NameSpace, component.Global.PrereleaseMethod, MakeFirstLowerCase(component.Global.PrereleaseMethod))
		w.Writeln("    if (prerelease.%s) {", PrereleaseMethod.Params[0].ParamName)
		w.Writeln("      System.out.print(\" \" + prerelease.%s);", PrereleaseMethod.Params[1].ParamName)
		w.Writeln("    }")
	}
	if BuildInfoMethod != nil {
		w.Writeln("    %sWrapper.%sResult buildinfo = wrapper.%s();", NameSpace, component.Global.BuildinfoMethod, MakeFirstLowerCase(component.Global.BuildinfoMethod))
		w.Writeln("    if (buildinfo.%s) {", BuildInfoMethod.Params[0].ParamName)
		w.Writeln("      System.out.print(\" \" + buildinfo.%s);", BuildInfoMethod.Params[1].ParamName)
		w.Writeln("    }")
	}
	w.Writeln("    System.out.println();")
	w.Writeln("  }")
	w.Writeln("}")
	w.Writeln("")

	return nil
}

func buildJavaBuildExampleScript(component ComponentDefinition, w LanguageWriter, version int) error {
	sources := strings.ToLower(component.NameSpace)
	versionStr := strconv.Itoa(version)
	imports := "../../Bindings/Java" + versionStr + "/" + sources + "/*.java"
	for _, subComponent := range component.ImportedComponentDefinitions {
		imports = imports + " ../../Bindings/Java" + versionStr + "/" + strings.ToLower(subComponent.NameSpace) + "/*.java"
	}

	w.Writeln("#!/bin/bash")
	w.Writeln("set -euxo pipefail")
	w.Writeln("")
	w.Writeln("cd \"$(dirname \"$0\")\"")
	w.Writeln("")
	w.Writeln("JnaJar=\"jna-5.5.0.jar\"")
	w.Writeln("Classpath=\".:${JnaJar}:../../Bindings/Java%d/\"", version)
	w.Writeln("if [[ \"$OSTYPE\" == \"linux-gnu\" ]]; then")
	w.Writeln("  Classpath=\".:${JnaJar}:../../Bindings/Java%d/\"", version)
	w.Writeln("elif [[ \"$OSTYPE\" == \"darwin\"* ]]; then")
	w.Writeln("  Classpath=\".:${JnaJar}:../../Bindings/Java%d/\"", version)
	w.Writeln("elif [[ \"$OSTYPE\" == \"cygwin\" ]]; then")
	w.Writeln("  Classpath=\".;${JnaJar};../../Bindings/Java%d/\"", version)
	w.Writeln("elif [[ \"$OSTYPE\" == \"msys\" ]]; then")
	w.Writeln("  Classpath=\".;${JnaJar};../../Bindings/Java%d/\"", version)
	w.Writeln("elif [[ \"$OSTYPE\" == \"win32\" ]]; then")
	w.Writeln("  Classpath=\".;${JnaJar};../../Bindings/Java%d/\"", version)
	w.Writeln("else")
	w.Writeln("  echo \"Unknown system: \"$OSTYPE")
	w.Writeln("  exit 1")
	w.Writeln("fi")
	w.Writeln("")
	w.Writeln("echo \"Download JNA\"")
	w.Writeln("[ -f jna-5.5.0.jar ] || curl -O https://repo1.maven.org/maven2/net/java/dev/jna/jna/5.5.0/jna-5.5.0.jar")
	w.Writeln("")
	w.Writeln("echo \"Compile Java bindings\"")
	w.Writeln("javac -encoding UTF8 -classpath \"${JnaJar}\" %s", imports)
	w.Writeln("echo \"Compile Java example\"")
	w.Writeln("javac -encoding UTF8 -classpath $Classpath %s_Example.java", component.NameSpace)
	w.Writeln("")
	w.Writeln("echo \"Execute example\"")
	w.Writeln("java -ea -classpath $Classpath %s_Example", component.NameSpace)
	return nil
}

func buildJavaBuildScript(component ComponentDefinition, w LanguageWriter) error {
	sources := strings.ToLower(component.NameSpace)
	imports := sources + "/*"
	for _, subComponent := range component.ImportedComponentDefinitions {
		imports = imports + " " + strings.ToLower(subComponent.NameSpace) + "/*"
	}

	w.Writeln("#!/bin/bash")
	w.Writeln("set -euxo pipefail")
	w.Writeln("")
	w.Writeln("cd \"$(dirname \"$0\")\"")
	w.Writeln("echo \"Download JNA\"")
	w.Writeln("[ -f jna-5.5.0.jar ] || curl -O https://repo1.maven.org/maven2/net/java/dev/jna/jna/5.5.0/jna-5.5.0.jar")
	w.Writeln("")
	w.Writeln("echo \"Compile Java Bindings\"")
	w.Writeln("javac -classpath *.jar " + imports)
	w.Writeln("")
	w.Writeln("echo \"Create JAR\"")
	w.Writeln("jar cvf %s-%s.jar %s", sources, component.Version, sources)
	return nil
}

func buildJavaException(component ComponentDefinition, w LanguageWriter, indent string) error {
	NameSpace := component.NameSpace
	w.Writeln("package %s;", strings.ToLower(component.NameSpace))
	w.Writeln("")
	w.Writeln("import java.util.HashMap;")
	w.Writeln("import java.util.Map;")
	w.Writeln("")
	// Write exception
	w.Writeln("public class %sException extends Exception {", NameSpace)
	w.Writeln("")
	// Write error codes
	w.Writeln("  // Error Constants for %s", NameSpace)
	w.Writeln("  public static final int %s_SUCCESS = 0;", strings.ToUpper(NameSpace))
	for i := 0; i < len(component.Errors.Errors); i++ {
		errorcode := component.Errors.Errors[i]
		w.Writeln("  public static final int %s_ERROR_%s = %d;", strings.ToUpper(NameSpace), errorcode.Name, errorcode.Code)
	}
	w.Writeln("")
	w.Writeln("  public static final Map<Integer, String> ErrorCodeMap = new HashMap<Integer, String>();")
	w.Writeln("  public static final Map<Integer, String> ErrorDescriptionMap = new HashMap<Integer, String>();")
	w.Writeln("")
	w.Writeln("  static {")
	for i := 0; i < len(component.Errors.Errors); i++ {
		errorcode := component.Errors.Errors[i]
		w.Writeln("    ErrorCodeMap.put(%s_ERROR_%s, \"%s_ERROR_%s\");", strings.ToUpper(NameSpace), errorcode.Name, strings.ToUpper(NameSpace), errorcode.Name)
		w.Writeln("    ErrorDescriptionMap.put(%s_ERROR_%s, \"%s\");", strings.ToUpper(NameSpace), errorcode.Name, errorcode.Description)
	}
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  protected int mErrorCode;")
	w.Writeln("")
	w.Writeln("  protected String mErrorString;")
	w.Writeln("")
	w.Writeln("  protected String mErrorDescription;")
	w.Writeln("")
	w.Writeln("  public " + NameSpace + "Exception(int errorCode, String message){")
	w.Writeln("    super(message);")
	w.Writeln("    mErrorCode = errorCode;")
	w.Writeln("    mErrorString = ErrorCodeMap.get(errorCode);")
	w.Writeln("    mErrorString = (mErrorString != null) ? mErrorString : \"Unknown error code\";")
	w.Writeln("    mErrorDescription = ErrorDescriptionMap.get(errorCode);")
	w.Writeln("    mErrorDescription = (mErrorDescription != null) ? mErrorDescription : \"\";")
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  @Override")
	w.Writeln("  public String toString() {")
	w.Writeln("    return mErrorCode + \": \" + mErrorString + \" (\" + mErrorDescription + \" - \" + getMessage() + \")\";")
	w.Writeln("  }")
	w.Writeln("}")
	w.Writeln("")
	return nil
}

func buildJavaClass(component ComponentDefinition, w LanguageWriter, indent string, class ComponentDefinitionClass, version int) error {
	NameSpace := component.NameSpace
	w.Writeln("package %s;", strings.ToLower(component.NameSpace))
	w.Writeln("")
	w.Writeln("import com.sun.jna.Library;")
	w.Writeln("import com.sun.jna.Memory;")
	w.Writeln("import com.sun.jna.Native;")
	w.Writeln("import com.sun.jna.Pointer;")
	if version >= 9 {
		w.Writeln("import java.lang.ref.Cleaner;")
	}
	w.Writeln("")
	for _, subComponent := range component.ImportedComponentDefinitions {
		w.Writeln("import %s.*;", strings.ToLower(subComponent.NameSpace))
	}
	w.Writeln("")
	w.Writeln("import java.nio.charset.StandardCharsets;")
	w.Writeln("import java.util.Arrays;")
	w.Writeln("import java.util.List;")
	w.Writeln("")
	if component.isBaseClass(class) {
		w.Writeln("public class %s {", class.ClassName)
		w.Writeln("")
	} else {
		ParentClass := class.ParentClass
		if ParentClass == "" {
			ParentClass = component.Global.BaseClassName
		}
		w.Writeln("public class %s extends %s {", class.ClassName, ParentClass)
		w.Writeln("")
	}
	if component.isBaseClass(class) {
		if version >= 9 {
			w.Writeln("  protected static final Cleaner mCleaner = Cleaner.create();")
			w.Writeln("")
		}
		w.Writeln("  protected Pointer mHandle;")
		w.Writeln("")
		w.Writeln("  protected %sWrapper mWrapper;", component.NameSpace)
		w.Writeln("")
	}

	w.Writeln("  public %s(%sWrapper wrapper, Pointer handle) {", class.ClassName, component.NameSpace)
	if component.isBaseClass(class) {
		w.Writeln("    mHandle = handle;")
		w.Writeln("    mWrapper = wrapper;")
		if version >= 9 {
			w.Writeln("    mCleaner.register(this, new InstanceReleaser(this));")
		}
	} else {
		w.Writeln("    super(wrapper, handle);")
	}
	w.Writeln("  }")
	w.Writeln("")

	if component.isBaseClass(class) {
		w.Writeln("  public Pointer getHandle() {")
		w.Writeln("    return mHandle;")
		w.Writeln("  }")
		w.Writeln("  ")
		if version >= 9 {
			w.Writeln("  protected static class InstanceReleaser implements Runnable{")
			w.Writeln("  ")
			w.Writeln("    protected Pointer mHandle;")
			w.Writeln("    ")
			w.Writeln("    protected %sWrapper mWrapper;", NameSpace)
			w.Writeln("    ")
			w.Writeln("    protected InstanceReleaser(%s instance) {", component.Global.BaseClassName)
			w.Writeln("      mHandle = instance.mHandle;")
			w.Writeln("      mWrapper = instance.mWrapper;")
			w.Writeln("    }")
			w.Writeln("    ")
			w.Writeln("    @Override")
			w.Writeln("    public void run() {")
			w.Writeln("      try {")
			w.Writeln("        mWrapper.checkError(null, mWrapper.%s_%s.invokeInt(new java.lang.Object[]{mHandle}));", strings.ToLower(NameSpace), strings.ToLower(component.Global.ReleaseMethod))
			w.Writeln("      } catch (%sException e) {", NameSpace)
			w.Writeln("        e.printStackTrace();")
			w.Writeln("      }")
			w.Writeln("    }")
			w.Writeln("  }")
		} else {
			w.Writeln("  @Override")
			w.Writeln("  protected void finalize() throws Throwable {")
			w.Writeln("    super.finalize();")
			w.Writeln("    mWrapper.%s(this);", MakeFirstLowerCase(component.Global.ReleaseMethod))
			w.Writeln("  }")
		}
	}

	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]

		additionalCode := make([]string, 0)
		err := writeJavaClassMethodImplementation(method, w, NameSpace, class.ClassName, indent, false, additionalCode, "")
		if err != nil {
			return err
		}
	}

	w.Writeln("")
	w.Writeln("}")
	w.Writeln("")
	return nil
}

func writeJavaClassMethodImplementation(method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string,
	indent string, isGlobal bool, additionalCode []string, additionalExceptions string) error {

	parameters := ""
	ReturnType := "void"

	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		ParamTypeName, _, err := getJavaParameterType(param.ParamType, NameSpace, param.ParamClass, param.ParamPass, false)
		if err != nil {
			return err
		}

		switch param.ParamPass {
		case "in":
			if parameters != "" {
				parameters = parameters + ", "
			}
			parameters = parameters + ParamTypeName + " " + MakeFirstLowerCase(param.ParamName)
		}
	}

	defineCommands := make([]string, 0)
	initCommands := make([]string, 0)
	resultCommands := make([]string, 0)
	postInitCommands := make([]string, 0)
	wrapperCallPrefix := ""
	wrapperInstanceName := ""

	doInitCall := false

	callFunctionName := ""
	callFunctionParameters := ""
	initCallParameters := ""
	errorInstanceHandle := ""
	ReturnTuple := []JavaReturn{}

	if isGlobal {
		callFunctionName = fmt.Sprintf("%s_%s", strings.ToLower(NameSpace), strings.ToLower(method.MethodName))
		errorInstanceHandle = "null"
		wrapperInstanceName = "this"
	} else {
		callFunctionName = fmt.Sprintf("%s_%s_%s", strings.ToLower(NameSpace), strings.ToLower(ClassName), strings.ToLower(method.MethodName))
		callFunctionParameters = "mHandle"
		errorInstanceHandle = "this"
		wrapperCallPrefix = "mWrapper."
		wrapperInstanceName = "mWrapper"
	}

	initCallParameters = callFunctionParameters
	w.Writeln("  /**")
	w.Writeln("   * " + method.MethodDescription)
	w.Writeln("   *")

	OutFieldCount := 0
	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		if param.ParamPass == "out" || param.ParamPass == "return" {
			OutFieldCount = OutFieldCount + 1
		}
	}

	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		PlainParamTypeName, bytes, err := getJavaParameterType(param.ParamType, NameSpace, param.ParamClass, "in", false)
		if err != nil {
			return err
		}

		if callFunctionParameters != "" {
			callFunctionParameters = callFunctionParameters + ", "
		}

		if initCallParameters != "" {
			initCallParameters = initCallParameters + ", "
		}
		if param.ParamPass == "out" || param.ParamPass == "return" {
			if OutFieldCount == 1 {
				w.Writeln("   * @return %s", param.ParamDescription)
			}
		} else {
			w.Writeln("   * @param %s %s", MakeFirstLowerCase(param.ParamName), param.ParamDescription)
		}

		switch param.ParamPass {
		case "in":

			switch param.ParamType {
			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "bool", "double", "pointer":
				callFunctionParameters = callFunctionParameters + MakeFirstLowerCase(param.ParamName)
				initCallParameters = initCallParameters + MakeFirstLowerCase(param.ParamName)

			case "string":
				initCommands = append(initCommands, "byte[] bytes"+param.ParamName+" = "+MakeFirstLowerCase(param.ParamName)+".getBytes(StandardCharsets.UTF_8);")
				initCommands = append(initCommands, "Memory buffer"+param.ParamName+" = new Memory(bytes"+param.ParamName+".length + 1);")
				initCommands = append(initCommands, "buffer"+param.ParamName+".write(0, bytes"+param.ParamName+", 0, bytes"+param.ParamName+".length);")
				initCommands = append(initCommands, "buffer"+param.ParamName+".setByte(bytes"+param.ParamName+".length, (byte)0);")
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName

			case "enum":
				addParam := fmt.Sprintf("%sWrapper.EnumConversion.convert%sToConst(%s)", NameSpace, param.ParamClass, MakeFirstLowerCase(param.ParamName))
				callFunctionParameters = callFunctionParameters + addParam
				initCallParameters = initCallParameters + addParam

			case "basicarray":
				ArrayType, ElementBytes, err := getJavaParameterType(param.ParamClass, "", "", "in", false)
				if err != nil {
					return err
				}
				Value := MakeFirstLowerCase(param.ParamName) + "[i]"
				if param.ParamClass == "bool" {
					ArrayType = "byte"
					Value = "(byte)(" + MakeFirstLowerCase(param.ParamName) + "[i] ? 1 : 0)"
				}

				initCommands = append(initCommands, fmt.Sprintf("Pointer buffer%s = new Memory(Math.max(1, %d * %s.length));", param.ParamName, ElementBytes, MakeFirstLowerCase(param.ParamName)))
				initCommands = append(initCommands, fmt.Sprintf("for (int i = 0; i < %s.length; i++) {", MakeFirstLowerCase(param.ParamName)))
				initCommands = append(initCommands, fmt.Sprintf("  buffer%s.set%s(%d * i, %s);", param.ParamName, MakeFirstUpperCase(ArrayType), ElementBytes, Value))
				initCommands = append(initCommands, "}")

				callFunctionParameters = callFunctionParameters + "(long) " + MakeFirstLowerCase(param.ParamName) + ".length, buffer" + param.ParamName
				initCallParameters = initCallParameters + "(long) " + MakeFirstLowerCase(param.ParamName) + ".length, buffer" + param.ParamName

			case "structarray":
				initCommands = append(initCommands, fmt.Sprintf("Pointer buffer%s = new Memory(Math.max(1, %s.SIZE * %s.length));", param.ParamName, param.ParamClass, MakeFirstLowerCase(param.ParamName)))
				initCommands = append(initCommands, fmt.Sprintf("for (int i = 0; i < %s.length; i++) {", MakeFirstLowerCase(param.ParamName)))
				initCommands = append(initCommands, fmt.Sprintf("  %s[i].writeToPointer(buffer%s, i * %s.SIZE);", MakeFirstLowerCase(param.ParamName), param.ParamName, param.ParamClass))
				initCommands = append(initCommands, "}")
				callFunctionParameters = callFunctionParameters + "(long) " + MakeFirstLowerCase(param.ParamName) + ".length, buffer" + param.ParamName
				initCallParameters = initCallParameters + "(long) " + MakeFirstLowerCase(param.ParamName) + ".length, buffer" + param.ParamName

			case "struct":
				initCommands = append(initCommands, fmt.Sprintf("Pointer buffer%s = new Memory(%s.SIZE);", param.ParamName, param.ParamClass))
				initCommands = append(initCommands, fmt.Sprintf("%s.writeToPointer(buffer%s, 0);", MakeFirstLowerCase(param.ParamName), param.ParamName))
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName

			case "functiontype":
				callFunctionParameters = callFunctionParameters + MakeFirstLowerCase(param.ParamName)
				initCallParameters = initCallParameters + MakeFirstLowerCase(param.ParamName)

			case "class", "optionalclass":
				initCommands = append(initCommands, "Pointer "+MakeFirstLowerCase(param.ParamName)+"Handle = null;")
				initCommands = append(initCommands, fmt.Sprintf("if (%s != null) {", MakeFirstLowerCase(param.ParamName)))
				initCommands = append(initCommands, indent+MakeFirstLowerCase(param.ParamName)+"Handle = "+MakeFirstLowerCase(param.ParamName)+".getHandle();")
				if param.ParamType == "optionalclass" {

				} else {
					initCommands = append(initCommands, fmt.Sprintf("} else {"))
					initCommands = append(initCommands, indent+fmt.Sprintf("throw new %sException(%sException.%s_ERROR_INVALIDPARAM, \"%s is a null value.\");", NameSpace, NameSpace, strings.ToUpper(NameSpace), param.ParamName))
				}
				initCommands = append(initCommands, fmt.Sprintf("}"))
				callFunctionParameters = callFunctionParameters + MakeFirstLowerCase(param.ParamName) + "Handle"
				initCallParameters = initCallParameters + MakeFirstLowerCase(param.ParamName) + "Handle"

			default:
				return fmt.Errorf("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName)
			}

		case "out", "return":

			ReturnItem := JavaReturn{ParamName: param.ParamName, ParamDescription: param.ParamDescription, ParamType: PlainParamTypeName}

			switch param.ParamType {
			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double", "pointer":
				initCommands = append(initCommands, fmt.Sprintf("Pointer buffer%s = new Memory(%d);", param.ParamName, bytes))
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName
				ReturnItem.ParamValue = fmt.Sprintf("buffer%s.get%s(0);", param.ParamName, MakeFirstUpperCase(PlainParamTypeName))
				ReturnTuple = append(ReturnTuple, ReturnItem)

			case "string":
				initCommands = append(initCommands, "Pointer bytesNeeded"+param.ParamName+" = new Memory(4);")

				initCallParameters = initCallParameters + fmt.Sprintf("0, bytesNeeded%s, null", param.ParamName)

				postInitCommands = append(postInitCommands, fmt.Sprintf("int size%s = bytesNeeded%s.getInt(0);", param.ParamName, param.ParamName))
				postInitCommands = append(postInitCommands, fmt.Sprintf("Pointer buffer%s = new Memory(size%s);", param.ParamName, param.ParamName))

				callFunctionParameters = callFunctionParameters + fmt.Sprintf("size%s, bytesNeeded%s, buffer%s", param.ParamName, param.ParamName, param.ParamName)

				ReturnItem.ParamValue = fmt.Sprintf("new String(buffer%s.getByteArray(0, size%s - 1), StandardCharsets.UTF_8);", param.ParamName, param.ParamName)
				ReturnTuple = append(ReturnTuple, ReturnItem)

				doInitCall = true

			case "enum":
				initCommands = append(initCommands, "Pointer buffer"+param.ParamName+" = new Memory(4);")

				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName

				ReturnItem.ParamValue = fmt.Sprintf("%sWrapper.EnumConversion.convertConstTo%s(buffer%s.getInt(0));", NameSpace, param.ParamClass, param.ParamName)
				ReturnTuple = append(ReturnTuple, ReturnItem)

			case "bool":
				initCommands = append(initCommands, "Pointer buffer"+param.ParamName+" = new Memory(1);")

				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName

				ReturnItem.ParamValue = fmt.Sprintf("buffer%s.getByte(0) != 0;", param.ParamName)
				ReturnTuple = append(ReturnTuple, ReturnItem)

			case "struct":
				initCommands = append(initCommands, fmt.Sprintf("Pointer buffer%s = new Memory(%s.SIZE);", param.ParamName, param.ParamClass))
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName
				resultCommands = append(resultCommands, fmt.Sprintf("%s %s = new %s();", param.ParamClass, MakeFirstLowerCase(param.ParamName), param.ParamClass))
				resultCommands = append(resultCommands, fmt.Sprintf("%s.readFromPointer(buffer%s, 0);", MakeFirstLowerCase(param.ParamName), param.ParamName))

				ReturnItem.ParamValue = MakeFirstLowerCase(param.ParamName) + ";"
				ReturnTuple = append(ReturnTuple, ReturnItem)

			case "basicarray":
				ArrayType, ElementBytes, err := getJavaParameterType(param.ParamClass, "", "", "in", false)
				if err != nil {
					return err
				}

				initCommands = append(initCommands, fmt.Sprintf("Pointer countNeeded%s = new Memory(8);", param.ParamName))

				initCallParameters = initCallParameters + fmt.Sprintf("0L, countNeeded%s, Pointer.NULL", param.ParamName)

				postInitCommands = append(postInitCommands, fmt.Sprintf("long count%s = countNeeded%s.getLong(0);", param.ParamName, param.ParamName))
				postInitCommands = append(postInitCommands, fmt.Sprintf("Pointer buffer%s = new Memory(Math.max(1, %d * count%s));", param.ParamName, ElementBytes, param.ParamName))

				callFunctionParameters = callFunctionParameters + fmt.Sprintf("count%s, countNeeded%s, buffer%s", param.ParamName, param.ParamName, param.ParamName)

				if param.ParamClass == "bool" {
					resultCommands = append(resultCommands, fmt.Sprintf("%s %s[] = new %s[(int)count%s];", ArrayType, MakeFirstLowerCase(param.ParamName), ArrayType, param.ParamName))
					resultCommands = append(resultCommands, fmt.Sprintf("byte[] bytes%s = buffer%s.getByteArray(0, (int)count%s);", param.ParamName, param.ParamName, param.ParamName))
					resultCommands = append(resultCommands, fmt.Sprintf("for (int i = 0; i < (int)count%s; i++) {", param.ParamName))
					resultCommands = append(resultCommands, fmt.Sprintf("  %s[i] = bytes%s[i] != (byte) 0;", MakeFirstLowerCase(param.ParamName), param.ParamName))
					resultCommands = append(resultCommands, "}")
					ReturnItem.ParamValue = MakeFirstLowerCase(param.ParamName) + ";"
				} else {
					ReturnItem.ParamValue = fmt.Sprintf("buffer%s.get%sArray(0, (int)count%s);", param.ParamName, MakeFirstUpperCase(ArrayType), param.ParamName)
				}
				ReturnTuple = append(ReturnTuple, ReturnItem)

				doInitCall = true

			case "structarray":

				initCommands = append(initCommands, fmt.Sprintf("Pointer countNeeded%s = new Memory(8);", param.ParamName))

				initCallParameters = initCallParameters + fmt.Sprintf("0L, countNeeded%s, null", param.ParamName)

				postInitCommands = append(postInitCommands, fmt.Sprintf("long count%s = countNeeded%s.getLong(0);", param.ParamName, param.ParamName))
				postInitCommands = append(postInitCommands, fmt.Sprintf("Pointer buffer%s = new Memory(Math.max(1, count%s * %s.SIZE));", param.ParamName, param.ParamName, param.ParamClass))

				callFunctionParameters = callFunctionParameters + fmt.Sprintf("count%s, countNeeded%s, buffer%s", param.ParamName, param.ParamName, param.ParamName)

				resultCommands = append(resultCommands, fmt.Sprintf("%s %s[] = new %s[(int)count%s];", param.ParamClass, MakeFirstLowerCase(param.ParamName), param.ParamClass, param.ParamName))
				resultCommands = append(resultCommands, fmt.Sprintf("for (int i = 0; i < (int)count%s; i++) {", param.ParamName))
				resultCommands = append(resultCommands, fmt.Sprintf("  %s[i] = new %s();", MakeFirstLowerCase(param.ParamName), param.ParamClass))
				resultCommands = append(resultCommands, fmt.Sprintf("  %s[i].readFromPointer(buffer%s, i * %s.SIZE);", MakeFirstLowerCase(param.ParamName), param.ParamName, param.ParamClass))
				resultCommands = append(resultCommands, "}")

				ReturnItem.ParamValue = MakeFirstLowerCase(param.ParamName) + ";"
				ReturnTuple = append(ReturnTuple, ReturnItem)

				doInitCall = true

			case "class", "optionalclass":
				theNameSpace, theParamClass, _ := decomposeParamClassName(param.ParamClass)
				theWrapperInstance := wrapperInstanceName
				if len(theNameSpace) > 0 {
					theWrapperInstance = theWrapperInstance + ".get" + theNameSpace + "Wrapper()"
				} else {
					theNameSpace = NameSpace
				}
				initCommands = append(initCommands, "Pointer buffer"+param.ParamName+" = new Memory(8);")
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				resultCommands = append(resultCommands, fmt.Sprintf("Pointer value%s = buffer%s.getPointer(0);", param.ParamName, param.ParamName))
				resultCommands = append(resultCommands, fmt.Sprintf("%s %s = null;", theParamClass, MakeFirstLowerCase(param.ParamName)))
				if param.ParamType == "class" {
					resultCommands = append(resultCommands, fmt.Sprintf("if (value%s == Pointer.NULL) {", param.ParamName))
					resultCommands = append(resultCommands, fmt.Sprintf("  throw new %sException(%sException.%s_ERROR_INVALIDPARAM, \"%s was a null pointer\");",
						NameSpace, NameSpace, strings.ToUpper(NameSpace), param.ParamName))
					resultCommands = append(resultCommands, "}")
					resultCommands = append(resultCommands, fmt.Sprintf("%s = %s.PolymorphicFactory(value%s, %s.class);", MakeFirstLowerCase(param.ParamName), theWrapperInstance, param.ParamName, theParamClass))
				} else {
					resultCommands = append(resultCommands, fmt.Sprintf("if (value%s != Pointer.NULL) {", param.ParamName))
					resultCommands = append(resultCommands, fmt.Sprintf("  %s = %s.PolymorphicFactory(value%s, %s.class);", MakeFirstLowerCase(param.ParamName), theWrapperInstance, param.ParamName, theParamClass))
					resultCommands = append(resultCommands, "}")
				}
				ReturnItem.ParamValue = fmt.Sprintf("%s;", MakeFirstLowerCase(param.ParamName))
				ReturnTuple = append(ReturnTuple, ReturnItem)

			default:
				return fmt.Errorf("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName)
			}

		}
	}

	if len(ReturnTuple) == 1 {
		ReturnType = ReturnTuple[0].ParamType
	}
	if len(ReturnTuple) > 1 {
		ReturnType = method.MethodName + "Result"
		w.Writeln("   * @return %s Result Tuple", method.MethodName)
	}

	w.Writeln("   * @throws %sException", NameSpace)
	w.Writeln("   */")
	w.Writeln("  public %s %s(%s) throws %sException%s {", ReturnType, decorateSpecialFunction(method.MethodName), parameters, NameSpace, additionalExceptions)

	if len(defineCommands) > 0 {
		w.Writelns(indent+indent, defineCommands)
	}

	w.Writelns(indent+indent, initCommands)

	if doInitCall {
		w.Writeln("    %scheckError(%s, %s%s.invokeInt(new java.lang.Object[]{%s}));", wrapperCallPrefix, errorInstanceHandle, wrapperCallPrefix, callFunctionName, initCallParameters)
	}

	w.Writelns(indent+indent, postInitCommands)

	w.Writeln("    %scheckError(%s, %s%s.invokeInt(new java.lang.Object[]{%s}));", wrapperCallPrefix, errorInstanceHandle, wrapperCallPrefix, callFunctionName, callFunctionParameters)

	w.Writelns(indent+indent, resultCommands)

	if len(additionalCode) > 0 {
		w.Writeln("")
		w.Writelns("    ", additionalCode)
	}

	if len(ReturnTuple) == 1 {
		w.Writeln("    return " + ReturnTuple[0].ParamValue)
	}
	if len(ReturnTuple) > 1 {
		w.Writeln("    %sResult returnTuple = new %sResult();", method.MethodName, method.MethodName)
		for _, ReturnParam := range ReturnTuple {
			w.Writeln("    returnTuple.%s = %s", ReturnParam.ParamName, ReturnParam.ParamValue)
		}
		w.Writeln("    return returnTuple;")
	}

	w.Writeln("  }")
	w.Writeln("")

	if len(ReturnTuple) > 1 {
		w.Writeln("  public static class %sResult {", method.MethodName)
		for _, ReturnParam := range ReturnTuple {
			w.Writeln("    /**")
			w.Writeln("     * " + ReturnParam.ParamDescription)
			w.Writeln("     */")
			w.Writeln("    public %s %s;", ReturnParam.ParamType, ReturnParam.ParamName)
			w.Writeln("")
		}
		w.Writeln("  }")
	}

	return nil
}

func buildJavaStruct(component ComponentDefinition, w LanguageWriter, indent string, structinfo ComponentDefinitionStruct) error {

	w.Writeln("package %s;", strings.ToLower(component.NameSpace))
	w.Writeln("")
	w.Writeln("import com.sun.jna.Memory;")
	w.Writeln("import com.sun.jna.Pointer;")
	w.Writeln("")
	w.Writeln("import java.util.Arrays;")
	w.Writeln("import java.util.List;")
	w.Writeln("")
	w.Writeln("public class %s {", structinfo.Name)
	w.Writeln("")
	byteSum := 0

	for j := 0; j < len(structinfo.Members); j++ {
		element := structinfo.Members[j]
		arrayprefix := ""
		arraysuffix := ""
		fieldType, bytes, err := getJavaParameterType(element.Type, component.NameSpace, "", "in", true)
		if err != nil {
			return err
		}

		if element.Rows > 0 {
			if element.Columns > 0 {
				arrayprefix = fmt.Sprintf("[][]")
				arraysuffix = fmt.Sprintf("[%d][%d]", element.Rows, element.Columns)
				byteSum = byteSum + bytes*element.Columns*element.Rows
			} else {
				arrayprefix = fmt.Sprintf("[]")
				arraysuffix = fmt.Sprintf("[%d]", element.Rows)
				byteSum = byteSum + bytes*element.Rows
			}
			w.Writeln("  public %s%s %s = new %s%s;", fieldType, arrayprefix, element.Name, fieldType, arraysuffix)
		} else {
			byteSum = byteSum + bytes
			w.Writeln("  public %s %s;", fieldType, element.Name)
		}
		w.Writeln("")
	}
	w.Writeln("  public static final int SIZE = %d;", byteSum)
	w.Writeln("")

	// Write memory reader
	byteSum = 0
	w.Writeln("  public void readFromPointer(Pointer p, long offset) {")
	for j := 0; j < len(structinfo.Members); j++ {
		element := structinfo.Members[j]
		boolSuffix := ""

		fieldType, bytes, err := getJavaParameterType(element.Type, component.NameSpace, "", "in", true)
		if err != nil {
			return err
		}
		if element.Type == "bool" {
			boolSuffix = " != 0"
			fieldType = "byte"
		}

		if element.Rows > 0 {
			for k := 0; k < element.Rows; k++ {
				if element.Columns > 0 {
					for l := 0; l < element.Columns; l++ {
						w.Writeln("    %s[%d][%d] = p.get%s(offset + %d)%s;", element.Name, k, l, MakeFirstUpperCase(fieldType), byteSum, boolSuffix)
						byteSum = byteSum + bytes
					}
				} else {
					w.Writeln("    %s[%d] = p.get%s(offset + %d)%s;", element.Name, k, MakeFirstUpperCase(fieldType), byteSum, boolSuffix)
					byteSum = byteSum + bytes
				}
			}
		} else {
			w.Writeln("    %s = p.get%s(offset + %d)%s;", element.Name, MakeFirstUpperCase(fieldType), byteSum, boolSuffix)
			byteSum = byteSum + bytes
		}
	}
	w.Writeln("  }")
	w.Writeln("")

	// Write memory writer
	byteSum = 0
	w.Writeln("  public void writeToPointer(Pointer p, long offset) {")
	for j := 0; j < len(structinfo.Members); j++ {
		element := structinfo.Members[j]
		value := element.Name
		fieldType, bytes, err := getJavaParameterType(element.Type, component.NameSpace, "", "in", true)
		if err != nil {
			return err
		}
		if element.Type == "bool" {
			value = "(byte) (" + element.Name + " ? 1 : 0)"
			fieldType = "byte"
		}

		if element.Rows > 0 {
			for k := 0; k < element.Rows; k++ {
				if element.Columns > 0 {
					for l := 0; l < element.Columns; l++ {
						w.Writeln("    p.set%s(offset + %d, %s[%d][%d]);", MakeFirstUpperCase(fieldType), byteSum, value, k, l)
						byteSum = byteSum + bytes
					}
				} else {
					w.Writeln("    p.set%s(offset + %d, %s[%d]);", MakeFirstUpperCase(fieldType), byteSum, value, k)
					byteSum = byteSum + bytes
				}
			}
		} else {
			w.Writeln("    p.set%s(offset + %d, %s);", MakeFirstUpperCase(fieldType), byteSum, value)
			byteSum = byteSum + bytes
		}
	}
	w.Writeln("  }")
	w.Writeln("")

	w.Writeln("}")
	w.Writeln("")
	return nil
}

func buildJavaWrapper(component ComponentDefinition, w LanguageWriter, indent string) error {

	NameSpace := component.NameSpace
	JavaWrapperName := NameSpace + "Wrapper"

	w.Writeln("package %s;", strings.ToLower(component.NameSpace))
	w.Writeln("")
	w.Writeln("import com.sun.jna.*;")
	w.Writeln("")
	w.Writeln("import java.nio.charset.StandardCharsets;")
	w.Writeln("")

	for _, subComponent := range component.ImportedComponentDefinitions {
		w.Writeln("import %s.*;", strings.ToLower(subComponent.NameSpace))
	}
	w.Writeln("")

	w.Writeln("public class " + JavaWrapperName + " {")
	w.Writeln("")

	// Write enums and conversion functions
	for i := 0; i < len(component.Enums); i++ {
		enum := component.Enums[i]
		for j := 0; j < len(enum.Options); j++ {
			w.Writeln("  public static final int %s_%s = %d;", strings.ToUpper(enum.Name), strings.ToUpper(enum.Options[j].Name), enum.Options[j].Value)
		}
		w.Writeln("")
		w.Writeln("  public enum %s {", enum.Name)
		for j := 0; j < len(enum.Options); j++ {
			if j < len(enum.Options)-1 {
				w.Writeln("    e" + enum.Options[j].Name + ",")
			} else {
				w.Writeln("    e" + enum.Options[j].Name)
			}
		}
		w.Writeln("  }")
		w.Writeln("")
	}
	if len(component.Errors.Errors) > 0 {
		w.Writeln("  public static class EnumConversion {")
		for i := 0; i < len(component.Enums); i++ {
			enum := component.Enums[i]
			w.Writeln("    public static int convert%sToConst (%s value) throws %sException {", enum.Name, enum.Name, NameSpace)
			w.Writeln("      switch (value) {")
			for j := 0; j < len(enum.Options); j++ {
				w.Writeln("        case e%s: return %s_%s;", enum.Options[j].Name, strings.ToUpper(enum.Name), strings.ToUpper(enum.Options[j].Name))
			}
			w.Writeln("        default: throw new %sException(%sException.%s_ERROR_INVALIDPARAM, \"Unknown enum value : \" + value);", NameSpace, NameSpace, strings.ToUpper(NameSpace))
			w.Writeln("      }")
			w.Writeln("    }")
			w.Writeln("")
			w.Writeln("    public static %s convertConstTo%s (int value) throws %sException {", enum.Name, enum.Name, NameSpace)
			w.Writeln("      switch (value) {")
			for j := 0; j < len(enum.Options); j++ {
				w.Writeln("        case %s_%s: return %s.e%s;", strings.ToUpper(enum.Name), strings.ToUpper(enum.Options[j].Name), enum.Name, enum.Options[j].Name)
			}
			w.Writeln("        default: throw new %sException(%sException.%s_ERROR_INVALIDPARAM, \"Unknown enum const : \" + value);", NameSpace, NameSpace, strings.ToUpper(NameSpace))
			w.Writeln("      }")
			w.Writeln("    }")
			w.Writeln("")
		}
		w.Writeln("  }")
		w.Writeln("")
	}

	// Write callback functions
	for j := 0; j < len(component.Functions); j++ {
		function := component.Functions[j]
		w.Writeln("  public interface %s extends Callback {", function.FunctionName)
		w.Writeln("")
		nativeParams := ""
		for i := 0; i < len(function.Params); i++ {
			param := function.Params[i]

			javaParams, err := generatePlainJavaParameter(param, "", function.FunctionName, NameSpace)
			if err != nil {
				return err
			}

			for _, javaParam := range javaParams {
				if nativeParams != "" {
					nativeParams = nativeParams + ", "
				}
				nativeParams = nativeParams + javaParam.ParamConvention + javaParam.ParamType + " " + javaParam.ParamName
			}
		}
		w.Writeln("    void %s (%s);", MakeFirstLowerCase(function.FunctionName), nativeParams)
		w.Writeln("")
		w.Writeln("  }")
		w.Writeln("")
	}

	// Write wrapper functions
	for j := 0; j < len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]
		w.Writeln("  protected Function %s_%s;", strings.ToLower(NameSpace), strings.ToLower(method.MethodName))
	}
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			w.Writeln("  protected Function %s_%s_%s;", strings.ToLower(NameSpace), strings.ToLower(class.ClassName), strings.ToLower(method.MethodName))
		}
	}
	w.Writeln("")

	// Write wrapper member/constructor/checkError
	w.Writeln("  protected NativeLibrary mLibrary;")
	w.Writeln("")
	for _, subComponent := range component.ImportedComponentDefinitions {
		w.Writeln("  protected %sWrapper m%sWrapper;", subComponent.NameSpace, subComponent.NameSpace)
		w.Writeln("")
	}
	w.Writeln("  public " + JavaWrapperName + "(String libraryPath) {")
	w.Writeln("    mLibrary = NativeLibrary.getInstance(libraryPath);")

	for j := 0; j < len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]
		w.Writeln("    %s_%s = mLibrary.getFunction(\"%s_%s\");", strings.ToLower(NameSpace), strings.ToLower(method.MethodName), strings.ToLower(NameSpace), strings.ToLower(method.MethodName))
	}
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		classPrefix := strings.ToLower(NameSpace) + "_" + strings.ToLower(class.ClassName)
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			w.Writeln("    %s_%s = mLibrary.getFunction(\"%s_%s\");", classPrefix, strings.ToLower(method.MethodName), classPrefix, strings.ToLower(method.MethodName))
		}
	}
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  public %s(Pointer lookupPointer) throws %sException {", JavaWrapperName, NameSpace)
	w.Writeln("    Function lookupMethod = Function.getFunction(lookupPointer);")
	for j := 0; j < len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]
		w.Writeln("    %s_%s = loadFunctionByLookup(lookupMethod, \"%s_%s\");", strings.ToLower(NameSpace), strings.ToLower(method.MethodName), strings.ToLower(NameSpace), strings.ToLower(method.MethodName))
	}
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		classPrefix := strings.ToLower(NameSpace) + "_" + strings.ToLower(class.ClassName)
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			w.Writeln("    %s_%s = loadFunctionByLookup(lookupMethod, \"%s_%s\");", classPrefix, strings.ToLower(method.MethodName), classPrefix, strings.ToLower(method.MethodName))
		}
	}
	w.Writeln("  }")
	w.Writeln("")
	ErrorMessage := "ErrorMessage"
	for j := 0; j < len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]
		isSpecialFunction, err := CheckHeaderSpecialFunction(method, component.Global)
		if err != nil {
			return err
		}
		if isSpecialFunction == eSpecialMethodError {
			ErrorMessage = method.Params[1].ParamName
		}
	}
	w.Writeln("  protected void checkError(%s instance, int errorCode) throws %sException {", component.Global.BaseClassName, NameSpace)
	w.Writeln("    if (instance != null && instance.mWrapper != this) {")
	w.Writeln("      throw new %sException(%sException.%s_ERROR_INVALIDCAST, \"invalid wrapper call\");", NameSpace, NameSpace, strings.ToUpper(NameSpace))
	w.Writeln("    }")
	w.Writeln("    if (errorCode != %sException.%s_SUCCESS) {", NameSpace, strings.ToUpper(NameSpace))
	w.Writeln("      if (instance != null) {")
	w.Writeln("        %sResult result = %s(instance);", component.Global.ErrorMethod, MakeFirstLowerCase(component.Global.ErrorMethod))
	w.Writeln("        throw new %sException(errorCode, result.%s);", NameSpace, ErrorMessage)
	w.Writeln("      } else {")
	w.Writeln("        throw new %sException(errorCode, \"\");", NameSpace)
	w.Writeln("      }")
	w.Writeln("    }")
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  private Function loadFunctionByLookup(Function lookupMethod, String functionName) throws %sException {", NameSpace)
	w.Writeln("    byte[] bytes = functionName.getBytes(StandardCharsets.UTF_8);")
	w.Writeln("    Memory name = new Memory(bytes.length+1);")
	w.Writeln("    name.write(0, bytes, 0, bytes.length);")
	w.Writeln("    name.setByte(bytes.length, (byte)0);")
	w.Writeln("    Pointer address = new Memory(8);")
	w.Writeln("    java.lang.Object[] addressParam = new java.lang.Object[]{name, address};")
	w.Writeln("    checkError(null, lookupMethod.invokeInt(addressParam));")
	w.Writeln("    return Function.getFunction(address.getPointer(0));")
	w.Writeln("  }")
	w.Writeln("")
	for _, subComponent := range component.ImportedComponentDefinitions {
		w.Writeln("  public %sWrapper get%sWrapper() {", subComponent.NameSpace, subComponent.NameSpace)
		w.Writeln("    return m%sWrapper;", subComponent.NameSpace)
		w.Writeln("  }")
		w.Writeln("")
	}

	// Write wrapper methods
	for j := 0; j < len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]

		isSpecialFunction, err := CheckHeaderSpecialFunction(method, component.Global)
		if err != nil {
			return err
		}

		implementationLines := make([]string, 0)
		additionalExceptions := ""
		if isSpecialFunction == eSpecialMethodInjection {
			implementationLines = append(implementationLines, "boolean nameSpaceFound = false;")
			sParamName := MakeFirstLowerCase(method.Params[0].ParamName)
			for _, subComponent := range component.ImportedComponentDefinitions {
				theNameSpace := subComponent.NameSpace

				implementationLines = append(implementationLines, fmt.Sprintf("if (\"%s\".equals(%s)) {", theNameSpace, sParamName))
				implementationLines = append(implementationLines, fmt.Sprintf("  if (m%sWrapper != null) {", theNameSpace))
				implementationLines = append(implementationLines, fmt.Sprintf("    throw new %sException(%sException.%s_ERROR_COULDNOTLOADLIBRARY, \"Library with namespace ' + %s + ' is already registered.\");", NameSpace, NameSpace, strings.ToUpper(NameSpace), sParamName))
				implementationLines = append(implementationLines, fmt.Sprintf("  }"))
				implementationLines = append(implementationLines, fmt.Sprintf("  m%sWrapper = new %sWrapper(%s);", theNameSpace, theNameSpace, MakeFirstLowerCase(method.Params[1].ParamName)))
				implementationLines = append(implementationLines, fmt.Sprintf("  nameSpaceFound = true;"))
				implementationLines = append(implementationLines, fmt.Sprintf("}"))
				additionalExceptions = additionalExceptions + ", " + theNameSpace + "Exception"
			}
			implementationLines = append(implementationLines, fmt.Sprintf("if (!nameSpaceFound) {"))
			implementationLines = append(implementationLines, fmt.Sprintf("  throw new %sException(%sException.%s_ERROR_COULDNOTLOADLIBRARY, \"Unknown namespace \" + %s);", NameSpace, NameSpace, strings.ToUpper(NameSpace), sParamName))
			implementationLines = append(implementationLines, fmt.Sprintf("}"))
		}

		err = writeJavaClassMethodImplementation(method, w, NameSpace, "", indent, true, implementationLines, additionalExceptions)
		if err != nil {
			return err
		}
	}

	// Write PolymorphicFactory
	w.Writeln("  /**")
	w.Writeln("   * IMPORTANT: PolymorphicFactory method should not be used by application directly.")
	w.Writeln("   *            It's designed to be used on %sHandle object only once.", NameSpace)
	w.Writeln("   *            If it's used on any existing object as a form of dynamic cast then")
	w.Writeln("   *            %sWrapper::acquireInstance(%s object) must be called after instantiating new object.", NameSpace, component.Global.BaseClassName)
	w.Writeln("   *            This is important to keep reference count matching between application and library sides.")
	w.Writeln("  */")
	w.Writeln("  public <T> T PolymorphicFactory(Pointer handle, Class<T> cls) {")
	w.Writeln("    if (handle == Pointer.NULL)")
	w.Writeln("  	 return null;")

	w.Writeln("  	 Class[] cArg = new Class[2];")
	w.Writeln("  	 cArg[0] = %sWrapper.class;", NameSpace)
	w.Writeln("  	 cArg[1] = Pointer.class;")
	w.Writeln("      ")
	w.Writeln("      try {")
	w.Writeln("  	   T obj = null;")
	w.Writeln("  	   Pointer bufferClassTypeId = new Memory(8);")
	w.Writeln("  	   checkError(null, %s_%s_%s.invokeInt(new java.lang.Object[]{handle, bufferClassTypeId}));", strings.ToLower(NameSpace), strings.ToLower(component.Global.BaseClassName), strings.ToLower(component.Global.ClassTypeIdMethod))
	w.Writeln("  	   long classTypeId = bufferClassTypeId.getLong(0);")

	w.Writeln("  	   ")
	w.Writeln("  	   int msbId = (int)(classTypeId >> 32); ")
	w.Writeln("  	   int lsbId = (int)classTypeId; ")

	msbIds := make(map[uint32][]ComponentDefinitionClass)
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		classTypeId, _ := class.classTypeId(NameSpace)
		msb := uint32((classTypeId >> 32) & 0xFFFFFFFF)
		msbIds[msb] = append(msbIds[msb], class)
	}

	// Sork Ids so change to binding file is always human readable
	msbKeys := make([]uint32, len(msbIds))
	i := 0
	for k := range msbIds {
		msbKeys[i] = k
		i++
	}
	sort.Slice(msbKeys, func(i, j int) bool { return msbKeys[i] < msbKeys[j] })

	w.Writeln("      switch(msbId) {")
	// for id, classes := range msbIds {
	for _, id := range msbKeys {
		classes := msbIds[id]
		// Sork Ids so change to binding file is always human readable
		sort.Slice(classes, func(i, j int) bool {
			iId, _ := classes[i].classTypeId(NameSpace)
			jId, _ := classes[j].classTypeId(NameSpace)
			return uint32(iId&0xFFFFFFFF) < uint32(jId&0xFFFFFFFF)
		})
		w.Writeln("        case 0x%08X: ", id)
		w.Writeln("          switch(lsbId) {")
		for i := 0; i < len(classes); i++ {
			class := classes[i]
			ClassTypeId, chashHashString := class.classTypeId(NameSpace)
			lsbId := uint32(ClassTypeId & 0xFFFFFFFF)
			w.Writeln("            case 0x%08X: obj = (T)(new %s(this, handle)); break; // First 64 bits of SHA1 of a string: \"%s\"", lsbId, class.ClassName, chashHashString)
		}
		w.Writeln("          }")
		w.Writeln("        break;")
	}
	w.Writeln("        default: obj = cls.getDeclaredConstructor(cArg).newInstance(this, handle); break;")
	w.Writeln("      }")

	w.Writeln("  		return obj;")
	w.Writeln("  	}")
	w.Writeln("  	catch(Exception e) {")
	w.Writeln("  		return null;")
	w.Writeln("  	}")
	w.Writeln("  }")
	w.Writeln("}")
	w.Writeln("")

	return nil
}

func generateParametersForMethod(method ComponentDefinitionMethod, ClassName string, NameSpace string, isGlobal bool) (string, error) {
	parameters := ""
	if isGlobal {

	} else {

		parameters = fmt.Sprintf("Pointer %s", MakeFirstLowerCase(ClassName))
	}

	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]

		javaParams, err := generatePlainJavaParameter(param, ClassName, method.MethodName, NameSpace)
		if err != nil {
			return "", err
		}

		for _, javaParam := range javaParams {
			if parameters != "" {
				parameters = parameters + ", "
			}
			parameters = parameters + javaParam.ParamConvention + javaParam.ParamType + " " + javaParam.ParamName
		}

	}
	return parameters, nil
}

func generatePlainJavaParameter(param ComponentDefinitionParam, className string, methodName string, NameSpace string) ([]JavaParameter, error) {
	cParams := make([]JavaParameter, 1)
	cParamTypeName, _, err := getJavaParameterType(param.ParamType, NameSpace, param.ParamClass, param.ParamPass, true)
	if err != nil {
		return nil, err
	}

	switch param.ParamPass {
	case "in":
		switch param.ParamType {
		case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "bool", "single", "double", "pointer", "string", "enum":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "struct":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "basicarray", "structarray":
			cParams = make([]JavaParameter, 2)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "Size"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - Number of elements in buffer", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = "Pointer"
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[1].ParamComment = fmt.Sprintf("* @param[in] %s - %s buffer of %s", cParams[1].ParamName, param.ParamClass, param.ParamDescription)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

		case "functiontype":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "class", "optionalclass":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		default:
			return nil, fmt.Errorf("invalid method parameter type \"%s\" for %s.%s(%s)", param.ParamType, className, methodName, param.ParamName)
		}

	case "out", "return":

		switch param.ParamType {

		case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "bool", "single", "double", "pointer", "enum":
			cParams[0].ParamType = "Pointer"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[out] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "struct":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[out] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "basicarray":
			cParams = make([]JavaParameter, 3)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "Size"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - Number of elements in buffer", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = "Pointer"
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "NeededSize"
			cParams[1].ParamComment = fmt.Sprintf("* @param[out] %s - will be filled with the count of the written elements, or needed buffer size.", cParams[1].ParamName)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

			cParams[2].ParamType = "Pointer"
			cParams[2].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[2].ParamComment = fmt.Sprintf("* @param[out] %s - %s buffer of %s", cParams[2].ParamName, param.ParamClass, param.ParamDescription)
			cParams[2].ParamConvention = ""
			cParams[2].ParamTypeNoConvention = cParams[2].ParamType

		case "structarray":
			cParams = make([]JavaParameter, 3)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "Size"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - Number of elements in buffer", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = "Pointer"
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "NeededSize"
			cParams[1].ParamComment = fmt.Sprintf("* @param[out] %s - will be filled with the count of the written elements, or needed buffer size.", cParams[1].ParamName)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

			cParams[2].ParamType = "Pointer"
			cParams[2].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[2].ParamComment = fmt.Sprintf("* @param[out] %s - %s buffer of %s", cParams[2].ParamName, param.ParamClass, param.ParamDescription)
			cParams[2].ParamConvention = ""
			cParams[2].ParamTypeNoConvention = cParams[2].ParamType

		case "string":
			cParams = make([]JavaParameter, 3)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "BufferSize"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - size of the buffer (including trailing 0)", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = "Pointer"
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "NeededBuffer"
			cParams[1].ParamComment = fmt.Sprintf("* @param[out] %s - will be filled with the count of the written bytes, or needed buffer size.", cParams[1].ParamName)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

			cParams[2].ParamType = "Pointer"
			cParams[2].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[2].ParamComment = fmt.Sprintf("* @param[out] %s - %s buffer of %s, may be NULL", cParams[2].ParamName, param.ParamClass, param.ParamDescription)
			cParams[2].ParamConvention = ""
			cParams[2].ParamTypeNoConvention = cParams[2].ParamType

		case "class", "optionalclass":
			cParams[0].ParamType = "Pointer"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[out] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		default:
			return nil, fmt.Errorf("invalid method parameter type \"%s\" for %s.%s(%s)", param.ParamType, className, methodName, param.ParamName)
		}

	default:
		return nil, fmt.Errorf("invalid method parameter passing \"%s\" for %s.%s(%s)", param.ParamPass, className, methodName, param.ParamName)
	}

	return cParams, nil
}

func getJavaParameterType(ParamTypeName string, NameSpace string, ParamClass string, ParamPass string, isPlain bool) (string, int, error) {
	JavaParamTypeName := ""
	Bytes := 0
	switch ParamTypeName {
	case "uint8", "int8":
		JavaParamTypeName = "byte"
		Bytes = 1

	case "int16":
		JavaParamTypeName = "short"
		Bytes = 2

	case "uint16":
		JavaParamTypeName = "char"
		Bytes = 2

	case "uint32", "int32":
		JavaParamTypeName = "int"
		Bytes = 4

	case "uint64", "int64":
		JavaParamTypeName = "long"
		Bytes = 8

	case "bool":
		JavaParamTypeName = "boolean"
		Bytes = 1

	case "single":
		JavaParamTypeName = "float"
		Bytes = 4

	case "double":
		JavaParamTypeName = "double"
		Bytes = 8

	case "pointer":
		JavaParamTypeName = "Pointer"
		Bytes = 8

	case "string":
		JavaParamTypeName = "String"

	case "enum":
		if isPlain {
			JavaParamTypeName = "int"
		} else {
			JavaParamTypeName = NameSpace + "Wrapper." + ParamClass
		}
		Bytes = 4

	case "functiontype":
		JavaParamTypeName = NameSpace + "Wrapper." + ParamClass

	case "struct":
		if isPlain {
			JavaParamTypeName = "Pointer"
		} else {
			JavaParamTypeName = ParamClass
		}

	case "basicarray":
		basicTypeName, SubBytes, err := getJavaParameterType(ParamClass, NameSpace, "", "in", isPlain)
		if err != nil {
			return "", 0, err
		}
		Bytes = SubBytes
		if isPlain {
			JavaParamTypeName = "Pointer"
		} else {
			if ParamPass == "out" {
				JavaParamTypeName = fmt.Sprintf("%sWrapper.%sArrayOut", NameSpace, MakeFirstUpperCase(basicTypeName))
			} else {
				JavaParamTypeName = fmt.Sprintf("%s[]", basicTypeName)
			}
		}

	case "structarray":
		if isPlain {
			JavaParamTypeName = "Pointer"
		} else {
			JavaParamTypeName = ParamClass + "[]"
		}

	case "class", "optionalclass":
		if isPlain {
			JavaParamTypeName = fmt.Sprintf("Pointer")
		} else {
			SubNameSpace, SubClassName, _ := decomposeParamClassName(ParamClass)
			if len(SubNameSpace) > 0 {
				JavaParamTypeName = fmt.Sprintf("%s", SubClassName)
			} else {
				JavaParamTypeName = fmt.Sprintf("%s", ParamClass)
			}
		}

	default:
		return "", Bytes, fmt.Errorf("invalid parameter type \"%s\" for Java parameter", ParamTypeName)
	}

	if isPlain {
		if ParamTypeName == "string" {
			JavaParamTypeName = "Pointer"
		}
		if ParamTypeName == "enum" {
			JavaParamTypeName = "int"
		}
	}

	return JavaParamTypeName, Bytes, nil
}

func MakeFirstLowerCase(s string) string {

	if len(s) < 2 {
		return strings.ToLower(s)
	}

	bts := []byte(s)

	lc := bytes.ToLower([]byte{bts[0]})
	rest := bts[1:]

	return string(bytes.Join([][]byte{lc, rest}, nil))
}

func MakeFirstUpperCase(s string) string {

	if len(s) < 2 {
		return strings.ToLower(s)
	}

	bts := []byte(s)

	lc := bytes.ToUpper([]byte{bts[0]})
	rest := bts[1:]

	return string(bytes.Join([][]byte{lc, rest}, nil))
}
