/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildbindingjava.go
// functions to generate dynamic Java-bindings of a library's API using Java Native Access (JNA).
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"fmt"
	"log"
	"path"
	"strings"
	"bytes"
	"os"
)

type JavaParameter struct {
	ParamType             string
	ParamName             string
	ParamComment          string
	ParamConvention       string
	ParamTypeNoConvention string
}

type JavaReturn struct {
	ParamName             string
	ParamType             string
	ParamValue            string
	ParamDescription      string
}

// BuildBindingJavaDynamic builds dynamic Java-bindings of a library's API using Java Native Access (JNA).
func BuildBindingJavaDynamic(component ComponentDefinition, outputFolder string, outputFolderExample string, indent string) error {
	namespace := component.NameSpace
	libraryname := component.LibraryName
	JavaFolder := path.Join(outputFolder, strings.ToLower(namespace));
	err := os.MkdirAll(JavaFolder, os.ModePerm)
	if err != nil {
		return err;
	}
	
	JavaWrapperName := namespace + "Wrapper";
	JavaWrapperPath := path.Join(JavaFolder, JavaWrapperName + ".java");
	log.Printf("Creating \"%s\"", JavaWrapperPath)
	JavaWrapperFile, err := CreateLanguageFile (JavaWrapperPath, indent)
	if err != nil {
		return err;
	}

	JavaWrapperFile.WriteJavaLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Java file in order to allow an easy\n use of %s", libraryname),
		true)
	
	err = buildJavaWrapper(component, JavaWrapperFile, indent)
	if err != nil {
		return err;
	}

	JavaExceptionName := namespace + "Exception";
	JavaExceptionPath := path.Join(JavaFolder, JavaExceptionName + ".java");
	log.Printf("Creating \"%s\"", JavaExceptionPath)
	JavaExceptionFile, err1 := CreateLanguageFile (JavaExceptionPath, indent)
	if err1 != nil {
		return err1;
	}

	JavaExceptionFile.WriteJavaLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Java file in order to allow an easy\n use of %s", libraryname),
		true)
	
	err = buildJavaException(component, JavaExceptionFile, indent)
	if err != nil {
		return err;
	}

	for i := 0; i < len(component.Structs); i++ {
		structinfo := component.Structs[i]
		JavaStructPath := path.Join(JavaFolder, structinfo.Name + ".java");
		log.Printf("Creating \"%s\"", JavaStructPath)

		JavaStructFile, err := CreateLanguageFile (JavaStructPath, indent)
		if err != nil {
			return err;
		}

		JavaStructFile.WriteJavaLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated Java file in order to allow an easy\n use of %s", libraryname),
			true)
	
		err = buildJavaStruct(component, JavaStructFile, indent, structinfo)
		if err != nil {
			return err;
		}
	}

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		JavaClassPath := path.Join(JavaFolder, class.ClassName + ".java");
		log.Printf("Creating \"%s\"", JavaClassPath)

		JavaClassFile, err := CreateLanguageFile (JavaClassPath, indent)
		if err != nil {
			return err;
		}

		JavaClassFile.WriteJavaLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated Java file in order to allow an easy\n use of %s", libraryname),
			true)
	
		err = buildJavaClass(component, JavaClassFile, indent, class)
		if err != nil {
			return err;
		}
	}

	JavaBuildName := "build_jar.sh";
	JavaBuildPath := path.Join(outputFolder, JavaBuildName);
	log.Printf("Creating \"%s\"", JavaBuildPath)
	JavaWrapperFile, err2 := CreateLanguageFile (JavaBuildPath, indent)
	if err2 != nil {
		return err2;
	}
	err = buildJavaBuildScript(component, JavaWrapperFile)
	if err != nil {
		return err;
	}

	return nil;
}

func buildJavaBuildScript(component ComponentDefinition, w LanguageWriter) error {
	sources := strings.ToLower(component.NameSpace)
	imports := sources + "/*"
	for _, subComponent := range(component.ImportedComponentDefinitions) {
		imports = imports + " " + strings.ToLower(subComponent.NameSpace) + "/*"
	}

	w.Writeln("#!/bin/bash")
	w.Writeln("")
	w.Writeln("echo \"Download JNA\"")
	w.Writeln("wget http://repo1.maven.org/maven2/net/java/dev/jna/jna/5.5.0/jna-5.5.0.jar")
	w.Writeln("")
	w.Writeln("echo \"Compile Java Bindings\"")
	w.Writeln("javac -classpath *.jar " + imports)
	w.Writeln("")
	w.Writeln("echo \"Create JAR\"")
	w.Writeln("jar cvf %s-%s.jar %s", sources, component.Version, sources)
	return nil;
}


func buildJavaException(component ComponentDefinition, w LanguageWriter, indent string) error {
	NameSpace := component.NameSpace
	w.Writeln("package %s;", strings.ToLower(component.NameSpace))
	w.Writeln("")
	w.Writeln("import java.util.HashMap;")
	w.Writeln("import java.util.Map;")
	w.Writeln("")
	// Write exception
	w.Writeln("public class %sException extends Exception {", NameSpace)
	w.Writeln("")
	// Write error codes
	w.Writeln("  // Error Constants for %s", NameSpace)
	w.Writeln("  public static final int %s_SUCCESS = 0;", strings.ToUpper(NameSpace))
	for i := 0; i < len(component.Errors.Errors); i++ {
		errorcode := component.Errors.Errors[i]
		w.Writeln("  public static final int %s_ERROR_%s = %d;", strings.ToUpper(NameSpace), errorcode.Name, errorcode.Code)
	}
	w.Writeln("")
	w.Writeln("  public static final Map<Integer, String> ErrorCodeMap = new HashMap<Integer, String>();")
	w.Writeln("")
	w.Writeln("  static {")
	for i := 0; i < len(component.Errors.Errors); i++ {
		errorcode := component.Errors.Errors[i]
		w.Writeln("    ErrorCodeMap.put(%s_ERROR_%s, \"%s_ERROR_%s\");", strings.ToUpper(NameSpace), errorcode.Name, strings.ToUpper(NameSpace), errorcode.Name)
	}
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  protected int mErrorCode;")
	w.Writeln("")
	w.Writeln("  protected String mErrorDescription;")
	w.Writeln("")
	w.Writeln("  public " + NameSpace + "Exception(int errorCode, String message){")
	w.Writeln("    super(message);")
	w.Writeln("    mErrorCode = errorCode;")
	w.Writeln("    mErrorDescription = ErrorCodeMap.get(errorCode);")
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  @Override")
	w.Writeln("  public String toString() {")
	w.Writeln("    return getMessage() + \" (\" + mErrorCode + \" \" + mErrorDescription + \")\";")
	w.Writeln("  }")
	w.Writeln("}")
	w.Writeln("")
	return nil;
}

func buildJavaClass(component ComponentDefinition, w LanguageWriter, indent string, class ComponentDefinitionClass) error {
	NameSpace := component.NameSpace
	w.Writeln("package %s;", strings.ToLower(component.NameSpace))
	w.Writeln("")
	w.Writeln("import com.sun.jna.Library;")
	w.Writeln("import com.sun.jna.Memory;")
	w.Writeln("import com.sun.jna.Native;")
	w.Writeln("import com.sun.jna.Pointer;")
	w.Writeln("")
	for _, subComponent := range(component.ImportedComponentDefinitions) {
		w.Writeln("import %s.*;", strings.ToLower(subComponent.NameSpace))
	}
	w.Writeln("")
	w.Writeln("import java.nio.charset.StandardCharsets;");
	w.Writeln("import java.util.Arrays;")
	w.Writeln("import java.util.List;")
	w.Writeln("")
	if component.isBaseClass(class) {
		w.Writeln("public class %s {", class.ClassName)
		w.Writeln("")
	} else {
		ParentClass := class.ParentClass
		if ParentClass == "" {
			ParentClass = component.Global.BaseClassName
		}
		w.Writeln("public class %s extends %s {", class.ClassName, ParentClass)
		w.Writeln("")		
	}
	if component.isBaseClass(class) {
		w.Writeln("  protected Pointer mHandle;");
		w.Writeln("")
		w.Writeln("  protected %sWrapper mWrapper;", component.NameSpace);
		w.Writeln("")
	}

	w.Writeln("  public %s(%sWrapper wrapper, Pointer handle) {", class.ClassName, component.NameSpace);
	if component.isBaseClass(class) {
		w.Writeln("    mHandle = handle;");
		w.Writeln("    mWrapper = wrapper;");
	} else {
		w.Writeln("    super(wrapper, handle);");
	}
	w.Writeln("  }");
	w.Writeln("")

	if component.isBaseClass(class) {
		w.Writeln("  @Override")
		w.Writeln("  protected void finalize() throws Throwable {")
		w.Writeln("    mWrapper.%s(this);", MakeFirstLowerCase(component.Global.ReleaseMethod))
		w.Writeln("    super.finalize();")
		w.Writeln("  }")
		w.Writeln("")
		w.Writeln("  public Pointer getHandle() {")
		w.Writeln("    return mHandle;")
		w.Writeln("  }")
		w.Writeln("")
	}

	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]

		err := writeJavaClassMethodImplementation(method, w, NameSpace, class.ClassName, indent, false)
		if err != nil {
			return err
		}
	}

	w.Writeln("")
	w.Writeln("}")
	w.Writeln("")
	return nil;
}

func writeJavaClassMethodImplementation(method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, indent string, isGlobal bool) error {

	parameters := ""
	ReturnType := "void"

	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		ParamTypeName, _, err := getJavaParameterType(param.ParamType, NameSpace, param.ParamClass, param.ParamPass, false)
		if err != nil {
			return err
		}

		switch param.ParamPass {
		case "in":
			if parameters != "" {
				parameters = parameters + ", "
			}
			parameters = parameters + ParamTypeName + " " + MakeFirstLowerCase(param.ParamName)
		}
	}

	defineCommands := make([]string, 0)
	initCommands := make([]string, 0)
	resultCommands := make([]string, 0)
	postInitCommands := make([]string, 0)
	wrapperCallPrefix := ""
	wrapperInstanceName := ""

	doInitCall := false

	callFunctionName := ""
	callFunctionParameters := ""
	initCallParameters := ""
	errorInstanceHandle := ""
	ReturnTuple := []JavaReturn{}

	if isGlobal {
		callFunctionName = fmt.Sprintf("%s_%s", strings.ToLower(NameSpace), strings.ToLower(method.MethodName))
		errorInstanceHandle = "null"
		wrapperInstanceName = "this"
	} else {
		callFunctionName = fmt.Sprintf("%s_%s_%s", strings.ToLower(NameSpace), strings.ToLower(ClassName), strings.ToLower(method.MethodName))
		callFunctionParameters = "mHandle"
		errorInstanceHandle = "this"
		wrapperCallPrefix = "mWrapper."
		wrapperInstanceName = "mWrapper"
	}

	initCallParameters = callFunctionParameters
	w.Writeln("  /**")
	w.Writeln("   * " + method.MethodDescription)
	w.Writeln("   *")

	OutFieldCount := 0
	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		if (param.ParamPass == "out" || param.ParamPass == "return") {
			OutFieldCount = OutFieldCount + 1
		}
	}

	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		PlainParamTypeName, bytes, err := getJavaParameterType(param.ParamType, NameSpace, param.ParamClass, "in", false)
		if err != nil {
			return err
		}

		if callFunctionParameters != "" {
			callFunctionParameters = callFunctionParameters + ", "
		}

		if initCallParameters != "" {
			initCallParameters = initCallParameters + ", "
		}
		if (param.ParamPass == "out" || param.ParamPass == "return") {
			if OutFieldCount == 1 {
				w.Writeln("   * @return %s", param.ParamDescription)
			}		
		} else {
			w.Writeln("   * @param %s %s", MakeFirstLowerCase(param.ParamName), param.ParamDescription)
		}

		switch param.ParamPass {
		case "in":

			switch param.ParamType {
			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "bool", "double", "pointer":
				callFunctionParameters = callFunctionParameters + MakeFirstLowerCase(param.ParamName)
				initCallParameters = initCallParameters + MakeFirstLowerCase(param.ParamName)

			case "string":
				initCommands = append(initCommands, "byte[] bytes" + param.ParamName + " = " + MakeFirstLowerCase(param.ParamName) + ".getBytes(StandardCharsets.UTF_8);")
				initCommands = append(initCommands, "Memory buffer" + param.ParamName + " = new Memory(bytes" + param.ParamName + ".length + 1);")
				initCommands = append(initCommands, "buffer" + param.ParamName + ".write(0, bytes" + param.ParamName + ", 0, bytes" + param.ParamName + ".length);")
				initCommands = append(initCommands, "buffer" + param.ParamName + ".setByte(bytes" + param.ParamName + ".length, (byte)0);")
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName

			case "enum":
				addParam := fmt.Sprintf("%sWrapper.EnumConversion.convert%sToConst(%s)", NameSpace, param.ParamClass, MakeFirstLowerCase(param.ParamName))
				callFunctionParameters = callFunctionParameters + addParam
				initCallParameters = initCallParameters + addParam

			case "basicarray":
				ArrayType, ElementBytes, err := getJavaParameterType(param.ParamClass, "", "", "in", false)
				if err != nil {
					return err
				}
				Value := MakeFirstLowerCase(param.ParamName) + "[i]"
				if param.ParamClass == "bool" {
					ArrayType = "byte"
					Value = "(byte)(" + MakeFirstLowerCase(param.ParamName) + "[i] ? 1 : 0)"
				}

				initCommands = append(initCommands, fmt.Sprintf("Pointer buffer%s = new Memory(%d * %s.length);", param.ParamName, ElementBytes, MakeFirstLowerCase(param.ParamName)))
				initCommands = append(initCommands, fmt.Sprintf("for (int i = 0; i < %s.length; i++) {", MakeFirstLowerCase(param.ParamName)))
				initCommands = append(initCommands, fmt.Sprintf("  buffer%s.set%s(%d * i, %s);", param.ParamName, MakeFirstUpperCase(ArrayType), ElementBytes, Value))
				initCommands = append(initCommands, "}")

				callFunctionParameters = callFunctionParameters + MakeFirstLowerCase(param.ParamName) + ".length, buffer" + param.ParamName
				initCallParameters = initCallParameters + MakeFirstLowerCase(param.ParamName) + ".length, buffer" + param.ParamName

			case "structarray":
				initCommands = append(initCommands, fmt.Sprintf("Pointer buffer%s = new Memory(%s.SIZE * %s.length);", param.ParamName, param.ParamClass, MakeFirstLowerCase(param.ParamName)))
				initCommands = append(initCommands, fmt.Sprintf("for (int i = 0; i < %s.length; i++) {", MakeFirstLowerCase(param.ParamName)))
				initCommands = append(initCommands, fmt.Sprintf("  %s[i].writeToPointer(buffer%s, i * %s.SIZE);", MakeFirstLowerCase(param.ParamName), param.ParamName, param.ParamClass))
				initCommands = append(initCommands, "}")
				callFunctionParameters = callFunctionParameters + MakeFirstLowerCase(param.ParamName) + ".length, buffer" + param.ParamName
				initCallParameters = initCallParameters + MakeFirstLowerCase(param.ParamName) + ".length, buffer" + param.ParamName

			case "struct":
				initCommands = append(initCommands, fmt.Sprintf("Pointer buffer%s = new Memory(%s.SIZE);", param.ParamName, param.ParamClass))
				initCommands = append(initCommands, fmt.Sprintf("%s.writeToPointer(buffer%s, 0);", MakeFirstLowerCase(param.ParamName), param.ParamName))
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName

			case "functiontype":
				callFunctionParameters = callFunctionParameters + MakeFirstLowerCase(param.ParamName)
				initCallParameters = initCallParameters + MakeFirstLowerCase(param.ParamName)

			case "class", "optionalclass":
				initCommands = append(initCommands, "Pointer " + MakeFirstLowerCase(param.ParamName) + "Handle = null;")
				initCommands = append(initCommands, fmt.Sprintf("if (%s != null) {", MakeFirstLowerCase(param.ParamName)))
				initCommands = append(initCommands, indent + MakeFirstLowerCase(param.ParamName) + "Handle = " + MakeFirstLowerCase(param.ParamName) + ".getHandle();")
				if (param.ParamType == "optionalclass") {

				} else {
					initCommands = append(initCommands, fmt.Sprintf("} else {"))
					initCommands = append(initCommands, indent + fmt.Sprintf("throw new %sException(%sException.%s_ERROR_INVALIDPARAM, \"%s is a null value.\");", NameSpace, NameSpace, strings.ToUpper(NameSpace), param.ParamName))
				}
				initCommands = append(initCommands, fmt.Sprintf("}"))
				callFunctionParameters = callFunctionParameters + MakeFirstLowerCase(param.ParamName) + "Handle"
				initCallParameters = initCallParameters + MakeFirstLowerCase(param.ParamName) + "Handle"

			default:
				return fmt.Errorf("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName)
			}

		case "out", "return":

			ReturnItem := JavaReturn{ParamName: param.ParamName, ParamDescription: param.ParamDescription, ParamType: PlainParamTypeName}

			switch param.ParamType {
			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double", "pointer":
				initCommands = append(initCommands, fmt.Sprintf("Pointer buffer%s = new Memory(%d);", param.ParamName, bytes))
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName
				ReturnItem.ParamValue = fmt.Sprintf("buffer%s.get%s(0);", param.ParamName, MakeFirstUpperCase(PlainParamTypeName))
				ReturnTuple = append(ReturnTuple, ReturnItem)

			case "string":
				initCommands = append(initCommands, "Pointer bytesNeeded"+param.ParamName+" = new Memory(4);")

				initCallParameters = initCallParameters + fmt.Sprintf("0, bytesNeeded%s, null", param.ParamName)

				postInitCommands = append(postInitCommands, fmt.Sprintf("int size%s = bytesNeeded%s.getInt(0);", param.ParamName, param.ParamName))
				postInitCommands = append(postInitCommands, fmt.Sprintf("Pointer buffer%s = new Memory(size%s);", param.ParamName, param.ParamName))

				callFunctionParameters = callFunctionParameters + fmt.Sprintf("size%s, bytesNeeded%s, buffer%s", param.ParamName, param.ParamName, param.ParamName)

				ReturnItem.ParamValue = fmt.Sprintf("new String(buffer%s.getByteArray(0, size%s - 1), StandardCharsets.UTF_8);", param.ParamName, param.ParamName)
				ReturnTuple = append(ReturnTuple, ReturnItem)

				doInitCall = true

			case "enum":
				initCommands = append(initCommands, "Pointer buffer" + param.ParamName + " = new Memory(4);")

				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName

				ReturnItem.ParamValue = fmt.Sprintf("%sWrapper.EnumConversion.convertConstTo%s(buffer%s.getInt(0));", NameSpace, param.ParamClass, param.ParamName)
				ReturnTuple = append(ReturnTuple, ReturnItem)

			case "bool":
				initCommands = append(initCommands, "Pointer buffer" + param.ParamName + " = new Memory(1);")				

				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName

				ReturnItem.ParamValue = fmt.Sprintf("buffer%s.getByte(0) != 0;", param.ParamName)
				ReturnTuple = append(ReturnTuple, ReturnItem)

			case "struct":
				initCommands = append(initCommands, fmt.Sprintf("Pointer buffer%s = new Memory(%s.SIZE);", param.ParamName, param.ParamClass))
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				initCallParameters = initCallParameters + "buffer" + param.ParamName
				resultCommands = append(resultCommands, fmt.Sprintf("%s %s = new %s();", param.ParamClass, MakeFirstLowerCase(param.ParamName), param.ParamClass))
				resultCommands = append(resultCommands, fmt.Sprintf("%s.readFromPointer(buffer%s, 0);", MakeFirstLowerCase(param.ParamName), param.ParamName))

				ReturnItem.ParamValue = MakeFirstLowerCase(param.ParamName) + ";"
				ReturnTuple = append(ReturnTuple, ReturnItem)

			case "basicarray":
				ArrayType, ElementBytes, err := getJavaParameterType(param.ParamClass, "", "", "in", false)
				if err != nil {
					return err
				}

				initCommands = append(initCommands, fmt.Sprintf("Pointer countNeeded%s = new Memory(4);", param.ParamName))

				initCallParameters = initCallParameters + fmt.Sprintf("0, countNeeded%s, Pointer.NULL", param.ParamName)

				postInitCommands = append(postInitCommands, fmt.Sprintf("int count%s = countNeeded%s.getInt(0);", param.ParamName,  param.ParamName))
				postInitCommands = append(postInitCommands, fmt.Sprintf("Pointer buffer%s = new Memory(%d * count%s);", param.ParamName, ElementBytes, param.ParamName))

				callFunctionParameters = callFunctionParameters + fmt.Sprintf("count%s, countNeeded%s, buffer%s", param.ParamName, param.ParamName, param.ParamName)

				if param.ParamClass == "bool" {
					resultCommands = append(resultCommands, fmt.Sprintf("%s %s[] = new %s[count%s];", ArrayType, MakeFirstLowerCase(param.ParamName), ArrayType, param.ParamName))
					resultCommands = append(resultCommands, fmt.Sprintf("byte[] bytes%s = buffer%s.getByteArray(0, count%s);", param.ParamName, param.ParamName, param.ParamName))
					resultCommands = append(resultCommands, fmt.Sprintf("for (int i = 0; i < count%s; i++) {", param.ParamName))
					resultCommands = append(resultCommands, fmt.Sprintf("  %s[i] = bytes%s[i] != (byte) 0;", MakeFirstLowerCase(param.ParamName), param.ParamName))
					resultCommands = append(resultCommands, "}")
					ReturnItem.ParamValue = MakeFirstLowerCase(param.ParamName) + ";"
				} else {
					ReturnItem.ParamValue = fmt.Sprintf("buffer%s.get%sArray(0, count%s);", param.ParamName, MakeFirstUpperCase(ArrayType), param.ParamName)
				}
				ReturnTuple = append(ReturnTuple, ReturnItem)

				doInitCall = true

			case "structarray":

				initCommands = append(initCommands, fmt.Sprintf("Pointer countNeeded%s = new Memory(4);", param.ParamName))

				initCallParameters = initCallParameters + fmt.Sprintf("0, countNeeded%s, null", param.ParamName)

				postInitCommands = append(postInitCommands, fmt.Sprintf("int count%s = countNeeded%s.getInt(0);", param.ParamName,  param.ParamName))
				postInitCommands = append(postInitCommands, fmt.Sprintf("Pointer buffer%s = new Memory(count%s * %s.SIZE);", param.ParamName, param.ParamName, param.ParamClass))

				callFunctionParameters = callFunctionParameters + fmt.Sprintf("count%s, countNeeded%s, buffer%s", param.ParamName, param.ParamName, param.ParamName)

				resultCommands = append(resultCommands, fmt.Sprintf("%s %s[] = new %s[count%s];", param.ParamClass, MakeFirstLowerCase(param.ParamName), param.ParamClass, param.ParamName))
				resultCommands = append(resultCommands, fmt.Sprintf("for (int i = 0; i < count%s; i++) {", param.ParamName))
				resultCommands = append(resultCommands, fmt.Sprintf("  %s[i] = new %s();", MakeFirstLowerCase(param.ParamName), param.ParamClass))
				resultCommands = append(resultCommands, fmt.Sprintf("  %s[i].readFromPointer(buffer%s, i * %s.SIZE);", MakeFirstLowerCase(param.ParamName), param.ParamName, param.ParamClass))
				resultCommands = append(resultCommands, "}")

				ReturnItem.ParamValue = MakeFirstLowerCase(param.ParamName) + ";"
				ReturnTuple = append(ReturnTuple, ReturnItem)

				doInitCall = true

			case "class", "optionalclass":
				theNameSpace, theParamClass, _ := decomposeParamClassName(param.ParamClass)
				theWrapperInstance := wrapperInstanceName
				if len(theNameSpace) > 0 {
					theWrapperInstance = theWrapperInstance + ".get" + theNameSpace + "Wrapper()"
				} else {
					theNameSpace = NameSpace
				}
				initCommands = append(initCommands, "Pointer buffer" + param.ParamName + " = new Memory(8);")
				callFunctionParameters = callFunctionParameters + "buffer" + param.ParamName
				resultCommands = append(resultCommands, fmt.Sprintf("Pointer value%s = buffer%s.getPointer(0);", param.ParamName, param.ParamName))
				resultCommands = append(resultCommands, fmt.Sprintf("%s %s = null;", theParamClass, MakeFirstLowerCase(param.ParamName)))
				if param.ParamType == "class" {
				  resultCommands = append(resultCommands, fmt.Sprintf("if (value%s == Pointer.NULL) {", param.ParamName))
					resultCommands = append(resultCommands, fmt.Sprintf("  throw new %sException(%sException.%s_ERROR_NORESULTAVAILABLE, \"%s was a null pointer\");", 
						NameSpace, NameSpace, strings.ToUpper(NameSpace), param.ParamName))
  				resultCommands = append(resultCommands, "}")
				}
				ReturnItem.ParamValue = fmt.Sprintf("(value%s == Pointer.NULL) ? null : new %s(%s, value%s);", param.ParamName, theParamClass, theWrapperInstance, param.ParamName)
				ReturnTuple = append(ReturnTuple, ReturnItem)

			default:
				return fmt.Errorf("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName)
			}

		}
	}

	if len(ReturnTuple) == 1 {
		ReturnType = ReturnTuple[0].ParamType
	}
	if len(ReturnTuple) > 1 {
		ReturnType = method.MethodName + "Result"
		w.Writeln("   * @return %s Result Tuple", method.MethodName)
	}

	w.Writeln("   * @throws %sException", NameSpace)
	w.Writeln("   */")
	w.Writeln("  public %s %s(%s) throws %sException {", ReturnType, MakeFirstLowerCase(method.MethodName), parameters, NameSpace)

	if len(defineCommands) > 0 {
		w.Writelns(indent + indent, defineCommands)
	}

	w.Writelns(indent + indent, initCommands)

	if doInitCall {
		w.Writeln("    %scheckError(%s, %s%s.invokeInt(new Object[]{%s}));", wrapperCallPrefix, errorInstanceHandle, wrapperCallPrefix, callFunctionName, initCallParameters)
	}

	w.Writelns(indent + indent, postInitCommands)

	w.Writeln("    %scheckError(%s, %s%s.invokeInt(new Object[]{%s}));", wrapperCallPrefix, errorInstanceHandle, wrapperCallPrefix, callFunctionName, callFunctionParameters)

	w.Writelns(indent + indent, resultCommands)

	if len(ReturnTuple) == 1 {
		w.Writeln("    return " + ReturnTuple[0].ParamValue)
	}
	if len(ReturnTuple) > 1 {
		w.Writeln("    %sResult returnTuple = new %sResult();", method.MethodName, method.MethodName)
		for _,ReturnParam := range(ReturnTuple) {
			w.Writeln("    returnTuple.%s = %s", ReturnParam.ParamName, ReturnParam.ParamValue)
		}
		w.Writeln("    return returnTuple;")
	}

	w.Writeln("  }")
	w.Writeln("")

	if len(ReturnTuple) > 1 {
		w.Writeln("  public static class %sResult {", method.MethodName)
		for _,ReturnParam := range(ReturnTuple) {
			w.Writeln("    /**")
			w.Writeln("     * " + ReturnParam.ParamDescription)
			w.Writeln("     */")
			w.Writeln("    public %s %s;", ReturnParam.ParamType, ReturnParam.ParamName)
			w.Writeln("")
		}
		w.Writeln("  }")
	}


	return nil
}

func buildJavaStruct(component ComponentDefinition, w LanguageWriter, indent string, structinfo ComponentDefinitionStruct) error {

	w.Writeln("package %s;", strings.ToLower(component.NameSpace))
	w.Writeln("")
	w.Writeln("import com.sun.jna.Memory;")
	w.Writeln("import com.sun.jna.Pointer;")
	w.Writeln("")
	w.Writeln("import java.util.Arrays;")
	w.Writeln("import java.util.List;")
	w.Writeln("")
	w.Writeln("public class %s {", structinfo.Name)
	w.Writeln("")
	byteSum := 0

	for j := 0; j < len(structinfo.Members); j++ {
		element := structinfo.Members[j]
		arrayprefix := ""
		arraysuffix := ""
		if element.Rows > 0 {
			if element.Columns > 0 {
				arrayprefix = fmt.Sprintf("[][]")
				arraysuffix = fmt.Sprintf("[%d][%d]", element.Columns-1, element.Rows-1)
			} else {
				arrayprefix = fmt.Sprintf("[]")
				arraysuffix = fmt.Sprintf("[%d]", element.Rows-1)
			}
		}

		fieldType, bytes, err := getJavaParameterType(element.Type, component.NameSpace, "", "in", true)
		if err != nil {
			return err
		}

		if element.Rows > 0 {
			if element.Columns > 0 {
				arrayprefix = fmt.Sprintf("[][]")
				arraysuffix = fmt.Sprintf("[%d][%d]", element.Columns, element.Rows)
				byteSum = byteSum + bytes * element.Columns * element.Rows;
			} else {
				arrayprefix = fmt.Sprintf("[]")
				arraysuffix = fmt.Sprintf("[%d]", element.Rows)
				byteSum = byteSum + bytes * element.Rows;
			}
			w.Writeln("  public %s%s %s = new %s%s;", fieldType, arrayprefix, element.Name, fieldType, arraysuffix)
		} else {
			byteSum = byteSum + bytes;
			w.Writeln("  public %s %s;", fieldType, element.Name)
		}
		w.Writeln("")
	}
	w.Writeln("  public static final int SIZE = %d;", byteSum);
	w.Writeln("")

	// Write memory reader
	byteSum = 0
	w.Writeln("  public void readFromPointer(Pointer p, long offset) {");
	for j := 0; j < len(structinfo.Members); j++ {
		element := structinfo.Members[j]
		boolSuffix := ""

		fieldType, bytes, err := getJavaParameterType(element.Type, component.NameSpace, "", "in", true)
		if err != nil {
			return err
		}
		if element.Type == "bool" {
			boolSuffix = " != 0"
			fieldType = "byte"
		}

		if element.Rows > 0 {
			for k := 0; k < element.Rows; k++ {
				if element.Columns > 0 {
					for l := 0; l < element.Columns; l++ {
						w.Writeln("    %s[%d][%d] = p.get%s(offset + %d)%s;", element.Name, k, l, MakeFirstUpperCase(fieldType), byteSum, boolSuffix)
						byteSum = byteSum + bytes;
					}
				} else {
					w.Writeln("    %s[%d] = p.get%s(offset + %d)%s;", element.Name, k, MakeFirstUpperCase(fieldType), byteSum, boolSuffix)
					byteSum = byteSum + bytes;
				}
			}
		} else {
			w.Writeln("    %s = p.get%s(offset + %d)%s;", element.Name, MakeFirstUpperCase(fieldType), byteSum, boolSuffix)
			byteSum = byteSum + bytes;
		}
	}
	w.Writeln("  }");
	w.Writeln("")

	// Write memory writer
	byteSum = 0
	w.Writeln("  public void writeToPointer(Pointer p, long offset) {");
	for j := 0; j < len(structinfo.Members); j++ {
		element := structinfo.Members[j]
		value := element.Name
		fieldType, bytes, err := getJavaParameterType(element.Type, component.NameSpace, "", "in", true)
		if err != nil {
			return err
		}
		if element.Type == "bool" {
			value = "(byte) (" + element.Name + " ? 1 : 0)"
			fieldType = "byte"
		}

		if element.Rows > 0 {
			for k := 0; k < element.Rows; k++ {
				if element.Columns > 0 {
					for l := 0; l < element.Columns; l++ {
						w.Writeln("    p.set%s(offset + %d, %s[%d][%d]);", MakeFirstUpperCase(fieldType), byteSum, value, k, l, )
						byteSum = byteSum + bytes;
					}
				} else {
					w.Writeln("    p.set%s(offset + %d, %s[%d]);", MakeFirstUpperCase(fieldType), byteSum, value, k, )
					byteSum = byteSum + bytes;
				}
			}
		} else {
			w.Writeln("    p.set%s(offset + %d, %s);", MakeFirstUpperCase(fieldType), byteSum, value)
			byteSum = byteSum + bytes;
		}
	}
	w.Writeln("  }");
	w.Writeln("")

	w.Writeln("}")
	w.Writeln("")
	return nil
}

func buildJavaWrapper(component ComponentDefinition, w LanguageWriter, indent string) error {

	NameSpace := component.NameSpace
	JavaWrapperName := NameSpace + "Wrapper";

	w.Writeln("package %s;", strings.ToLower(component.NameSpace))
	w.Writeln("")
	w.Writeln("import com.sun.jna.*;")
	w.Writeln("")
	w.Writeln("import java.nio.charset.StandardCharsets;")
	w.Writeln("")

	for _, subComponent := range(component.ImportedComponentDefinitions) {
		w.Writeln("import %s.*;", strings.ToLower(subComponent.NameSpace))
	}
	w.Writeln("")

	w.Writeln("public class " + JavaWrapperName + " {")
	w.Writeln("")

	// Write enums and conversion functions
	for i := 0; i < len(component.Enums); i++ {
		enum := component.Enums[i]
		for j := 0; j < len(enum.Options); j++ {
				w.Writeln("  public static final int %s_%s = %d;", strings.ToUpper(enum.Name), strings.ToUpper(enum.Options[j].Name), enum.Options[j].Value)
		}
		w.Writeln("")
		w.Writeln("  public enum %s {", enum.Name)
		for j := 0; j < len(enum.Options); j++ {
			if j < len(enum.Options) - 1 {
				w.Writeln("    e" + enum.Options[j].Name + ",")
			} else {
				w.Writeln("    e" + enum.Options[j].Name)
			}
		}
		w.Writeln("  }")
		w.Writeln("")
	}
	if (len(component.Errors.Errors) > 0) {
		w.Writeln("  public static class EnumConversion {")
		for i := 0; i < len(component.Enums); i++ {
			enum := component.Enums[i]
			w.Writeln("    public static int convert%sToConst (%s value) throws %sException {", enum.Name, enum.Name, NameSpace)
			w.Writeln("      switch (value) {")
			for j := 0; j < len(enum.Options); j++ {
				w.Writeln("        case e%s: return %s_%s;", enum.Options[j].Name, strings.ToUpper(enum.Name), strings.ToUpper(enum.Options[j].Name))
			}
				w.Writeln("        default: throw new %sException(%sException.%s_ERROR_INVALIDPARAM, \"Unknown enum value : \" + value);", NameSpace, NameSpace, strings.ToUpper(NameSpace))
			w.Writeln("      }")
			w.Writeln("    }")
			w.Writeln("")
			w.Writeln("    public static %s convertConstTo%s (int value) throws %sException {", enum.Name, enum.Name, NameSpace)
			w.Writeln("      switch (value) {")
			for j := 0; j < len(enum.Options); j++ {
				w.Writeln("        case %s_%s: return %s.e%s;", strings.ToUpper(enum.Name), strings.ToUpper(enum.Options[j].Name), enum.Name, enum.Options[j].Name)
			}
				w.Writeln("        default: throw new %sException(%sException.%s_ERROR_INVALIDPARAM, \"Unknown enum const : \" + value);", NameSpace, NameSpace, strings.ToUpper(NameSpace))
			w.Writeln("      }")
			w.Writeln("    }")
			w.Writeln("")
		}
		w.Writeln("  }")
		w.Writeln("")
	}

	// Write callback functions
	for j:=0; j<len(component.Functions); j++ {
		function := component.Functions[j]
		w.Writeln("  public interface %s extends Callback {", function.FunctionName)
		w.Writeln("")
		nativeParams := ""
		for i := 0; i < len(function.Params); i++ {
			param := function.Params[i]

			javaParams, err := generatePlainJavaParameter(param, "", function.FunctionName, NameSpace)
			if err != nil {
				return err
			}

			for _, javaParam := range javaParams {
				if nativeParams != "" {
					nativeParams = nativeParams + ", "
				}
				nativeParams = nativeParams + javaParam.ParamConvention + javaParam.ParamType + " " + javaParam.ParamName
			}
		}
		w.Writeln("    void %s (%s);", MakeFirstLowerCase(function.FunctionName), nativeParams)
		w.Writeln("")
		w.Writeln("  }")
		w.Writeln("")
	}

	// Write wrapper functions
	for j:=0; j<len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]
		w.Writeln("  protected Function %s_%s;", strings.ToLower(NameSpace), strings.ToLower(method.MethodName))
	}
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		for j:=0; j<len(class.Methods); j++ {
			method := class.Methods[j]
			w.Writeln("  protected Function %s_%s_%s;", strings.ToLower(NameSpace), strings.ToLower(class.ClassName), strings.ToLower(method.MethodName))
		}
	}
	w.Writeln("")

	// Write wrapper member/constructor/checkError
	w.Writeln("  protected NativeLibrary mLibrary;")
	w.Writeln("")
	for _, subComponent := range(component.ImportedComponentDefinitions) {
		w.Writeln("  protected %sWrapper m%sWrapper;", subComponent.NameSpace, subComponent.NameSpace)
		w.Writeln("")
	}
	w.Writeln("  public " + JavaWrapperName + "(String libraryPath) {")
	w.Writeln("    mLibrary = NativeLibrary.getInstance(libraryPath);")

	for j:=0; j<len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]
		w.Writeln("    %s_%s = mLibrary.getFunction(\"%s_%s\");", strings.ToLower(NameSpace), strings.ToLower(method.MethodName), strings.ToLower(NameSpace), strings.ToLower(method.MethodName))
	}
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		classPrefix := strings.ToLower(NameSpace) + "_" + strings.ToLower(class.ClassName)
		for j:=0; j<len(class.Methods); j++ {
			method := class.Methods[j]
			w.Writeln("    %s_%s = mLibrary.getFunction(\"%s_%s\");", classPrefix, strings.ToLower(method.MethodName), classPrefix, strings.ToLower(method.MethodName))
		}
	}
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  public %s(Pointer lookupPointer) throws %sException {", JavaWrapperName, NameSpace)
	w.Writeln("    Function lookupMethod = Function.getFunction(lookupPointer);")
	for j:=0; j<len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]
		w.Writeln("    %s_%s = loadFunctionByLookup(lookupMethod, \"%s_%s\");", strings.ToLower(NameSpace), strings.ToLower(method.MethodName), strings.ToLower(NameSpace), strings.ToLower(method.MethodName))
	}
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		classPrefix := strings.ToLower(NameSpace) + "_" + strings.ToLower(class.ClassName)
		for j:=0; j<len(class.Methods); j++ {
			method := class.Methods[j]
			w.Writeln("    %s_%s = loadFunctionByLookup(lookupMethod, \"%s_%s\");", classPrefix, strings.ToLower(method.MethodName), classPrefix, strings.ToLower(method.MethodName))
		}
	}
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  protected void checkError(%s instance, int errorCode) throws %sException {", component.Global.BaseClassName, NameSpace)
	w.Writeln("    if (instance != null && instance.mWrapper != this) {")
	w.Writeln("      throw new %sException(%sException.%s_ERROR_INVALIDCAST, \"invalid wrapper call\");", NameSpace, NameSpace, strings.ToUpper(NameSpace))
	w.Writeln("    }")
	w.Writeln("    if (errorCode != %sException.%s_SUCCESS) {", NameSpace, strings.ToUpper(NameSpace))
	w.Writeln("      if (instance != null) {")
	w.Writeln("        %sResult result = %s(instance);", component.Global.ErrorMethod, MakeFirstLowerCase(component.Global.ErrorMethod))
	w.Writeln("        throw new %sException(errorCode, result.ErrorMessage);", NameSpace)
	w.Writeln("      } else {")
	w.Writeln("        throw new %sException(errorCode, \"\");", NameSpace)
	w.Writeln("      }")
	w.Writeln("    }")
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  private Function loadFunctionByLookup(Function lookupMethod, String functionName) throws %sException {", NameSpace)
	w.Writeln("    byte[] bytes = functionName.getBytes(StandardCharsets.UTF_8);")
	w.Writeln("    Memory name = new Memory(bytes.length+1);")
	w.Writeln("    name.write(0, bytes, 0, bytes.length);")
	w.Writeln("    name.setByte(bytes.length, (byte)0);")
	w.Writeln("    Pointer address = new Memory(8);")
	w.Writeln("    Object[] addressParam = new Object[]{name, address};")
	w.Writeln("    checkError(null, lookupMethod.invokeInt(addressParam));")
	w.Writeln("    return Function.getFunction(address.getPointer(0));")
	w.Writeln("  }")
	w.Writeln("")
	for _, subComponent := range(component.ImportedComponentDefinitions) {
		w.Writeln("  public %sWrapper get%sWrapper() {", subComponent.NameSpace, subComponent.NameSpace)
		w.Writeln("    return m%sWrapper;", subComponent.NameSpace)
		w.Writeln("  }")
		w.Writeln("")
	}

	// Write wrapper methods
	for j := 0; j < len(component.Global.Methods); j++ {
		method := component.Global.Methods[j]

		err := writeJavaClassMethodImplementation(method, w, NameSpace, "", indent, true)
		if err != nil {
			return err
		}
	}

	w.Writeln("}")
	w.Writeln("")

	return nil
}

func generateParametersForMethod(method ComponentDefinitionMethod, ClassName string, NameSpace string, isGlobal bool) (string, error) {
	parameters := "";
	if isGlobal {

	} else {

		parameters = fmt.Sprintf("Pointer %s", MakeFirstLowerCase(ClassName))
	}

	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]

		javaParams, err := generatePlainJavaParameter(param, ClassName, method.MethodName, NameSpace)
		if err != nil {
			return "", err
		}

		for _, javaParam := range javaParams {
			if parameters != "" {
				parameters = parameters + ", "
			}
			parameters = parameters + javaParam.ParamConvention + javaParam.ParamType + " " + javaParam.ParamName
		}

	}
	return parameters, nil;
}

func generatePlainJavaParameter(param ComponentDefinitionParam, className string, methodName string, NameSpace string) ([]JavaParameter, error) {
	cParams := make([]JavaParameter, 1)
	cParamTypeName, _, err := getJavaParameterType(param.ParamType, NameSpace, param.ParamClass, param.ParamPass, true)
	if err != nil {
		return nil, err
	}

	switch param.ParamPass {
	case "in":
		switch param.ParamType {
		case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "bool", "single", "double", "pointer", "string", "enum":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "struct":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "basicarray", "structarray":
			cParams = make([]JavaParameter, 2)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "Size"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - Number of elements in buffer", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = "Pointer"
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[1].ParamComment = fmt.Sprintf("* @param[in] %s - %s buffer of %s", cParams[1].ParamName, param.ParamClass, param.ParamDescription)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

		case "functiontype":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "class", "optionalclass":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		default:
			return nil, fmt.Errorf("invalid method parameter type \"%s\" for %s.%s(%s)", param.ParamType, className, methodName, param.ParamName)
		}

	case "out", "return":

		switch param.ParamType {

		case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "bool", "single", "double", "pointer", "enum":
			cParams[0].ParamType = "Pointer"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[out] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "struct":
			cParams[0].ParamType = cParamTypeName
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[out] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		case "basicarray":
			cParams = make([]JavaParameter, 3)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "Size"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - Number of elements in buffer", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = "Pointer"
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "NeededSize"
			cParams[1].ParamComment = fmt.Sprintf("* @param[out] %s - will be filled with the count of the written elements, or needed buffer size.", cParams[1].ParamName)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

			cParams[2].ParamType = "Pointer"
			cParams[2].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[2].ParamComment = fmt.Sprintf("* @param[out] %s - %s buffer of %s", cParams[2].ParamName, param.ParamClass, param.ParamDescription)
			cParams[2].ParamConvention = ""
			cParams[2].ParamTypeNoConvention = cParams[2].ParamType

		case "structarray":
			cParams = make([]JavaParameter, 3)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "Size"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - Number of elements in buffer", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = "Pointer"
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "NeededSize"
			cParams[1].ParamComment = fmt.Sprintf("* @param[out] %s - will be filled with the count of the written elements, or needed buffer size.", cParams[1].ParamName)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

			cParams[2].ParamType = "Pointer"
			cParams[2].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[2].ParamComment = fmt.Sprintf("* @param[out] %s - %s buffer of %s", cParams[2].ParamName, param.ParamClass, param.ParamDescription)
			cParams[2].ParamConvention = ""
			cParams[2].ParamTypeNoConvention = cParams[2].ParamType

		case "string":
			cParams = make([]JavaParameter, 3)
			cParams[0].ParamType = "int"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName) + "BufferSize"
			cParams[0].ParamComment = fmt.Sprintf("* @param[in] %s - size of the buffer (including trailing 0)", cParams[0].ParamName)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

			cParams[1].ParamType = "Pointer"
			cParams[1].ParamName = MakeFirstLowerCase(param.ParamName) + "NeededBuffer"
			cParams[1].ParamComment = fmt.Sprintf("* @param[out] %s - will be filled with the count of the written bytes, or needed buffer size.", cParams[1].ParamName)
			cParams[1].ParamConvention = ""
			cParams[1].ParamTypeNoConvention = cParams[1].ParamType

			cParams[2].ParamType = "Pointer"
			cParams[2].ParamName = MakeFirstLowerCase(param.ParamName) + "Buffer"
			cParams[2].ParamComment = fmt.Sprintf("* @param[out] %s - %s buffer of %s, may be NULL", cParams[2].ParamName, param.ParamClass, param.ParamDescription)
			cParams[2].ParamConvention = ""
			cParams[2].ParamTypeNoConvention = cParams[2].ParamType

		case "class", "optionalclass":
			cParams[0].ParamType = "Pointer"
			cParams[0].ParamName = MakeFirstLowerCase(param.ParamName)
			cParams[0].ParamComment = fmt.Sprintf("* @param[out] %s - %s", cParams[0].ParamName, param.ParamDescription)
			cParams[0].ParamConvention = ""
			cParams[0].ParamTypeNoConvention = cParams[0].ParamType

		default:
			return nil, fmt.Errorf("invalid method parameter type \"%s\" for %s.%s(%s)", param.ParamType, className, methodName, param.ParamName)
		}


	default:
		return nil, fmt.Errorf("invalid method parameter passing \"%s\" for %s.%s(%s)", param.ParamPass, className, methodName, param.ParamName)
	}

	return cParams, nil
}

func getJavaParameterType(ParamTypeName string, NameSpace string, ParamClass string, ParamPass string, isPlain bool) (string, int, error) {
	JavaParamTypeName := ""
	Bytes := 0;
	switch ParamTypeName {
	case "uint8":
		JavaParamTypeName = "char"
		Bytes = 1;

	case "uint16", "int16":
		JavaParamTypeName = "short"
		Bytes = 2;

	case "uint32", "int32":
		JavaParamTypeName = "int"
		Bytes = 4;

	case "uint64", "int64":
		JavaParamTypeName = "long"
		Bytes = 8;

	case "int8":
		JavaParamTypeName = "byte"
		Bytes = 1;

	case "bool":
		JavaParamTypeName = "boolean"
		Bytes = 1;

	case "single":
		JavaParamTypeName = "float"
		Bytes = 4;

	case "double":
		JavaParamTypeName = "double"
		Bytes = 8;

	case "pointer":
		JavaParamTypeName = "Pointer"
		Bytes = 8;

	case "string":
		JavaParamTypeName = "String"

	case "enum":
		if isPlain {
			JavaParamTypeName = "int"
		} else {
			JavaParamTypeName = NameSpace + "Wrapper." + ParamClass
		}
		Bytes = 4;

	case "functiontype":
		JavaParamTypeName = NameSpace + "Wrapper." + ParamClass

	case "struct":
		if isPlain {
			JavaParamTypeName = "Pointer"
		} else {
			JavaParamTypeName = ParamClass
		}


	case "basicarray":
		basicTypeName, SubBytes, err := getJavaParameterType(ParamClass, NameSpace, "", "in", isPlain)
		if err != nil {
			return "", 0, err
		}
		Bytes = SubBytes
		if isPlain {
			JavaParamTypeName = "Pointer"
		} else {
			if ParamPass == "out" {
				JavaParamTypeName = fmt.Sprintf("%sWrapper.%sArrayOut", NameSpace, MakeFirstUpperCase(basicTypeName))
			} else {
				JavaParamTypeName = fmt.Sprintf("%s[]", basicTypeName)
			}
		}

	case "structarray":
		if isPlain {
			JavaParamTypeName = "Pointer"
		} else {
			JavaParamTypeName = ParamClass + "[]"
		}

	case "class", "optionalclass":
		if isPlain {
			JavaParamTypeName = fmt.Sprintf("Pointer")
		} else {
			SubNameSpace, SubClassName, _ := decomposeParamClassName(ParamClass)
			if len(SubNameSpace) > 0 {
				JavaParamTypeName = fmt.Sprintf("%s", SubClassName)
			} else {
				JavaParamTypeName = fmt.Sprintf("%s", ParamClass)
			}
		}

	default:
		return "", Bytes, fmt.Errorf("invalid parameter type \"%s\" for Java parameter", ParamTypeName)
	}

	if isPlain {
		if ParamTypeName == "string" {
			JavaParamTypeName = "Pointer"
		}
		if ParamTypeName == "enum" {
			JavaParamTypeName = "int"
		}
	}

	return JavaParamTypeName, Bytes, nil
}

func MakeFirstLowerCase(s string) string {
    
    if len(s) < 2 {
        return strings.ToLower(s)
    }
    
    bts := []byte(s)
    
    lc := bytes.ToLower([]byte{bts[0]})
    rest := bts[1:]
    
    return string(bytes.Join([][]byte{lc, rest}, nil))   
}

func MakeFirstUpperCase(s string) string {
    
    if len(s) < 2 {
        return strings.ToLower(s)
    }
    
    bts := []byte(s)
    
    lc := bytes.ToUpper([]byte{bts[0]})
    rest := bts[1:]
    
    return string(bytes.Join([][]byte{lc, rest}, nil))   
}
