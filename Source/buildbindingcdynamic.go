/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildbindingcdynamic.go
// functions to generate dynamic C-bindings of a library's API in form of dynamically loaded functions
// handles.
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"fmt"
	"log"
	"path"
	"strings"
	"path/filepath"
)

// BuildBindingCDynamic builds dyanmic C-bindings of a library's API in form of dynamically loaded functions
// handles.
func BuildBindingCDynamic(component ComponentDefinition, outputFolder string, indentString string) error {

	namespace := component.NameSpace;
	libraryname := component.LibraryName;
	baseName := component.BaseName;

	DynamicCHeader := path.Join(outputFolder, baseName+"_dynamic.h");
	log.Printf("Creating \"%s\"", DynamicCHeader)
	dynhfile, err := CreateLanguageFile(DynamicCHeader, indentString)
	if err != nil {
		return err;
	}
	dynhfile.WriteCLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated plain C Header file in order to allow an easy\n use of %s", libraryname),
		true)
	err = buildDynamicCHeader(component, dynhfile, namespace, baseName, false)
	if err != nil {
		return err;
	}

	DynamicCImpl := path.Join(outputFolder, baseName+"_dynamic.cpp");
	log.Printf("Creating \"%s\"", DynamicCImpl)
	dyncppfile, err := CreateLanguageFile(DynamicCImpl, indentString)
	if err != nil {
		return err;
	}
	dyncppfile.WriteCLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated plain C Header file in order to allow an easy\n use of %s", libraryname),
		true)
	
	err = buildDynamicCppImplementation(component, dyncppfile, namespace, baseName)
	if err != nil {
		return err;
	}
	
	return nil;
}

func buildDynamicCHeader(component ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string, headerOnly bool) error {
	w.Writeln("#ifndef __%s_DYNAMICHEADER", strings.ToUpper(NameSpace))
	w.Writeln("#define __%s_DYNAMICHEADER", strings.ToUpper(NameSpace))
	w.Writeln("")

	w.Writeln("#include \"%s_types.h\"", BaseName)
	w.Writeln("")

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]

		w.Writeln("")
		w.Writeln("/*************************************************************************************************************************")
		w.Writeln(" Class definition for %s", class.ClassName)
		w.Writeln("**************************************************************************************************************************/")

		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			WriteCMethod(method, w, NameSpace, class.ClassName, false, true)
		}

	}

	w.Writeln("")
	w.Writeln("/*************************************************************************************************************************")
	w.Writeln(" Global functions")
	w.Writeln("**************************************************************************************************************************/")

	global := component.Global;
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		err := WriteCMethod(method, w, NameSpace, "Wrapper", true, true)
		if err != nil {
			return err
		}

	}

	w.Writeln("")
	w.Writeln("/*************************************************************************************************************************")
	w.Writeln(" Function Table Structure")
	w.Writeln("**************************************************************************************************************************/")
	w.Writeln("")
	w.Writeln("typedef struct {")
	w.Writeln("  void * m_LibraryHandle;")

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			w.Writeln("  P%s%s_%sPtr m_%s_%s;", NameSpace, class.ClassName, method.MethodName, class.ClassName, method.MethodName)
		}
	}

	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		w.Writeln("  P%s%sPtr m_%s;", NameSpace, method.MethodName, method.MethodName)
	}

	w.Writeln("} s%sDynamicWrapperTable;", NameSpace)
	w.Writeln("")
	
	if (!headerOnly) {

		w.Writeln("/*************************************************************************************************************************")
		w.Writeln(" Load DLL dynamically")
		w.Writeln("**************************************************************************************************************************/")

		w.Writeln("%sResult Init%sWrapperTable (s%sDynamicWrapperTable * pWrapperTable);", NameSpace, NameSpace, NameSpace)
		w.Writeln("%sResult Release%sWrapperTable (s%sDynamicWrapperTable * pWrapperTable);", NameSpace, NameSpace, NameSpace)
		w.Writeln("%sResult Load%sWrapperTable (s%sDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);", NameSpace, NameSpace, NameSpace)

		w.Writeln("")
	}
	
	w.Writeln("#endif // __%s_DYNAMICHEADER", strings.ToUpper(NameSpace))
	w.Writeln("")

	return nil
}


func buildDynamicCInitTableCode(component ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {
	global := component.Global;
	
	w.Writeln("if (pWrapperTable == nullptr)")
	w.Writeln("  return %s_ERROR_INVALIDPARAM;", strings.ToUpper(NameSpace))
	w.Writeln("")
	w.Writeln("pWrapperTable->m_LibraryHandle = nullptr;")

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			w.Writeln("pWrapperTable->m_%s_%s = nullptr;", class.ClassName, method.MethodName)
		}
	}

	global = component.Global
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		w.Writeln("pWrapperTable->m_%s = nullptr;", method.MethodName)
	}

	w.Writeln("")
	w.Writeln("return %s_SUCCESS;", strings.ToUpper(NameSpace))
	
	return nil;
}


func buildDynamicCReleaseTableCode(component ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string, initWrapperFunctionName string) error {

	w.Writeln("if (pWrapperTable == nullptr)")
	w.Writeln("  return %s_ERROR_INVALIDPARAM;", strings.ToUpper(NameSpace))
	w.Writeln("")
	w.Writeln("if (pWrapperTable->m_LibraryHandle != nullptr) {")
	w.Writeln("#ifdef WIN32")
	w.Writeln("  HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;")
	w.Writeln("  FreeLibrary (hModule);")
	w.Writeln("#else // WIN32")
	w.Writeln("  dlclose (pWrapperTable->m_LibraryHandle);")
	w.Writeln("#endif // WIN32")
	w.Writeln("  return %s (pWrapperTable);", initWrapperFunctionName)
	w.Writeln("}")
	w.Writeln("")
	w.Writeln("return %s_SUCCESS;", strings.ToUpper(NameSpace))

	return nil;
}


func buildDynamicCLoadTableCode(component ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	global := component.Global;

	w.Writeln("if (pWrapperTable == nullptr)")
	w.Writeln("  return %s_ERROR_INVALIDPARAM;", strings.ToUpper(NameSpace))
	w.Writeln("if (pLibraryFileName == nullptr)")
	w.Writeln("  return %s_ERROR_INVALIDPARAM;", strings.ToUpper(NameSpace))

	w.Writeln("")


	w.Writeln("#ifdef WIN32")
	// TODO: Unicode
	w.Writeln("HMODULE hLibrary = LoadLibraryA (pLibraryFileName);")
	w.Writeln("if (hLibrary == 0) ")
	w.Writeln("  return %s_ERROR_COULDNOTLOADLIBRARY;", strings.ToUpper(NameSpace))
	w.Writeln("#else // WIN32")
	w.Writeln("void* hLibrary = dlopen (pLibraryFileName, RTLD_LAZY);")
	w.Writeln("if (hLibrary == 0) ")
	w.Writeln("  return %s_ERROR_COULDNOTLOADLIBRARY;", strings.ToUpper(NameSpace))
	w.Writeln("dlerror();");
	w.Writeln("#endif // WIN32")
	w.Writeln("")
	
	for i := 0; i < len(component.Classes); i++ {

		class := component.Classes[i]
		for j := 0; j < len(class.Methods); j++ {

			method := class.Methods[j]
			w.Writeln("#ifdef WIN32")
			w.Writeln("pWrapperTable->m_%s_%s = (P%s%s_%sPtr) GetProcAddress (hLibrary, \"%s_%s_%s%s\");", class.ClassName, method.MethodName, NameSpace, class.ClassName, method.MethodName, strings.ToLower(NameSpace), strings.ToLower(class.ClassName), strings.ToLower(method.MethodName), method.DLLSuffix)
			w.Writeln("#else // WIN32")
			w.Writeln("pWrapperTable->m_%s_%s = (P%s%s_%sPtr) dlsym (hLibrary, \"%s_%s_%s%s\");", class.ClassName, method.MethodName, NameSpace, class.ClassName, method.MethodName, strings.ToLower(NameSpace), strings.ToLower(class.ClassName), strings.ToLower(method.MethodName), method.DLLSuffix)
			w.Writeln("dlerror();")
			w.Writeln("#endif // WIN32")
			w.Writeln("if (pWrapperTable->m_%s_%s == nullptr)", class.ClassName, method.MethodName)
			w.Writeln("  return %s_ERROR_COULDNOTFINDLIBRARYEXPORT;", strings.ToUpper(NameSpace))
			w.Writeln("")
		}
	}

	global = component.Global
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		w.Writeln("#ifdef WIN32")
		w.Writeln("pWrapperTable->m_%s = (P%s%sPtr) GetProcAddress (hLibrary, \"%s_%s%s\");", method.MethodName, NameSpace, method.MethodName, strings.ToLower(NameSpace), strings.ToLower(method.MethodName), method.DLLSuffix)
		w.Writeln("#else // WIN32")
		w.Writeln("pWrapperTable->m_%s = (P%s%sPtr) dlsym (hLibrary, \"%s_%s%s\");", method.MethodName, NameSpace, method.MethodName, strings.ToLower(NameSpace), strings.ToLower(method.MethodName), method.DLLSuffix)
		w.Writeln("dlerror();")
		w.Writeln("#endif // WIN32")

		w.Writeln("if (pWrapperTable->m_%s == nullptr)", method.MethodName)
		w.Writeln("  return %s_ERROR_COULDNOTFINDLIBRARYEXPORT;", strings.ToUpper(NameSpace))
		w.Writeln("")
	}

	w.Writeln("pWrapperTable->m_LibraryHandle = hLibrary;")
	w.Writeln("return %s_SUCCESS;", strings.ToUpper(NameSpace))

	return nil;
}

func buildDynamicCppImplementation(component ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln("#include \"%s_types.h\"", BaseName)
	w.Writeln("#include \"%s_dynamic.h\"", BaseName)

	w.Writeln("#ifdef WIN32")
	w.Writeln("#include <Windows.h>")
	w.Writeln("#else // WIN32")
	w.Writeln("#include <dlfcn.h>")
	w.Writeln("#endif // WIN32")

	w.Writeln("")
	w.Writeln("%sResult Init%sWrapperTable (s%sDynamicWrapperTable * pWrapperTable)", NameSpace, NameSpace, NameSpace)
	w.Writeln("{")
	
	w.AddIndentationLevel(1)
	buildDynamicCInitTableCode(component, w, NameSpace, BaseName);
	w.AddIndentationLevel(-1)

	w.Writeln("}")

	w.Writeln("")
	w.Writeln("%sResult Release%sWrapperTable (s%sDynamicWrapperTable * pWrapperTable)", NameSpace, NameSpace, NameSpace)
	w.Writeln("{")
	
	w.AddIndentationLevel(1)
	buildDynamicCReleaseTableCode (component, w, NameSpace, BaseName, "Init" + NameSpace + "WrapperTable");
	w.AddIndentationLevel(-1)

	w.Writeln("}")

	w.Writeln("")
	w.Writeln("%sResult Load%sWrapperTable (s%sDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)", NameSpace, NameSpace, NameSpace)
	w.Writeln("{")
	
	w.AddIndentationLevel(1)
	buildDynamicCLoadTableCode (component, w, NameSpace, BaseName);
	w.AddIndentationLevel(-1)

	w.Writeln("}")
	w.Writeln("")

	return nil
}


func writeDynamicCPPMethodDeclaration(method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, isGlobal bool) error {
	parameters := ""
	returntype := "void"

	for k := 0; k < len(method.Params); k++ {

		param := method.Params[k]
		variableName := getBindingCppVariableName(param)

		switch param.ParamPass {
		case "in":

			if parameters != "" {
				parameters = parameters + ", "
			}

			cppParamType := getBindingCppParamType(param, NameSpace, true)

			switch param.ParamType {
			case "string":
				parameters = parameters + fmt.Sprintf("const %s & %s", cppParamType, variableName);
			case "struct":
				parameters = parameters + fmt.Sprintf("const %s & %s", cppParamType, variableName);
			case "structarray", "basicarray":
				parameters = parameters + fmt.Sprintf("const %s & %s", cppParamType, variableName);
			case "handle":
				parameters = parameters + fmt.Sprintf("%s %s", cppParamType, variableName)

			default:
				parameters = parameters + fmt.Sprintf("const %s %s", cppParamType, variableName)
			}

		case "out":
			cppParamType := getBindingCppParamType(param, NameSpace, false)
	
			if parameters != "" {
				parameters = parameters + ", "
			}
			parameters = parameters + fmt.Sprintf("%s & %s", cppParamType, variableName)


		case "return":
			returntype = getBindingCppParamType(param, NameSpace, false)

		default:
			return fmt.Errorf("invalid method parameter passing \"%s\" for %s.%s (%s)", param.ParamPass, ClassName, method.MethodName, param.ParamName)
		}

	}
	
	w.Writeln("    %s %s (%s);", returntype, method.MethodName, parameters);

	return nil
}



func writeDynamicCPPMethod(method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, isGlobal bool, includeComments bool) error {

	CMethodName := ""
	requiresInitCall := false;
	initCallParameters := ""	// usually used to check sizes of buffers
	callParameters := ""
	checkErrorCode := ""
	makeSharedParameter := "";

	if isGlobal {
		CMethodName = fmt.Sprintf("m_WrapperTable.m_%s", method.MethodName)
		checkErrorCode = "CheckError (nullptr,"
		makeSharedParameter = "this, "
	} else {
		CMethodName = fmt.Sprintf("m_pWrapper->m_WrapperTable.m_%s_%s", ClassName, method.MethodName)
		callParameters = "m_pHandle"
		initCallParameters = "m_pHandle"
		checkErrorCode = "CheckError ("
		makeSharedParameter = "m_pWrapper, "
	}

	parameters := ""
	returntype := "void"

	definitionCodeLines := []string{}
	functionCodeLines := []string{}
	returnCodeLines := []string{}
	commentcodeLines := []string{}
	postCallCodeLines := []string{}

	cppClassPrefix := "C" + NameSpace
	cppClassName := cppClassPrefix + ClassName

	for k := 0; k < len(method.Params); k++ {

		param := method.Params[k]
		variableName := getBindingCppVariableName(param)

		callParameter := "";
		initCallParameter := "";

		switch param.ParamPass {
		case "in":

			if parameters != "" {
				parameters = parameters + ", "
			}

			cppParamType := getBindingCppParamType(param, NameSpace, true)
			commentcodeLines = append(commentcodeLines, fmt.Sprintf("* @param[in] %s - %s", variableName, param.ParamDescription) )

			switch param.ParamType {
			case "string":
				callParameter = variableName + ".c_str()"
				initCallParameter = callParameter;
				parameters = parameters + fmt.Sprintf("const %s & %s", cppParamType, variableName);
			case "struct":
				callParameter = "&" + variableName
				initCallParameter = callParameter;
				parameters = parameters + fmt.Sprintf("const %s & %s", cppParamType, variableName);
			case "structarray", "basicarray":
				callParameter = fmt.Sprintf("(%s_uint64)%s.size(), %s.data()", NameSpace, variableName, variableName);
				initCallParameter = callParameter;
				parameters = parameters + fmt.Sprintf("const %s & %s", cppParamType, variableName);
			case "handle":
				functionCodeLines = append(functionCodeLines, fmt.Sprintf("%sHandle h%s = nullptr;", NameSpace, param.ParamName))
				functionCodeLines = append(functionCodeLines, fmt.Sprintf("if (%s != nullptr) {", variableName))
				functionCodeLines = append(functionCodeLines, fmt.Sprintf("  h%s = %s->GetHandle ();", param.ParamName, variableName))
				functionCodeLines = append(functionCodeLines, fmt.Sprintf("};"))
				callParameter = "h" + param.ParamName;
				initCallParameter = callParameter;
				parameters = parameters + fmt.Sprintf("%s %s", cppParamType, variableName)

			default:
				callParameter = variableName;
				initCallParameter = callParameter;
				parameters = parameters + fmt.Sprintf("const %s %s", cppParamType, variableName)
			}

		case "out":
			cppParamType := getBindingCppParamType(param, NameSpace, false)
			commentcodeLines = append(commentcodeLines, fmt.Sprintf("* @param[out] %s - %s", variableName, param.ParamDescription))

			if parameters != "" {
				parameters = parameters + ", "
			}
			parameters = parameters + fmt.Sprintf("%s & %s", cppParamType, variableName)

			switch param.ParamType {

			case "string":
				requiresInitCall = true;
				definitionCodeLines = append(definitionCodeLines, fmt.Sprintf("%s_uint32 bytesNeeded%s = 0;", NameSpace, param.ParamName))
				definitionCodeLines = append(definitionCodeLines, fmt.Sprintf("%s_uint32 bytesWritten%s = 0;", NameSpace, param.ParamName))
				initCallParameter = fmt.Sprintf("0, &bytesNeeded%s, nullptr", param.ParamName);
				
				functionCodeLines = append(functionCodeLines, fmt.Sprintf("std::vector<char> buffer%s;", param.ParamName))
				functionCodeLines = append(functionCodeLines, fmt.Sprintf("buffer%s.resize(bytesNeeded%s + 2);", param.ParamName, param.ParamName))

				callParameter = fmt.Sprintf("bytesNeeded%s + 2, &bytesWritten%s, &buffer%s[0]", param.ParamName, param.ParamName, param.ParamName)

				postCallCodeLines = append(postCallCodeLines, fmt.Sprintf("buffer%s[bytesNeeded%s + 1] = 0;", param.ParamName, param.ParamName) )
				postCallCodeLines = append(postCallCodeLines, fmt.Sprintf("s%s = std::string(&buffer%s[0]);", param.ParamName, param.ParamName) )

			case "handle":
				// NOTTESTED
				definitionCodeLines = append(definitionCodeLines, fmt.Sprintf("%sHandle h%s = nullptr;", NameSpace, param.ParamName) )
				callParameter = fmt.Sprintf("&h%s", param.ParamName)
				initCallParameter = callParameter;
				postCallCodeLines = append(postCallCodeLines, fmt.Sprintf("p%s = std::make_shared<%s%s> (h%s);", param.ParamName, cppClassPrefix, param.ParamClass, param.ParamName) )

			case "structarray", "basicarray":
				requiresInitCall = true;
				definitionCodeLines = append(definitionCodeLines, fmt.Sprintf("%s_uint64 elementsNeeded%s = 0;", NameSpace, param.ParamName) )
				definitionCodeLines = append(definitionCodeLines, fmt.Sprintf("%s_uint64 elementsWritten%s = 0;", NameSpace, param.ParamName) )
				initCallParameter = fmt.Sprintf("0, &elementsNeeded%s, nullptr", param.ParamName);

				functionCodeLines = append(functionCodeLines, fmt.Sprintf("%s.resize(elementsNeeded%s);", variableName, param.ParamName));
				callParameter = fmt.Sprintf("elementsNeeded%s, &elementsWritten%s, %s.data()", param.ParamName, param.ParamName, variableName)

			default:
				callParameter = "&" + variableName
				initCallParameter = callParameter
			}

		case "return":
			commentcodeLines = append(commentcodeLines, fmt.Sprintf("* @return %s", param.ParamDescription) )
			returntype = getBindingCppParamType(param, NameSpace, false)

			switch param.ParamType {
			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "bool", "single", "double":
				callParameter = fmt.Sprintf("&result%s", param.ParamName)
				initCallParameter = callParameter;
				definitionCodeLines = append(definitionCodeLines, fmt.Sprintf("%s result%s = 0;", returntype, param.ParamName) )
				returnCodeLines = append(returnCodeLines, fmt.Sprintf("return result%s;", param.ParamName))

			case "string":
				requiresInitCall = true;
				definitionCodeLines = append(definitionCodeLines, fmt.Sprintf("%s_uint32 bytesNeeded%s = 0;", NameSpace, param.ParamName))
				definitionCodeLines = append(definitionCodeLines, fmt.Sprintf("%s_uint32 bytesWritten%s = 0;", NameSpace, param.ParamName))
				initCallParameter = fmt.Sprintf("0, &bytesNeeded%s, nullptr", param.ParamName);

				functionCodeLines = append(functionCodeLines, fmt.Sprintf("std::vector<char> buffer%s;", param.ParamName))
				functionCodeLines = append(functionCodeLines, fmt.Sprintf("buffer%s.resize(bytesNeeded%s + 2);", param.ParamName, param.ParamName))

				callParameter = fmt.Sprintf("bytesNeeded%s + 2, &bytesWritten%s, &buffer%s[0]", param.ParamName, param.ParamName, param.ParamName)

				postCallCodeLines = append(postCallCodeLines, fmt.Sprintf("buffer%s[bytesNeeded%s + 1] = 0;", param.ParamName, param.ParamName))
				returnCodeLines = append(returnCodeLines, fmt.Sprintf("return std::string(&buffer%s[0]);", param.ParamName))

			case "enum":
				callParameter = fmt.Sprintf("&result%s", param.ParamName)
				initCallParameter = callParameter;
				definitionCodeLines = append(definitionCodeLines, fmt.Sprintf("e%s%s result%s = (e%s%s) 0;", NameSpace, param.ParamClass, param.ParamName, NameSpace, param.ParamClass))
				returnCodeLines = append(returnCodeLines, fmt.Sprintf("return result%s;", param.ParamName))

			case "struct":
				callParameter = fmt.Sprintf("&result%s", param.ParamName)
				initCallParameter = callParameter;
				definitionCodeLines = append(definitionCodeLines, fmt.Sprintf("s%s%s result%s;", NameSpace, param.ParamClass, param.ParamName))
				returnCodeLines = append(returnCodeLines, fmt.Sprintf("return result%s;", param.ParamName))

			case "handle":
				definitionCodeLines = append(definitionCodeLines, fmt.Sprintf("%sHandle h%s = nullptr;", NameSpace, param.ParamName))
				callParameter = fmt.Sprintf("&h%s", param.ParamName)
				initCallParameter = callParameter;
				returnCodeLines = append(returnCodeLines, fmt.Sprintf("return std::make_shared<%s%s> (%sh%s);", cppClassPrefix, param.ParamClass, makeSharedParameter, param.ParamName))

			case "basicarray":
				return fmt.Errorf("can not return basicarray \"%s\" for %s.%s (%s)", param.ParamPass, ClassName, method.MethodName, param.ParamName)

			case "structarray":
				return fmt.Errorf("can not return structarray \"%s\" for %s.%s (%s)", param.ParamPass, ClassName, method.MethodName, param.ParamName)

			default:
				return fmt.Errorf("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName)
			}

		default:
			return fmt.Errorf("invalid method parameter passing \"%s\" for %s.%s (%s)", param.ParamPass, ClassName, method.MethodName, param.ParamName)
		}

		if callParameters != "" {
			callParameters = callParameters + ", "
		}
		callParameters = callParameters + callParameter;
		if (initCallParameters != "") {
			initCallParameters = initCallParameters + ", ";
		}
		initCallParameters = initCallParameters + initCallParameter;
	}

	w.Writeln("  ")
	if (includeComments) {
		w.Writeln("  /**")
		w.Writeln("  * %s::%s - %s", cppClassName, method.MethodName, method.MethodDescription)
		w.Writelns("  ", commentcodeLines)
		w.Writeln("  */")
	}
	
	if (isGlobal) {	
		w.Writeln("  inline %s %s::%s (%s)", returntype, cppClassName, method.MethodName, parameters)
	} else {
		w.Writeln("  %s %s::%s (%s)", returntype, cppClassName, method.MethodName, parameters)
	}

	w.Writeln("  {")
	w.Writelns("    ", definitionCodeLines)
	if (requiresInitCall) {
		w.Writeln("    %s %s (%s) );", checkErrorCode, CMethodName, initCallParameters)
	}
	w.Writelns("    ", functionCodeLines)
	w.Writeln("    %s %s (%s) );", checkErrorCode, CMethodName, callParameters)
	w.Writelns("    ", postCallCodeLines)
	w.Writelns("    ", returnCodeLines)
	w.Writeln("  }")

	return nil
}


func buildDynamicCppHeader(component ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	global := component.Global
	
	cppClassPrefix := "C" + NameSpace
	
	w.Writeln("#ifndef __%s_DYNAMICCPPHEADER", strings.ToUpper(NameSpace))
	w.Writeln("#define __%s_DYNAMICCPPHEADER", strings.ToUpper(NameSpace))
	w.Writeln("")

	w.Writeln("#include \"%s_types.h\"", BaseName)
	w.Writeln("#include \"%s_dynamic.h\"", BaseName)
	w.Writeln("")

	w.Writeln("#ifdef WIN32") 
	w.Writeln("#include <Windows.h>")
	w.Writeln("#else // WIN32") 
	w.Writeln("#include <dlfcn.h>")
	w.Writeln("#endif // WIN32") 
	w.Writeln("#include <string>")
	w.Writeln("#include <memory>")
	w.Writeln("#include <vector>")
	w.Writeln("#include <exception>")
	w.Writeln("")

	w.Writeln("namespace %s {", NameSpace)
	w.Writeln("")

	w.Writeln("/*************************************************************************************************************************")
	w.Writeln(" Forward Declaration of all classes ")
	w.Writeln("**************************************************************************************************************************/")
	w.Writeln("")

	w.Writeln("class %sBaseClass;", cppClassPrefix)
	w.Writeln("class %sWrapper;", cppClassPrefix)
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		w.Writeln("class %s%s;", cppClassPrefix, class.ClassName)
	}

	w.Writeln("")

	w.Writeln("/*************************************************************************************************************************")
	w.Writeln(" Declaration of shared pointer types ")
	w.Writeln("**************************************************************************************************************************/")

	w.Writeln("")

	w.Writeln("typedef std::shared_ptr<%sBaseClass> P%sBaseClass;", cppClassPrefix, NameSpace)
	w.Writeln("typedef std::shared_ptr<%sWrapper> P%sWrapper;", cppClassPrefix, NameSpace)
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		w.Writeln("typedef std::shared_ptr<%s%s> P%s%s;", cppClassPrefix, class.ClassName, NameSpace, class.ClassName)
	}

	w.Writeln("")
	w.Writeln("/*************************************************************************************************************************")
	w.Writeln(" Class E%sException ", NameSpace)
	w.Writeln("**************************************************************************************************************************/")
	w.Writeln("class E%sException : public std::exception {", NameSpace)
	w.Writeln("protected:")
	w.Writeln("  /**")
	w.Writeln("  * Error code for the Exception.")
	w.Writeln("  */")
	w.Writeln("  %sResult m_errorCode;", NameSpace)
	w.Writeln("  /**")
	w.Writeln("  * Error message for the Exception.")
	w.Writeln("  */")
	w.Writeln("  std::string m_errorMessage;")
	w.Writeln("")
	w.Writeln("public:")
	w.Writeln("  /**")
	w.Writeln("  * Exception Constructor.")
	w.Writeln("  */")
	w.Writeln("  E%sException (%sResult errorCode)", NameSpace, NameSpace)
	w.Writeln("    : m_errorMessage(\"%s Error \" + std::to_string (errorCode))", NameSpace)
	w.Writeln("  {")
	w.Writeln("    m_errorCode = errorCode;")
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  /**")
	w.Writeln("  * Returns error code")
	w.Writeln("  */")
	w.Writeln("  %sResult getErrorCode ()", NameSpace)
	w.Writeln("  {")
	w.Writeln("    return m_errorCode;")
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  /**")
	w.Writeln("  * Returns error message")
	w.Writeln("  */")
	w.Writeln("  const char* what () const noexcept")
	w.Writeln("  {")
	w.Writeln("    return m_errorMessage.c_str();")
	w.Writeln("  }")
	w.Writeln("")

	w.Writeln("};")

	w.Writeln("")

	err := writeCPPInputVector(w, NameSpace)
	if err != nil {
		return err
	}
	w.Writeln("")

	w.Writeln("/*************************************************************************************************************************")
	w.Writeln(" Class %sWrapper ", cppClassPrefix)
	w.Writeln("**************************************************************************************************************************/")

	w.Writeln("class %sWrapper {", cppClassPrefix)
	w.Writeln("public:")
	
	w.Writeln("  ")
	w.Writeln("  %sWrapper (const std::string &sFileName)", cppClassPrefix)
	w.Writeln("  {")
	w.Writeln("    CheckError (nullptr, initWrapperTable (&m_WrapperTable));")
	w.Writeln("    CheckError (nullptr, loadWrapperTable (&m_WrapperTable, sFileName.c_str ()));")
	w.Writeln("    ")
	w.Writeln("    CheckError(nullptr, checkBinaryVersion());")
	w.Writeln("  }")
	w.Writeln("  ")
	
	w.Writeln("  static P%sWrapper loadLibrary (const std::string &sFileName)", NameSpace)	
	w.Writeln("  {");
	w.Writeln("    return std::make_shared<%sWrapper> (sFileName);", cppClassPrefix);
	w.Writeln("  }")
	w.Writeln("  ")
	

	w.Writeln("  ~%sWrapper ()", cppClassPrefix)
	w.Writeln("  {")
	w.Writeln("    releaseWrapperTable (&m_WrapperTable);")
	w.Writeln("  }")
	w.Writeln("  ")
	
	w.Writeln("  void CheckError(%sHandle handle, %sResult nResult)", NameSpace, NameSpace)
	w.Writeln("  {")
	w.Writeln("    if (nResult != 0) ")
	w.Writeln("      throw E%sException (nResult);", NameSpace)
	w.Writeln("  }")
	w.Writeln("  ")
	
	w.Writeln("")

	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]

		err := writeDynamicCPPMethodDeclaration(method, w, NameSpace, "Wrapper", true)
		if err != nil {
			return err
		}
	}
	
	w.Writeln("")
	w.Writeln("private:")
	w.Writeln("  s%sDynamicWrapperTable m_WrapperTable;", NameSpace)
	w.Writeln("")

	w.Writeln("  %sResult checkBinaryVersion()", NameSpace)
	w.Writeln("  {")
	w.Writeln("    %s_uint32 nMajor, nMinor, nMicro;", NameSpace)
	w.Writeln("    %s(nMajor, nMinor, nMicro);", global.VersionMethod)
	w.Writeln("    if ( (nMajor != %s_VERSION_MAJOR) || (nMinor < %s_VERSION_MINOR) ) {", strings.ToUpper(NameSpace), strings.ToUpper(NameSpace) )
	w.Writeln("      return %s_ERROR_INCOMPATIBLEBINARYVERSION;", strings.ToUpper(NameSpace))
	w.Writeln("    }")
	w.Writeln("    return %s_SUCCESS;", strings.ToUpper(NameSpace))
	w.Writeln("  }")

	w.Writeln("  %sResult initWrapperTable (s%sDynamicWrapperTable * pWrapperTable);", NameSpace, NameSpace)
	w.Writeln("  %sResult releaseWrapperTable (s%sDynamicWrapperTable * pWrapperTable);", NameSpace, NameSpace)
	w.Writeln("  %sResult loadWrapperTable (s%sDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);", NameSpace, NameSpace)
	w.Writeln("")
	for i := 0; i < len(component.Classes); i++ {

		class := component.Classes[i]
		cppClassName := cppClassPrefix + class.ClassName
		w.Writeln("  friend class %s;", cppClassName)
		
	}
	w.Writeln("")
	w.Writeln("};")
	w.Writeln("")
	
	
	w.Writeln("/*************************************************************************************************************************")
	w.Writeln(" Class %sBaseClass ", cppClassPrefix)
	w.Writeln("**************************************************************************************************************************/")

	w.Writeln("class %sBaseClass {", cppClassPrefix)
	w.Writeln("protected:")
	w.Writeln("  /* Wrapper Object that created the class..*/")
	w.Writeln("  %sWrapper * m_pWrapper;", cppClassPrefix)
	w.Writeln("  /* Handle to Instance in library*/")
	w.Writeln("  %sHandle m_pHandle;", NameSpace)
	w.Writeln("")
	w.Writeln("  /* Checks for an Error code and raises Exceptions */")
	w.Writeln("  void CheckError(%sResult nResult)", NameSpace)
	w.Writeln("  {")
	w.Writeln("    if (m_pWrapper != nullptr)")
	w.Writeln("      m_pWrapper->CheckError (m_pHandle, nResult);")
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("public:")
	w.Writeln("")
	w.Writeln("  /**")
	w.Writeln("  * %sBaseClass::%sBaseClass - Constructor for Base class.", cppClassPrefix, cppClassPrefix)
	w.Writeln("  */")
	w.Writeln("  %sBaseClass(%sWrapper * pWrapper, %sHandle pHandle)", cppClassPrefix, cppClassPrefix, NameSpace)
	w.Writeln("    : m_pWrapper (pWrapper), m_pHandle (pHandle)")
	w.Writeln("  {")
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  /**")
	w.Writeln("  * %sBaseClass::~%sBaseClass - Destructor for Base class.", cppClassPrefix, cppClassPrefix)
	w.Writeln("  */")

	w.Writeln("  virtual ~%sBaseClass()", cppClassPrefix)
	w.Writeln("  {")
	w.Writeln("    if (m_pWrapper != nullptr)")
	w.Writeln("      m_pWrapper->%s (this);", component.Global.ReleaseMethod)
	w.Writeln("    m_pWrapper = nullptr;")
	w.Writeln("  }")
	w.Writeln("")
	w.Writeln("  /**")
	w.Writeln("  * %sBaseClass::GetHandle - Returns handle to instance.", cppClassPrefix)
	w.Writeln("  */")
	w.Writeln("  %sHandle GetHandle()", NameSpace)
	w.Writeln("  {")
	w.Writeln("    return m_pHandle;")
	w.Writeln("  }")
	w.Writeln("};")
	
	w.Writeln("  ")
	
	for i := 0; i < len(component.Classes); i++ {

		class := component.Classes[i]
		cppClassName := cppClassPrefix + class.ClassName

		parentClassName := class.ParentClass
		if parentClassName == "" {
			parentClassName = "BaseClass"
		}
		cppParentClassName := cppClassPrefix + parentClassName

		w.Writeln("  ")
		w.Writeln("/*************************************************************************************************************************")
		w.Writeln(" Class %s ", cppClassName)
		w.Writeln("**************************************************************************************************************************/")
		w.Writeln("class %s : public %s {", cppClassName, cppParentClassName)
		w.Writeln("public:")
		w.Writeln("  ")
		w.Writeln("  /**")
		w.Writeln("  * %s::%s - Constructor for %s class.", cppClassName, cppClassName, class.ClassName)
		w.Writeln("  */")
		w.Writeln("  %s (%sWrapper * pWrapper, %sHandle pHandle)", cppClassName, cppClassPrefix, NameSpace)
		w.Writeln("    : %s (pWrapper, pHandle)", cppParentClassName);
		w.Writeln("  {")
		w.Writeln("  }")
		w.Writeln("  ")

		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]

			err := writeDynamicCPPMethodDeclaration(method, w, NameSpace, cppClassName, true)
			if err != nil {
				return err
			}
		}
		w.Writeln("};")
	}
	

	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]

		err := writeDynamicCPPMethod(method, w, NameSpace, "Wrapper", true, true)
		if err != nil {
			return err
		}
	}

	w.Writeln("")
	w.Writeln("  inline %sResult %sWrapper::initWrapperTable (s%sDynamicWrapperTable * pWrapperTable)", NameSpace, cppClassPrefix, NameSpace)
	w.Writeln("  {")
	
	w.AddIndentationLevel(2)
	buildDynamicCInitTableCode (component, w, NameSpace, BaseName);
	w.AddIndentationLevel(-2)

	w.Writeln("  }")
	w.Writeln("")

	w.Writeln("  inline %sResult %sWrapper::releaseWrapperTable (s%sDynamicWrapperTable * pWrapperTable)", NameSpace, cppClassPrefix, NameSpace)
	w.Writeln("  {")

	w.AddIndentationLevel(2)
	buildDynamicCReleaseTableCode (component, w, NameSpace, BaseName, "initWrapperTable");
	w.AddIndentationLevel(-2)

	w.Writeln("  }")
	w.Writeln("")
	
	w.Writeln("  inline %sResult %sWrapper::loadWrapperTable (s%sDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)", NameSpace, cppClassPrefix, NameSpace)
	w.Writeln("  {")
	
	w.AddIndentationLevel(2)
	buildDynamicCLoadTableCode (component, w, NameSpace, BaseName);
	w.AddIndentationLevel(-2)

	w.Writeln("  }")

	w.Writeln("  ")

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		cppClassName := cppClassPrefix + class.ClassName
		w.Writeln("  ")
		w.Writeln("  /**")
		w.Writeln("   * Method definitions for class %s", cppClassName )
		w.Writeln("   */")
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			err := writeDynamicCPPMethod(method, w, NameSpace, class.ClassName, false, false)
			if err != nil {
				return err
			}
		}
	}
		
	w.Writeln("")
	
	w.Writeln("} // namespace %s", NameSpace)
	w.Writeln("")
	
	w.Writeln("#endif // __%s_DYNAMICCPPHEADER", strings.ToUpper(NameSpace))
	w.Writeln("")

	return nil
}



// BuildBindingCppDynamic builds dynamic headeronly C++-bindings of a library's API in form of dynamically loaded functions
// handles.
func BuildBindingCppDynamic(component ComponentDefinition, outputFolder string, outputFolderExample string, indentString string) error {
	forceRecreation := false

	namespace := component.NameSpace;
	libraryname := component.LibraryName;
	baseName := component.BaseName;

	DynamicCHeader := path.Join(outputFolder, baseName+"_dynamic.h");
	log.Printf("Creating \"%s\"", DynamicCHeader)
	dynhfile, err := CreateLanguageFile(DynamicCHeader, indentString)
	if err != nil {
		return err;
	}
	dynhfile.WriteCLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated plain C Header file in order to allow an easy\n use of %s", libraryname),
		true)
	err = buildDynamicCHeader(component, dynhfile, namespace, baseName, true)
	if err != nil {
		return err;
	}
	
	DynamicCppHeader := path.Join(outputFolder, baseName+"_dynamic.hpp");
	log.Printf("Creating \"%s\"", DynamicCppHeader)
	dynhppfile, err := CreateLanguageFile(DynamicCppHeader, indentString)
	if err != nil {
		return err;
	}
	dynhppfile.WriteCLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated C++ Header file in order to allow an easy\n use of %s", libraryname),
		true)
	err = buildDynamicCppHeader(component, dynhppfile, namespace, baseName)
	if err != nil {
		return err;
	}
	
	if (len(outputFolderExample) > 0) {
		DynamicCPPExample := path.Join(outputFolderExample, namespace+"_example"+".cpp");
		if (forceRecreation || !FileExists(DynamicCPPExample)) {
			log.Printf("Creating \"%s\"", DynamicCPPExample)
			dyncppexamplefile, err := CreateLanguageFile (DynamicCPPExample, "  ")
			if err != nil {
				return err;
			}
			dyncppexamplefile.WriteCLicenseHeader(component,
				fmt.Sprintf("This is an autogenerated C++ application that demonstrates the\n usage of the Dynamic C++ bindings of %s", libraryname),
				true)
			buildDynamicCppExample(component, dyncppexamplefile, outputFolder)
		} else {
			log.Printf("Omitting recreation of C++Dynamic example file \"%s\"", DynamicCPPExample)
		}

		DynamicCPPCMake := path.Join(outputFolderExample, "CMakeLists.txt");
		if (forceRecreation || !FileExists(DynamicCPPCMake)) {
			log.Printf("Creating \"%s\"", DynamicCPPCMake)
			dyncppcmake, err := CreateLanguageFile (DynamicCPPCMake, "	")
			if err != nil {
				return err;
			}
			dyncppcmake.WriteCMakeLicenseHeader(component,
				fmt.Sprintf("This is an autogenerated CMake Project that demonstrates the\n usage of the Dynamic C++ bindings of %s", libraryname),
				true)
			buildDynamicCppExampleCMake(component, dyncppcmake, outputFolder)
		} else {
			log.Printf("Omitting recreation of C++Dynamic example file \"%s\"", DynamicCPPCMake)
		}
	}

	return nil;
}


func buildDynamicCppExample(componentdefinition ComponentDefinition, w LanguageWriter, outputFolder string) error {
	NameSpace := componentdefinition.NameSpace
	BaseName := componentdefinition.BaseName

	w.Writeln("#include <iostream>")
	w.Writeln("#include \"%s_dynamic.hpp\"", strings.ToLower(BaseName) )
	w.Writeln("")
	w.Writeln("")

	w.Writeln("int main()")
	w.Writeln("{")
	w.Writeln("  try")
	w.Writeln("  {")
	w.Writeln("    std::string libpath = (\"\"); // TODO: put the location of the %s-library file here.", NameSpace)
	w.Writeln("    auto wrapper = %s::C%sWrapper::loadLibrary(libpath + \"/%s.\"); // TODO: add correct suffix of the library", NameSpace, NameSpace, BaseName)
	w.Writeln("    unsigned int nMajor, nMinor, nMicro;")
	w.Writeln("    wrapper->%s(nMajor, nMinor, nMicro);", componentdefinition.Global.VersionMethod)
	w.Writeln("    std::cout << \"%s.Version = \" << nMajor << \".\" << nMinor << \".\" << nMicro << std::endl;", NameSpace);
	w.Writeln("  }")
	w.Writeln("  catch (std::exception &e)")
	w.Writeln("  {")
	w.Writeln("    std::cout << e.what() << std::endl;")
	w.Writeln("    return 1;")
	w.Writeln("  }")
	w.Writeln("  return 0;")
	w.Writeln("}")
	w.Writeln("")

	return nil
}

func buildDynamicCppExampleCMake(componentdefinition ComponentDefinition, w LanguageWriter, outputFolder string) error {
	NameSpace := componentdefinition.NameSpace

	w.Writeln("cmake_minimum_required(VERSION 3.5)")

	w.Writeln("")
	w.Writeln("project(%sExample_CPPDynamic)", NameSpace)
	w.Writeln("set (CMAKE_CXX_STANDARD 11)")
	w.Writeln("add_executable(%sExample_CPPDynamic \"${CMAKE_CURRENT_SOURCE_DIR}/%s_example.cpp\")", NameSpace, NameSpace)
	w.Writeln("if (UNIX)")
	w.Writeln("  target_link_libraries(%sExample_CPPDynamic ${CMAKE_DL_LIBS})", NameSpace)
	w.Writeln("endif (UNIX)")
	// TODO: calculate relative path from ExampleOutputFolder to OUTPUTFOLDER based on CURRENT_SOURCE_DIR
	outputFolder = strings.Replace(outputFolder, string(filepath.Separator), "/", -1)
	w.Writeln("target_include_directories(%sExample_CPPDynamic PRIVATE \"%s\")", NameSpace, outputFolder)
	return nil
}
