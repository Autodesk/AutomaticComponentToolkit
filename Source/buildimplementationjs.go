/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildimplementationjs.go
// functions to generate C++ interface classes, implementation stubs and wrapper code that maps to
// the C-header.
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"fmt"
	"log"
	"path"
	"strings"
)

// BuildImplementationJS builds C++ interface classes, implementation stubs and wrapper code that maps to the C-header
func BuildImplementationJS(component ComponentDefinition, outputFolder string, stubOutputFolder string, projectOutputFolder string, implementation ComponentDefinitionImplementation, suppressStub bool, suppressInterfaces bool, outputFolderDocumentation string) error {

	doJournal := len(component.Global.JournalMethod) > 0

	NameSpace := component.NameSpace
	LibraryName := component.LibraryName
	BaseName := component.BaseName
	ImplementationSubNameSpace := "Impl"

	log.Printf("Creating JavaScript Implementation")

	indentString := getIndentationString(implementation.Indentation)
	stubIdentifier := ""
	if len(implementation.StubIdentifier) > 0 {
		stubIdentifier = "_" + strings.ToLower(implementation.StubIdentifier)
	}

	if !suppressInterfaces {

		IntfExceptionHeaderName := path.Join(outputFolder, BaseName+"_interfaceexception.hpp")
		log.Printf("Creating \"%s\"", IntfExceptionHeaderName)
		hInternalExceptionHeaderFile, err := CreateLanguageFile(IntfExceptionHeaderName, indentString)
		if err != nil {
			return err
		}
		hInternalExceptionHeaderFile.WriteCLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated C++ Header file with the basic internal\n exception type in order to allow an easy use of %s", LibraryName),
			true)

		IntfExceptionImplName := path.Join(outputFolder, BaseName+"_interfaceexception.cpp")
		log.Printf("Creating \"%s\"", IntfExceptionImplName)
		hInternalExceptionImplFile, err := CreateLanguageFile(IntfExceptionImplName, indentString)
		if err != nil {
			return err
		}
		hInternalExceptionImplFile.WriteCLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated C++ Implementation file with the basic internal\n exception type in order to allow an easy use of %s", LibraryName),
			true)

		err = buildCPPInternalException(hInternalExceptionHeaderFile, hInternalExceptionImplFile, NameSpace, BaseName)
		if err != nil {
			return err
		}

		IntfHeaderName := path.Join(outputFolder, BaseName+"_interfaces.hpp")
		log.Printf("Creating \"%s\"", IntfHeaderName)
		interfaceshppfile, err := CreateLanguageFile(IntfHeaderName, indentString)
		if err != nil {
			return err
		}
		interfaceshppfile.WriteCLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated C++ header file in order to allow easy\ndevelopment of %s. The implementer of %s needs to\nderive concrete classes from the abstract classes in this header.", LibraryName, LibraryName),
			true)
		err = buildCPPInterfaces(component, interfaceshppfile, ImplementationSubNameSpace, implementation.ClassIdentifier)
		if err != nil {
			return err
		}

		IntfWrapperImplName := path.Join(outputFolder, BaseName+"_interfacewrapper.cpp")
		log.Printf("Creating \"%s\"", IntfWrapperImplName)
		cppWrapperfile, err := CreateLanguageFile(IntfWrapperImplName, indentString)
		if err != nil {
			return err
		}
		cppWrapperfile.WriteCLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated C++ implementation file in order to allow easy\ndevelopment of %s. The functions in this file need to be implemented. It needs to be generated only once.", LibraryName),
			true)
		err = buildCPPInterfaceWrapper(component, cppWrapperfile, NameSpace, ImplementationSubNameSpace, implementation.ClassIdentifier, BaseName, doJournal)
		if err != nil {
			return err
		}

		if doJournal {
			IntfJournalHeaderName := path.Join(outputFolder, strings.ToLower(BaseName)+"_interfacejournal.hpp")
			log.Printf("Creating \"%s\"", IntfJournalHeaderName)
			interfacejournalhppfile, err := CreateLanguageFile(IntfJournalHeaderName, indentString)
			if err != nil {
				return err
			}
			interfacejournalhppfile.WriteCLicenseHeader(component,
				fmt.Sprintf("This is an autogenerated C++ header file in order to allow easy\ndevelopment of %s. It provides an automatic Journaling mechanism for the library implementation.", LibraryName),
				true)

			IntfJournalImplName := path.Join(outputFolder, strings.ToLower(BaseName)+"_interfacejournal.cpp")
			log.Printf("Creating \"%s\"", IntfJournalImplName)
			interfacejournalcppfile, err := CreateLanguageFile(IntfJournalImplName, indentString)
			if err != nil {
				return err
			}
			interfacejournalcppfile.WriteCLicenseHeader(component,
				fmt.Sprintf("This is an autogenerated C++ implementation file in order to allow easy\ndevelopment of %s. It provides an automatic Journaling mechanism for the library implementation.", LibraryName),
				true)

			err = buildJournalingCPP(component, interfacejournalhppfile, interfacejournalcppfile)
			if err != nil {
				return err
			}
		}

	}

	err := buildJSTypesFiles(component, NameSpace, ImplementationSubNameSpace, implementation.ClassIdentifier, BaseName, stubOutputFolder, indentString, stubIdentifier)
	if err != nil {
		return err
	}

	for _, subComponent := range component.ImportedComponentDefinitions {

		for i := 0; i < len(subComponent.Classes); i++ {
			class := subComponent.Classes[i]
			err := buildJSInjectionClass(component, subComponent, class, NameSpace, ImplementationSubNameSpace, implementation.ClassIdentifier, BaseName, stubOutputFolder, indentString, stubIdentifier)
			if err != nil {
				return err
			}
		}

	}

	if outputFolderDocumentation != "" {

		err = BuildJSDocumentation(component, outputFolderDocumentation, implementation.ClassIdentifier)
		if err != nil {
			return err
		}

	}

	return nil
}

func buildJSTypesFiles(component ComponentDefinition, NameSpace string, NameSpaceImplementation string, ClassIdentifier string, BaseName string, outputFolder string, indentString string, stubIdentifier string) error {

	TypesDefinitionFileName := path.Join(outputFolder, BaseName+stubIdentifier+"_v8types.hpp")
	ClassDefinitionFileName := path.Join(outputFolder, BaseName+stubIdentifier+"_v8classes.hpp")

	log.Printf("Creating \"%s\"", TypesDefinitionFileName)
	typesdefinitionw, err := CreateLanguageFile(TypesDefinitionFileName, indentString)
	if err != nil {
		return err
	}
	typesdefinitionw.WriteCLicenseHeader(component,
		"JavaScript injection type definitions", false)

	log.Printf("Creating \"%s\"", ClassDefinitionFileName)
	classdefinitionw, err := CreateLanguageFile(ClassDefinitionFileName, indentString)
	if err != nil {
		return err
	}
	classdefinitionw.WriteCLicenseHeader(component,
		"JavaScript injection class definitions", false)

	typesdefinitionw.Writeln("")
	typesdefinitionw.Writeln("#ifndef __%s_V8TYPES", strings.ToUpper(NameSpace))
	typesdefinitionw.Writeln("#define __%s_V8TYPES", strings.ToUpper(NameSpace))
	typesdefinitionw.Writeln("")
	typesdefinitionw.Writeln("#include <stdint.h>")
	typesdefinitionw.Writeln("")

	typeEnumID := 1

	typesdefinitionw.Writeln("namespace v8%s {", NameSpace)
	typesdefinitionw.Writeln("  namespace %s {", NameSpaceImplementation)
	typesdefinitionw.Writeln("")
	typesdefinitionw.Writeln("    enum class eInjectionClassType {")
	typesdefinitionw.Writeln("      e_Injection_Invalid = 0,")
	for _, subComponent := range component.ImportedComponentDefinitions {

		for i := 0; i < len(subComponent.Classes); i++ {
			class := subComponent.Classes[i]
			typesdefinitionw.Writeln("      e_v8%s_%s = %d,", subComponent.NameSpace, class.ClassName, typeEnumID)
			typeEnumID = typeEnumID + 1
		}

	}
	typesdefinitionw.Writeln("      e_Injection_enumMax")
	typesdefinitionw.Writeln("    };")
	typesdefinitionw.Writeln("")
	typesdefinitionw.Writeln("  }")
	typesdefinitionw.Writeln("}")
	typesdefinitionw.Writeln("")
	typesdefinitionw.Writeln("#endif // __%s_V8TYPES", strings.ToUpper(NameSpace))
	typesdefinitionw.Writeln("")

	classdefinitionw.Writeln("")
	classdefinitionw.Writeln("#ifndef __%s_V8CLASSES", strings.ToUpper(NameSpace))
	classdefinitionw.Writeln("#define __%s_V8CLASSES", strings.ToUpper(NameSpace))
	classdefinitionw.Writeln("")
	for _, subComponent := range component.ImportedComponentDefinitions {

		for i := 0; i < len(subComponent.Classes); i++ {
			class := subComponent.Classes[i]
			classdefinitionw.Writeln("#include \"%s_v8_%s_%s.hpp\"", component.BaseName+stubIdentifier, subComponent.BaseName, strings.ToLower(class.ClassName))
		}

	}
	classdefinitionw.Writeln("")

	classdefinitionw.Writeln("namespace v8%s {", NameSpace)
	classdefinitionw.Writeln("  namespace %s {", NameSpaceImplementation)
	classdefinitionw.Writeln("")
	classdefinitionw.Writeln("    inline void registerInjectionClasses (std::shared_ptr<Cv8objectCreator> pObjectCreator, v8::Local<v8::Object> pTarget)")
	classdefinitionw.Writeln("    {")
	for _, subComponent := range component.ImportedComponentDefinitions {

		for i := 0; i < len(subComponent.Classes); i++ {
			class := subComponent.Classes[i]
			classdefinitionw.Writeln("      v8%s::Cv8%s%s::internalV8Register(pObjectCreator, pTarget);", subComponent.NameSpace, ClassIdentifier, class.ClassName)
		}

	}
	classdefinitionw.Writeln("    }")
	classdefinitionw.Writeln("")

	classdefinitionw.AddIndentationLevel(2)
	for _, subComponent := range component.ImportedComponentDefinitions {
		writeMapClassIdtoInjectionClassTypeFunction(classdefinitionw, subComponent, subComponent.NameSpace)
		classdefinitionw.Writeln("")
	}
	classdefinitionw.AddIndentationLevel(-2)

	classdefinitionw.Writeln("  }")
	classdefinitionw.Writeln("}")
	classdefinitionw.Writeln("")
	classdefinitionw.Writeln("#endif // __%s_V8CLASSES", strings.ToUpper(NameSpace))
	classdefinitionw.Writeln("")

	return nil
}

func buildJSInjectionClass(component ComponentDefinition, subComponent ComponentDefinition, class ComponentDefinitionClass, NameSpace string, NameSpaceImplementation string, ClassIdentifier string, BaseName string, outputFolder string, indentString string, stubIdentifier string) error {
	baseFileName := fmt.Sprintf("%s_v8_%s_%s", component.BaseName+stubIdentifier, subComponent.BaseName, strings.ToLower(class.ClassName))
	HeaderFileName := path.Join(outputFolder, baseFileName+".hpp")
	CppFileName := path.Join(outputFolder, baseFileName+".cpp")

	log.Printf("Creating \"%s\"", HeaderFileName)
	headerw, err := CreateLanguageFile(HeaderFileName, indentString)
	if err != nil {
		return err
	}

	headerw.WriteCLicenseHeader(component,
		"JavaScript definition for injection class "+subComponent.NameSpace+"::"+class.ClassName, false)

	log.Printf("Creating \"%s\"", CppFileName)
	cppw, err := CreateLanguageFile(CppFileName, indentString)
	if err != nil {
		return err
	}
	cppw.WriteCLicenseHeader(component,
		"JavaScript implementation for injection class "+subComponent.NameSpace+"::"+class.ClassName, false)

	headerw.Writeln("")
	headerw.Writeln("")
	headerw.Writeln("#ifndef __%s_V8_%s_%s", strings.ToUpper(NameSpace), strings.ToUpper(subComponent.NameSpace), strings.ToUpper(class.ClassName))
	headerw.Writeln("#define __%s_V8_%s_%s", strings.ToUpper(NameSpace), strings.ToUpper(subComponent.NameSpace), strings.ToUpper(class.ClassName))
	headerw.Writeln("")
	headerw.Writeln("#include \"%s_v8objectcreator.hpp\"", component.BaseName)
	headerw.Writeln("#include \"%s_v8objectwrapper.hpp\"", component.BaseName)
	headerw.Writeln("")

	headerw.Writeln("namespace v8%s {", NameSpace)
	headerw.Writeln("  namespace %s {", NameSpaceImplementation)
	headerw.Writeln("    namespace v8%s {", subComponent.NameSpace)
	headerw.Writeln("")

	headerw.Writeln("       class Cv8%s : public Cv8objectWrapper", class.ClassName)
	headerw.Writeln("       {")
	headerw.Writeln("         public:")
	headerw.Writeln("")
	headerw.Writeln("           /* constructors, destructor and operators */")
	headerw.Writeln("           Cv8%s();", class.ClassName)
	headerw.Writeln("           Cv8%s(v8::Local<v8::Object> localObject);", class.ClassName)
	headerw.Writeln("           Cv8%s(const Cv8%s& valueReference);", class.ClassName, class.ClassName)
	headerw.Writeln("           virtual ~Cv8%s();", class.ClassName)
	headerw.Writeln("")
	headerw.Writeln("           Cv8%s& operator=(const Cv8%s& valueReference);", class.ClassName, class.ClassName)
	headerw.Writeln("           static Cv8%s* Cast(Cv8objectWrapper* objectWrapper);", class.ClassName)
	headerw.Writeln("")
	headerw.Writeln("           /* class helper methods */")
	headerw.Writeln("           static eInjectionClassType getClassType();")
	headerw.Writeln("")
	headerw.Writeln("           static %s::P%s getInstance(const v8::Local<v8::Object>& holder);", subComponent.NameSpace, class.ClassName)
	headerw.Writeln("")
	headerw.Writeln("           /* V8 Registration commands */")
	headerw.Writeln("           static void internalV8RegisterMethods(v8::Local<v8::FunctionTemplate> localClassTemplate, std::shared_ptr<Cv8objectCreator> pObjectCreator, v8::Local<v8::Object> target);")
	headerw.Writeln("           static void internalV8Register(std::shared_ptr<Cv8objectCreator> pObjectCreator, v8::Local<v8::Object> target);")
	headerw.Writeln("           static void internalV8New(const v8::FunctionCallbackInfo<v8::Value>& args);")
	headerw.Writeln("")
	headerw.Writeln("           /* V8 Method implementations */")

	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]
		if method.PropertyGet != "" {
			headerw.Writeln("           static void v8%s(v8::Local<v8::String> property, const v8::PropertyCallbackInfo<v8::Value>& args);", method.MethodName)
		} else if method.PropertySet != "" {
			headerw.Writeln("           static void v8%s(v8::Local<v8::String> property, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<void>& args);", method.MethodName)
		} else {
			headerw.Writeln("           static void v8%s(const v8::FunctionCallbackInfo<v8::Value>& args);", method.MethodName)
		}
	}

	//static void V8Data(const v8::FunctionCallbackInfo<v8::Value>& args);
	headerw.Writeln("")
	headerw.Writeln("         };")

	headerw.Writeln("")
	headerw.Writeln("    }")
	headerw.Writeln("  }")
	headerw.Writeln("}")
	headerw.Writeln("")
	headerw.Writeln("#endif // __%s_V8_%s_%s", strings.ToUpper(NameSpace), strings.ToUpper(subComponent.NameSpace), strings.ToUpper(class.ClassName))
	headerw.Writeln("")

	cppw.Writeln("")
	cppw.Writeln("#include \"%s.hpp\"", baseFileName)
	cppw.Writeln("")
	cppw.Writeln("#include \"%s_v8utils.hpp\"", component.BaseName)
	cppw.Writeln("#include \"%s_v8objectcreator.hpp\"", component.BaseName)
	cppw.Writeln("#include \"%s%s_v8classes.hpp\"", component.BaseName, stubIdentifier)
	cppw.Writeln("")
	cppw.Writeln("")

	cppw.Writeln("using namespace v8%s::%s;", NameSpace, NameSpaceImplementation)
	cppw.Writeln("using namespace v8%s::%s::v8%s;", NameSpace, NameSpaceImplementation, subComponent.NameSpace)
	cppw.Writeln("")

	cppw.Writeln("Cv8%s::Cv8%s()", class.ClassName, class.ClassName)
	cppw.Writeln("  : Cv8objectWrapper(getClassType())")
	cppw.Writeln("{")
	cppw.Writeln("}")
	cppw.Writeln("")

	cppw.Writeln("Cv8%s::Cv8%s(v8::Local<v8::Object> localObject)", class.ClassName, class.ClassName)
	cppw.Writeln("  : Cv8objectWrapper(getClassType())")
	cppw.Writeln("{")
	cppw.Writeln("  Wrap(localObject);")
	cppw.Writeln("}")
	cppw.Writeln("")

	cppw.Writeln("Cv8%s::Cv8%s(const Cv8%s& valueReference)", class.ClassName, class.ClassName, class.ClassName)
	cppw.Writeln("  : Cv8objectWrapper(getClassType())")
	cppw.Writeln("{")
	cppw.Writeln("  setObjectInstances(valueReference.m_pObjectCreator, valueReference.m_pObjectInstance);")
	cppw.Writeln("}")
	cppw.Writeln("")

	cppw.Writeln("Cv8%s::~Cv8%s()", class.ClassName, class.ClassName)
	cppw.Writeln("{")
	cppw.Writeln("}")
	cppw.Writeln("")

	cppw.Writeln("eInjectionClassType Cv8%s::getClassType()", class.ClassName)
	cppw.Writeln("{")
	cppw.Writeln("  return eInjectionClassType::e_v8%s_%s;", subComponent.NameSpace, class.ClassName)
	cppw.Writeln("}")
	cppw.Writeln("")

	cppw.Writeln("Cv8%s* Cv8%s::Cast(Cv8objectWrapper* objectWrapper)", class.ClassName, class.ClassName)
	cppw.Writeln("{")
	cppw.Writeln("  if (objectWrapper != nullptr) {")
	cppw.Writeln("    if (objectWrapper->get_type() == getClassType())")
	cppw.Writeln("      return static_cast<Cv8%s*>(objectWrapper);", class.ClassName)
	cppw.Writeln("  }")
	cppw.Writeln("  return nullptr;")
	cppw.Writeln("}")
	cppw.Writeln("")

	cppw.Writeln("%s::P%s Cv8%s::getInstance(const v8::Local<v8::Object>& holder)", subComponent.NameSpace, class.ClassName, class.ClassName)
	cppw.Writeln("{")
	cppw.Writeln("  auto objectWrapper = UnwrapBase(holder);")
	cppw.Writeln("  if (objectWrapper == nullptr)")
	cppw.Writeln("    throw std::runtime_error (\"could not get %s instance wrapper.\");", class.ClassName)
	cppw.Writeln("")
	cppw.Writeln("  auto pInstance = objectWrapper->getObjectInstance ();")
	cppw.Writeln("  if (pInstance.get () == nullptr)")
	cppw.Writeln("    throw std::runtime_error (\"could not get %s instance.\");", class.ClassName)
	cppw.Writeln("")
	cppw.Writeln("  auto pCastInstance = std::dynamic_pointer_cast<%s::C%s> (pInstance);", subComponent.NameSpace, class.ClassName)
	cppw.Writeln("  if (pCastInstance.get () == nullptr)")
	cppw.Writeln("    throw std::runtime_error (\"invalid %s instance type.\");", class.ClassName)
	cppw.Writeln("")
	cppw.Writeln("  return pCastInstance;")
	cppw.Writeln("}")
	cppw.Writeln("")

	cppw.Writeln("Cv8%s& Cv8%s::operator=(const Cv8%s& valueReference)", class.ClassName, class.ClassName, class.ClassName)
	cppw.Writeln("{")
	cppw.Writeln("  if (this != &valueReference)")
	cppw.Writeln("  {")
	cppw.Writeln("    setObjectInstances(valueReference.m_pObjectCreator, valueReference.m_pObjectInstance);")
	cppw.Writeln("  }")
	cppw.Writeln("  return *this;")
	cppw.Writeln("}")
	cppw.Writeln("")

	cppw.Writeln("void Cv8%s::internalV8Register(std::shared_ptr<Cv8objectCreator> pObjectCreator, v8::Local<v8::Object> target)", class.ClassName)
	cppw.Writeln("{")
	cppw.Writeln("  v8::Isolate* isolate = v8::Isolate::GetCurrent();")
	cppw.Writeln("  if (isolate == nullptr)")
	cppw.Writeln("    return;")
	cppw.Writeln("")
	cppw.Writeln("  // Create class template")
	cppw.Writeln("  v8::HandleScope handle_scope(isolate);")
	cppw.Writeln("")
	cppw.Writeln("  v8::Local<v8::FunctionTemplate> localClassTemplate = createClassTemplate (isolate, \"%s\", Cv8%s::internalV8New);", class.ClassName, class.ClassName)
	cppw.Writeln("")
	cppw.Writeln("	Cv8%s::internalV8RegisterMethods(localClassTemplate, pObjectCreator, target);", class.ClassName)
	cppw.Writeln("")
	cppw.Writeln("  pObjectCreator->setTemplate(getClassType(), localClassTemplate);")
	cppw.Writeln("}")
	cppw.Writeln("")
	cppw.Writeln("void Cv8%s::internalV8RegisterMethods(v8::Local<v8::FunctionTemplate> localClassTemplate,", class.ClassName)
	cppw.Writeln("	std::shared_ptr<Cv8objectCreator> pObjectCreator, v8::Local<v8::Object> target)")
	cppw.Writeln("{")
	if (class.ParentClass != "") && (class.ClassName != "Base") {
		cppw.Writeln("	Cv8%s::internalV8RegisterMethods(localClassTemplate, pObjectCreator, target);", class.ParentClass)
	}
	cppw.Writeln("  // Add functions to prototype object")
	for i := 0; i < len(class.Methods); i++ {
		method := class.Methods[i]
		if method.PropertySet != "" {
			// Ignore setters
		} else if method.PropertyGet != "" {
			readOnly := true
			var getter = &method
			var setter *ComponentDefinitionMethod
			for _, method := range class.Methods {
				if method.PropertySet == getter.PropertyGet {
					setter = &method
					readOnly = false
					break
				}
			}
			if readOnly {
				cppw.Writeln("  Cv8toolsUtils::Set_proto_accessor(localClassTemplate, \"%s\", Cv8%s::v8%s);", getter.PropertyGet, class.ClassName, getter.MethodName)
				cppw.Writeln("  Cv8toolsUtils::Set_proto_accessor(localClassTemplate, \"%s\", Cv8%s::v8%s);", camelize(getter.PropertyGet), class.ClassName, getter.MethodName)
			} else {
				cppw.Writeln("  Cv8toolsUtils::Set_proto_accessor(localClassTemplate, \"%s\", Cv8%s::v8%s, Cv8%s::v8%s);", setter.PropertySet, class.ClassName, getter.MethodName, class.ClassName, setter.MethodName)
				cppw.Writeln("  Cv8toolsUtils::Set_proto_accessor(localClassTemplate, \"%s\", Cv8%s::v8%s, Cv8%s::v8%s);", camelize(setter.PropertySet), class.ClassName, getter.MethodName, class.ClassName, setter.MethodName)
			}
		} else {
			cppw.Writeln("  Cv8toolsUtils::Set_proto_method(localClassTemplate, \"%s\", Cv8%s::v8%s);", method.MethodName, class.ClassName, method.MethodName)
			cppw.Writeln("  Cv8toolsUtils::Set_proto_method(localClassTemplate, \"%s\", Cv8%s::v8%s);", camelize(method.MethodName), class.ClassName, method.MethodName)
		}
	}
	cppw.Writeln("")
	cppw.Writeln("}")

	cppw.Writeln("void Cv8%s::internalV8New(const v8::FunctionCallbackInfo<v8::Value>& args)", class.ClassName)
	cppw.Writeln("{")
	cppw.Writeln("  if (!args.IsConstructCall())")
	cppw.Writeln("  {")
	cppw.Writeln("    Cv8toolsUtils::Throw_error(\"Expected constructor call type\");")
	cppw.Writeln("    return;")
	cppw.Writeln("  }")
	cppw.Writeln("  new Cv8%s(args.This());", class.ClassName)
	cppw.Writeln("}")
	cppw.Writeln("")
	cppw.Writeln("")

	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]

		if method.PropertyGet != "" {
			cppw.Writeln("void Cv8%s::v8%s(v8::Local<v8::String> property, const v8::PropertyCallbackInfo<v8::Value>& args)", class.ClassName, method.MethodName)
		} else if method.PropertySet != "" {
			cppw.Writeln("void Cv8%s::v8%s(v8::Local<v8::String> property, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<void>& args)", class.ClassName, method.MethodName)
		} else {
			cppw.Writeln("void Cv8%s::v8%s(const v8::FunctionCallbackInfo<v8::Value>& args)", class.ClassName, method.MethodName)
		}
		cppw.Writeln("{")
		cppw.Writeln("  v8::Isolate* isolate = v8::Isolate::GetCurrent();")
		cppw.Writeln("")
		cppw.Writeln("  try {")
		cppw.Indentation += 2

		if method.PropertySet == "" && method.PropertyGet == "" {
			inArgs := filterPass(method.Params, "in")
			optionalArgs := filterOptional(inArgs)
			argString := ""
			for k, param := range inArgs {
				if k != 0 {
					argString = argString + ", "
				}
				if param.ParamOptional == "true" {
					argString = argString + "[" + param.ParamName + "]"
				} else {
					argString = argString + param.ParamName
				}
			}
			cppw.Writeln(
				"checkArgumentParameters(args, %d, %d, \"%s.%s (%s)\");",
				len(inArgs)-len(optionalArgs),
				len(inArgs),
				class.ClassName,
				method.MethodName,
				argString,
			)
			cppw.Writeln("")
		}

		// This is probably because I should be adding to the prototype
		if method.PropertySet != "" || method.PropertyGet != "" {
			cppw.Writeln("auto instancePtr = getInstance(args.This());")
			cppw.Writeln("")
			cppw.Writeln("auto v8instance = UnwrapBase(args.This());")
		} else {
			cppw.Writeln("auto instancePtr = getInstance(args.Holder());")
			cppw.Writeln("")
			cppw.Writeln("auto v8instance = UnwrapBase(args.Holder());")
		}
		cppw.Writeln("if (v8instance == nullptr)")
		cppw.Writeln("  throw std::runtime_error(\"could not get %s instance.\");", class.ClassName)
		cppw.Writeln("")
		cppw.Writeln("auto objectCreator = v8instance->getObjectCreator();")
		cppw.Writeln("if (objectCreator == nullptr)")
		cppw.Writeln("  throw std::runtime_error(\"invalid object creator.\");")
		cppw.Writeln("")

		baseClassName := "P" + component.Global.BaseClassName
		argumentString := ""

		for k, param := range method.Params {
			if param.ParamPass == "in" {
				argName := "value"
				if method.PropertySet == "" {
					argName = fmt.Sprintf("args[%d]", k)
				}
				writeExtractV8InArg(param, k, subComponent, baseClassName, argName, cppw)
			}
		}

		for _, param := range method.Params {
			if param.ParamPass == "out" || param.ParamPass == "return" {
				if param.ParamType == "basicarray" {
					cppw.Writeln("std::vector<%s> param%s;", cppArrayClass(param), param.ParamName)
				} else {
					cppw.Writeln("%s param%s = %s;", cppParamType(param, subComponent), param.ParamName, argumentDefault(param, subComponent))
				}
			}
		}

		resultString := ""
		for _, param := range method.Params {
			if param.ParamPass != "return" {
				if argumentString != "" {
					argumentString = argumentString + ", "
				}
				argumentString = argumentString + "param" + param.ParamName
			}
		}

		returnArgs := filterPass(method.Params, "return")
		if len(returnArgs) > 0 {
			// Just take the first
			param := returnArgs[0]
			resultString = "param" + param.ParamName + " = "
		}

		cppw.Writeln("%sinstancePtr->%s (%s);", resultString, method.MethodName, argumentString)

		outArgs := filterPass(method.Params, "out")
		if len(outArgs) > 0 {
			cppw.Writeln("auto context = isolate->GetCurrentContext();")
			cppw.Writeln("auto outArgs = v8::Array::New(isolate);")

			for n, param := range outArgs {
				argName := "v8" + param.ParamName
				writeInsertV8OutArg(param, subComponent, argName, cppw)
				cppw.Writeln("outArgs->Set(context, %d, %s);", n, argName)
			}

			cppw.Writeln("args.GetReturnValue().Set(outArgs);")
		} else {
			for k := 0; k < len(method.Params); k++ {
				param := method.Params[k]
				if param.ParamPass == "return" {
					if method.PropertySet == "" {
						returnValueArg := generateReturnValue(param, subComponent)
						cppw.Writeln("setReturnValue(isolate, args, %s);", returnValueArg)
					}
				}
			}
		}
		cppw.Writeln("")
		cppw.Indentation -= 2
		cppw.Writeln("")

		cppw.Writeln("  }")
		cppw.Writeln("  catch (std::exception& E) {")
		cppw.Writeln("    throwV8Exception(isolate, E);")
		cppw.Writeln("  }")
		cppw.Writeln("}")
		cppw.Writeln("")
	}
	cppw.Writeln("")

	return nil
}

func writeMapClassIdtoInjectionClassTypeFunction(w LanguageWriter, component ComponentDefinition, NameSpace string) {
	w.Writeln("")
	w.Writeln("inline eInjectionClassType %s_MapClassIdToInjectionClassType(uint64_t nClassTypeId)", NameSpace)
	w.Writeln("{")
	w.Writeln("  switch(nClassTypeId) {")
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		classTypeId, chashHashString := class.classTypeId(NameSpace)
		w.Writeln("    case 0x%016XUL: return eInjectionClassType::e_v8%s_%s; break; // First 64 bits of SHA1 of a string: \"%s\"", classTypeId, NameSpace, class.ClassName, chashHashString)
	}
	w.Writeln("  }")

	w.Writeln("  return eInjectionClassType::e_Injection_Invalid;")
	w.Writeln("}")
}

func writeExtractV8InArg(
	param ComponentDefinitionParam,
	index int,
	subComponent ComponentDefinition,
	baseClassName string,
	argName string,
	writer LanguageWriter,
) {
	switch param.ParamType {
	case "class", "optionalclass":
		writer.Writeln("%s::%s object%s;", subComponent.NameSpace, baseClassName, param.ParamName)
	case "basicarray":
		writer.Writeln("std::vector<%s> param%s;", cppArrayClass(param), param.ParamName)
	case "string":
		if param.ParamOptional == "true" {
			writer.Writeln("%s param%s = \"%s\";", cppParamType(param, subComponent), param.ParamName, param.ParamDefaultValue)
		} else {
			writer.Writeln("%s param%s;", cppParamType(param, subComponent), param.ParamName)
		}
	case "enum":
		if param.ParamOptional == "true" {
			writer.Writeln("%s param%s = %s::%s;", cppParamType(param, subComponent), param.ParamName, cppParamType(param, subComponent), param.ParamDefaultValue)
		} else {
			writer.Writeln("%s param%s;", cppParamType(param, subComponent), param.ParamName)
		}
	default:
		if param.ParamOptional == "true" {
			writer.Writeln("%s param%s = %s;", cppParamType(param, subComponent), param.ParamName, param.ParamDefaultValue)
		} else {
			writer.Writeln("%s param%s;", cppParamType(param, subComponent), param.ParamName)
		}
	}
	if param.ParamOptional == "true" {
		writer.Writeln("if (args.Length() > %d) {", index)
		writer.Indentation++
	}
	switch param.ParamType {
	case "class", "optionalclass":
		writer.Writeln("object%s = v8instance->get%sArgument (isolate, %s);", param.ParamName, argumentMethodCallType(param), argName)
	case "basicarray":
		writer.Writeln("v8instance->get%sArgument (isolate, %s, param%s);", argumentMethodCallType(param), argName, param.ParamName)
	default:
		writer.Writeln("param%s = %sv8instance->get%sArgument (isolate, %s);", param.ParamName, cppReturnValueCast(param, subComponent), argumentMethodCallType(param), argName)
	}
	if param.ParamOptional == "true" {
		writer.Indentation--
		writer.Writeln("}")
	}
	switch param.ParamType {
	case "class", "optionalclass":
		writer.Writeln("%s param%s = std::dynamic_pointer_cast<%s::C%s> (object%s);", cppParamType(param, subComponent), param.ParamName, subComponent.NameSpace, param.ParamClass, param.ParamName)
	}
}

func writeInsertV8OutArg(
	param ComponentDefinitionParam,
	subComponent ComponentDefinition,
	argName string,
	writer LanguageWriter,
) {
	switch param.ParamType {
	case "class":
		writer.Writeln("auto %s = createV8Instance(objectCreator, param%s, %s_MapClassIdToInjectionClassType(param%s->%s()));", argName, param.ParamName, subComponent.NameSpace, param.ParamName, subComponent.Global.ClassTypeIdMethod)
	case "optionalclass":
		writer.Writeln("auto %s = param%s?createV8Instance(objectCreator, param%s, %s_MapClassIdToInjectionClassType(param%s->%s())):v8::Local<v8::Object>();", argName, param.ParamName, param.ParamName, subComponent.NameSpace, param.ParamName, subComponent.Global.ClassTypeIdMethod)
	case "enum":
		writer.Writeln("auto %s = v8::Number::New(isolate, (uint32_t)param%s);", argName, param.ParamName)
	case "string":
		writer.Writeln("auto %s = v8::String::NewFromUtf8(isolate, param%s.c_str()).ToLocalChecked();", argName, param.ParamName)
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double":
		writer.Writeln("auto %s = v8::Number::New(isolate, param%s);", argName, param.ParamName)
	case "bool":
		writer.Writeln("auto %s = v8::Boolean::New(isolate, param%s);", argName, param.ParamName)
	case "basicarray":
		writer.Writeln("auto %s = v8::Array::New(isolate);", argName)
		writer.Writeln("for (size_t i = 0; i < param%s.size(); ++i) {", param.ParamName)
		writer.Writeln("  const auto& %s = param%s.at(i);", strings.ToLower(param.ParamName), param.ParamName)
		writer.Writeln("  %s->Set(context, i, v8::%s::New(isolate, %s));", argName, v8Type(param), strings.ToLower(param.ParamName))
		writer.Writeln("}")
	default:
		writer.Writeln("<" + param.ParamType + ">")
	}
}

func v8Type(param ComponentDefinitionParam) string {
	if param.ParamType == "basicarray" {
		return v8TypeString(param.ParamClass)
	}
	return v8TypeString(param.ParamType)
}

func v8TypeString(paramType string) string {
	v8type := ""
	switch paramType {
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double":
		v8type = "Number"
	case "bool":
		v8type = "Boolean"
	case "string":
		v8type = "String"
	default:
		v8type = "<" + paramType + ">"
	}
	return v8type
}

func generateReturnValue(param ComponentDefinitionParam, subComponent ComponentDefinition) string {
	returnValue := ""
	if param.ParamType == "class" {
		returnValue = fmt.Sprintf("createV8Instance(objectCreator, param%s, %s_MapClassIdToInjectionClassType(param%s->%s()))", param.ParamName, subComponent.NameSpace, param.ParamName, subComponent.Global.ClassTypeIdMethod)
	} else if param.ParamType == "optionalclass" {
		returnValue = fmt.Sprintf("param%s?createV8Instance(objectCreator, param%s, %s_MapClassIdToInjectionClassType(param%s->%s())):v8::Local<v8::Object>()", param.ParamName, param.ParamName, subComponent.NameSpace, param.ParamName, subComponent.Global.ClassTypeIdMethod)
	} else if param.ParamType == "enum" {
		returnValue = "(uint32_t) param" + param.ParamName
	} else {
		returnValue = "param" + param.ParamName
	}
	return returnValue
}

func cppParamType(
	param ComponentDefinitionParam,
	subComponent ComponentDefinition,
) string {
	result := ""
	switch param.ParamType {
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64":
		result = param.ParamType + "_t"
	case "single":
		result = "float"
	case "double":
		result = "double"
	case "string":
		result = "std::string"
	case "bool":
		result = "bool"
	case "pointer":
		result = "void *"
	case "class", "optionalclass":
		result = subComponent.NameSpace + "::P" + param.ParamClass
	case "enum":
		result = subComponent.NameSpace + "::e" + param.ParamClass
	default:
		result = "<" + param.ParamType + ">"
	}
	return result
}

func argumentMethodCallType(param ComponentDefinitionParam) string {
	result := ""
	switch param.ParamType {
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64",
		"single", "double", "string", "bool":
		result = strings.Title(param.ParamType)
	case "pointer":
		result = "Pointer"
	case "class", "optionalclass":
		result = "Object"
	case "enum":
		result = "Int32"
	case "basicarray":
		switch param.ParamClass {
		case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64",
			"single", "double", "string", "bool":
			result = strings.Title(param.ParamClass) + "Array"
		default:
			result = "<" + param.ParamType + "|" + param.ParamClass + ">"
		}
	default:
		result = "<" + param.ParamType + ">"
	}
	return result
}

func argumentDefault(
	param ComponentDefinitionParam,
	subComponent ComponentDefinition,
) string {
	result := ""
	switch param.ParamType {
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64":
		result = "0"
	case "single":
		result = "0.0f"
	case "double":
		result = "0.0"
	case "string":
		result = "\"\""
	case "bool":
		result = "false"
	case "pointer", "class", "optionalclass":
		result = "nullptr"
	case "enum":
		result = "(" + subComponent.NameSpace + "::e" + param.ParamClass + ") 0"
	default:
		result = "<" + param.ParamType + ">"
	}

	return result
}

func cppArrayClass(param ComponentDefinitionParam) string {
	result := ""
	if param.ParamType == "basicarray" {
		switch param.ParamClass {
		case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64":
			result = param.ParamClass + "_t"
		case "single", "double":
			result = "double"
		case "bool":
			result = "uint8_t"
		default:
			result = "<" + param.ParamClass + ">"
		}

	}
	return result
}

func cppReturnValueCast(
	param ComponentDefinitionParam,
	subComponent ComponentDefinition,
) string {
	result := ""
	if param.ParamType == "enum" {
		result = "(" + subComponent.NameSpace + "::e" + param.ParamClass + ")"
	}
	return result
}

// BuildJSDocumentation builds the Sphinx documentation of a library's C++-bindings
func BuildJSDocumentation(component ComponentDefinition, outputFolder string, ClassIdentifier string) error {
	BaseName := component.BaseName

	globalFileName := path.Join(outputFolder, BaseName+".rst")
	log.Printf("Creating \"%s\"", globalFileName)
	globalDocFile, err := CreateLanguageFile(globalFileName, "\t")
	if err != nil {
		return err
	}
	err = buildJSDocumentationGlobal(component, globalDocFile, ClassIdentifier)
	if err != nil {
		return err
	}

	typesFileName := path.Join(outputFolder, BaseName+"-types.rst")
	log.Printf("Creating \"%s\"", typesFileName)
	typesDocFile, err := CreateLanguageFile(typesFileName, "\t")
	if err != nil {
		return err
	}
	err = buildJSDocumentationTypes(component, typesDocFile, ClassIdentifier)
	if err != nil {
		return err
	}

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		classFileName := path.Join(outputFolder, BaseName+"_"+class.ClassName+".rst")
		log.Printf("Creating \"%s\"", classFileName)
		classDocFile, err := CreateLanguageFile(classFileName, "\t")
		if err != nil {
			return err
		}
		err = buildJSDocumentationClass(component, classDocFile, class, ClassIdentifier)
		if err != nil {
			return err
		}

	}

	err = buildJSDocumentationExample(component, outputFolder, ClassIdentifier, true, "_dynamic")
	if err != nil {
		return err
	}
	err = buildJSDocumentationExample(component, outputFolder, ClassIdentifier, false, "_implicit")
	if err != nil {
		return err
	}

	return nil
}

func buildJSDocumentationExample(component ComponentDefinition, outputFolder string, ClassIdentifier string, ExplicitLinking bool, suffix string) error {
	NameSpace := component.NameSpace

	DynamicCPPExample := path.Join(outputFolder, NameSpace+"_example"+suffix+".cpp")
	log.Printf("Creating \"%s\"", DynamicCPPExample)
	dyncppexamplefile, err := CreateLanguageFile(DynamicCPPExample, "  ")
	if err != nil {
		return err
	}
	buildDynamicCppExample(component, dyncppexamplefile, outputFolder, ClassIdentifier, ExplicitLinking)

	DynamicCPPCMake := path.Join(outputFolder, "CMakeLists"+suffix+".txt")
	log.Printf("Creating \"%s\"", DynamicCPPCMake)
	dyncppcmake, err := CreateLanguageFile(DynamicCPPCMake, "	")
	if err != nil {
		return err
	}
	buildCppDynamicExampleCMake(component, dyncppcmake, outputFolder, outputFolder, ExplicitLinking)
	return nil
}

func writeJSDocumentationFunctionPointer(component ComponentDefinition, w LanguageWriter,
	functiontype ComponentDefinitionFunctionType) error {

	NameSpace := component.NameSpace
	returnType := "void"
	parameters := ""

	for j := 0; j < len(functiontype.Params); j++ {
		param := functiontype.Params[j]

		cParamTypeName, err := getCPPParameterTypeName(param.ParamType, NameSpace, param.ParamClass)
		if err != nil {
			return err
		}
		if parameters != "" {
			parameters = parameters + ", "
		}
		if param.ParamPass == "in" {
			parameters = parameters + cParamTypeName
		} else {
			parameters = parameters + cParamTypeName + "*"
		}
	}
	w.Writeln("  .. cpp:type:: %s = %s(*)(%s)", functiontype.FunctionName, returnType, parameters)
	w.Writeln("    ")
	w.Writeln("    %s", functiontype.FunctionDescription)
	w.Writeln("    ")

	for j := 0; j < len(functiontype.Params); j++ {
		param := functiontype.Params[j]

		cParams, err := generateCCPPParameter(param, "", functiontype.FunctionName, NameSpace, true)
		if err != nil {
			return err
		}
		for _, cParam := range cParams {
			w.Writeln("    %s", cParam.ParamDocumentationLine)
		}
	}
	w.Writeln("    ")

	return nil
}

func buildJSDocumentationGlobal(component ComponentDefinition, w LanguageWriter, ClassIdentifier string) error {

	NameSpace := component.NameSpace
	LibraryName := component.LibraryName
	global := component.Global

	wrapperName := "C" + ClassIdentifier + "Wrapper"

	w.Writeln("")
	w.Writeln("The wrapper class %s", wrapperName)
	w.Writeln("===================================================================================")
	w.Writeln("")
	w.Writeln("")
	w.Writeln(".. cpp:class:: %s::%s", NameSpace, wrapperName)

	w.Writeln("")
	w.Writeln("  All types of %s reside in the namespace %s and all", LibraryName, NameSpace)
	w.Writeln("  functionality of %s resides in %s::%s.", LibraryName, NameSpace, wrapperName)
	w.Writeln("")
	w.Writeln("  A suitable way to use %s::%s is as a singleton.", NameSpace, wrapperName)
	w.Writeln("")

	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]

		parameters, returntype, err := getDynamicCPPMethodParameters(method, NameSpace, ClassIdentifier, "Wrapper")
		if err != nil {
			return err
		}
		w.Writeln("  .. cpp:function:: %s %s(%s)", returntype, method.MethodName, parameters)
		w.Writeln("  ")
		w.Writeln("    %s", method.MethodDescription)
		w.Writeln("  ")
		writeJSDocumentationParameters(method, w, NameSpace)
		w.Writeln("  ")
	}

	w.Writeln(".. cpp:type:: std::shared_ptr<%s> %s::P%s%s", wrapperName, NameSpace, ClassIdentifier, "Wrapper")
	w.Writeln("  ")

	// Load library functions
	// Check error functions of the base class

	return nil
}

func writeJSDocumentationParameters(method ComponentDefinitionMethod, w LanguageWriter, NameSpace string) {
	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		variableName := getBindingCppVariableName(param)
		if param.ParamPass == "return" {
			w.Writeln("    :returns: %s", param.ParamDescription)
		} else {
			w.Writeln("    :param %s: %s ", variableName, param.ParamDescription)
		}
	}
	w.Writeln("")
}

func buildJSDocumentationClass(component ComponentDefinition, w LanguageWriter, class ComponentDefinitionClass, ClassIdentifier string) error {

	NameSpace := component.NameSpace
	className := "C" + ClassIdentifier + class.ClassName

	w.Writeln("")
	w.Writeln("%s", className)
	w.Writeln("====================================================================================================")
	w.Writeln("")
	w.Writeln("")

	_, inheritanceSpecifier := getCPPInheritanceSpecifier(component, class, "C", ClassIdentifier)

	w.Writeln(".. cpp:class:: %s::%s %s", NameSpace, className, inheritanceSpecifier)
	w.Writeln("")
	w.Writeln("  %s", class.ClassDescription)
	w.Writeln("")
	w.Writeln("")

	w.Writeln("")
	w.Writeln("")
	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]

		parameters, returntype, err := getDynamicCPPMethodParameters(method, NameSpace, ClassIdentifier, class.ClassName)
		if err != nil {
			return err
		}
		w.Writeln("  .. cpp:function:: %s %s(%s)", returntype, method.MethodName, parameters)
		w.Writeln("")
		w.Writeln("    %s", method.MethodDescription)
		w.Writeln("")
		writeJSDocumentationParameters(method, w, NameSpace)
		w.Writeln("")
	}

	w.Writeln(".. cpp:type:: std::shared_ptr<%s> %s::P%s%s", className, NameSpace, ClassIdentifier, class.ClassName)
	w.Writeln("")
	w.Writeln("  Shared pointer to %s to easily allow reference counting.", className)
	w.Writeln("")

	return nil
}

func buildJSDocumentationException(component ComponentDefinition, w LanguageWriter) {
	LibraryName := component.LibraryName
	NameSpace := component.NameSpace

	ExceptionName := "E" + NameSpace + "Exception"
	w.Writeln("  ")
	w.Writeln("%s: The standard exception class of %s", ExceptionName, LibraryName)
	w.Writeln("============================================================================================================================================================================================================")
	w.Writeln("  ")
	w.Writeln("  Errors in %s are reported as Exceptions. It is recommended to not throw these exceptions in your client code.", LibraryName)
	w.Writeln("  ")
	w.Writeln("  ")
	w.Writeln("  .. cpp:class:: %s::%s", NameSpace, ExceptionName)
	w.Writeln("  ")
	w.Writeln("    .. cpp:function:: void %s::what() const noexcept", ExceptionName)
	w.Writeln("    ")
	w.Writeln("       Returns error message")
	w.Writeln("    ")
	w.Writeln("       :return: the error message of this exception")
	w.Writeln("    ")

	w.Writeln("  ")
	w.Writeln("    .. cpp:function:: %sResult %s::getErrorCode() const noexcept", NameSpace, ExceptionName)
	w.Writeln("    ")
	w.Writeln("       Returns error code")
	w.Writeln("    ")
	w.Writeln("       :return: the error code of this exception")
	w.Writeln("    ")
}

func buildJSDocumentationInputVector(component ComponentDefinition, w LanguageWriter, ClassIdentifier string) {
	LibraryName := component.LibraryName
	NameSpace := component.NameSpace

	InputVector := "C" + ClassIdentifier + "InputVector"
	w.Writeln("  ")
	w.Writeln("%s: Adapter for passing arrays as input for functions", InputVector)
	w.Writeln("===============================================================================================================================================================")
	w.Writeln("  ")
	w.Writeln("  Several functions of %s expect arrays of integral types or structs as input parameters.", LibraryName)
	w.Writeln("  To not restrict the interface to, say, std::vector<type>,")
	w.Writeln("  and to have a more abstract interface than a location in memory and the number of elements to input to a function")
	w.Writeln("  %s provides a templated adapter class to pass arrays as input for functions.", LibraryName)
	w.Writeln("  ")
	w.Writeln("  Usually, instances of %s are generated anonymously (or even implicitly) in the call to a function that expects an input array.", InputVector)
	w.Writeln("  ")
	w.Writeln("  ")

	w.Writeln("  .. cpp:class:: template<typename T> %s::%s", NameSpace, InputVector)
	w.Writeln("  ")
	w.Writeln("    .. cpp:function:: %s(const std::vector<T>& vec)", InputVector)
	w.Writeln("  ")
	w.Writeln("      Constructs of a %s from a std::vector<T>", InputVector)
	w.Writeln("  ")
	w.Writeln("    .. cpp:function:: %s(const T* in_data, size_t in_size)", InputVector)
	w.Writeln("  ")
	w.Writeln("      Constructs of a %s from a memory address and a given number of elements", InputVector)
	w.Writeln("  ")

	w.Writeln("    .. cpp:function:: const T* %s::data() const", InputVector)
	w.Writeln("  ")
	w.Writeln("      returns the start address of the data captured by this %s", InputVector)
	w.Writeln("  ")

	w.Writeln("    .. cpp:function:: size_t %s::size() const", InputVector)
	w.Writeln("  ")
	w.Writeln("      returns the number of elements captured by this %s", InputVector)
	w.Writeln("  ")
	w.Writeln(" ")
}

func buildJSDocumentationStructs(component ComponentDefinition, w LanguageWriter) error {
	if len(component.Structs) == 0 {
		return nil
	}

	NameSpace := component.NameSpace

	w.Writeln("")
	w.Writeln("Structs")
	w.Writeln("--------------")
	w.Writeln("")
	w.Writeln("  All structs are defined as `packed`, i.e. with the")
	w.Writeln("  ")
	w.Writeln("  .. code-block:: c")
	w.Writeln("    ")
	w.Writeln("    #pragma pack (1)")
	w.Writeln("")

	for i := 0; i < len(component.Structs); i++ {
		structinfo := component.Structs[i]
		w.Writeln("  .. cpp:struct:: s%s", structinfo.Name)
		w.Writeln("  ")
		// w.Writeln("    %s", structinfo.Description);
		// w.Writeln("  ");
		for j := 0; j < len(structinfo.Members); j++ {
			member := structinfo.Members[j]
			arraysuffix := ""
			if member.Rows > 0 {
				if member.Columns > 0 {
					arraysuffix = fmt.Sprintf("[%d][%d]", member.Columns, member.Rows)
				} else {
					arraysuffix = fmt.Sprintf("[%d]", member.Rows)
				}
			}
			memberLine, err := getCPPMemberLine(member, NameSpace, arraysuffix, structinfo.Name, "")
			if err != nil {
				return err
			}
			w.Writeln("    .. cpp:member:: %s", memberLine)
			w.Writeln("  ")
		}
		w.Writeln("")
	}

	return nil
}

func buildJSDocumentationSimpleTypes(component ComponentDefinition, w LanguageWriter) {
	NameSpace := component.NameSpace

	w.Writeln("Simple types")
	w.Writeln("--------------")
	w.Writeln("")
	types := []string{"uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64"}
	for _, _type := range types {
		w.Writeln("  .. cpp:type:: %s_t %s_%s", _type, NameSpace, _type)
		w.Writeln("  ")
	}
	w.Writeln("  .. cpp:type:: float %s_single", NameSpace)
	w.Writeln("  ")
	w.Writeln("  .. cpp:type:: double %s_double", NameSpace)
	w.Writeln("  ")
	w.Writeln("  .. cpp:type:: %s_pvoid = void*", NameSpace)
	w.Writeln("  ")
	w.Writeln("  .. cpp:type:: %sResult = %s_int32", NameSpace, NameSpace)
	w.Writeln("  ")
	w.Writeln("  ")
}

func buildJSDocumentationEnums(component ComponentDefinition, w LanguageWriter) {
	if len(component.Enums) == 0 {
		return
	}

	NameSpace := component.NameSpace

	w.Writeln("")
	w.Writeln("Enumerations")
	w.Writeln("--------------")
	w.Writeln("")
	for i := 0; i < len(component.Enums); i++ {
		enum := component.Enums[i]
		w.Writeln("  .. cpp:enum-class:: e%s : %s_int32", enum.Name, NameSpace)
		w.Writeln("  ")
		// w.Writeln("  %s", enum.Description)
		// w.Writeln("  ")
		for j := 0; j < len(enum.Options); j++ {
			option := enum.Options[j]
			w.Writeln("    .. cpp:enumerator:: %s = %d", option.Name, option.Value)
		}
		w.Writeln("  ")
	}
}

func buildJSDocumentationFunctionTypes(component ComponentDefinition, w LanguageWriter) error {
	if len(component.Functions) == 0 {
		return nil
	}
	w.Writeln("")
	w.Writeln("Function types")
	w.Writeln("---------------")
	w.Writeln("")
	w.Writeln("")
	for i := 0; i < len(component.Functions); i++ {
		functiontype := component.Functions[i]
		err := writeJSDocumentationFunctionPointer(component, w, functiontype)
		if err != nil {
			return err
		}
	}
	w.Writeln("")

	return nil
}

func buildJSDocumentationTypes(component ComponentDefinition, w LanguageWriter, ClassIdentifier string) error {
	LibraryName := component.LibraryName

	w.Writeln("")
	w.Writeln("Types used in %s", LibraryName)
	w.Writeln("==========================================================================================================")
	w.Writeln("")
	w.Writeln("")

	buildJSDocumentationSimpleTypes(component, w)
	buildJSDocumentationEnums(component, w)

	err := buildJSDocumentationStructs(component, w)
	if err != nil {
		return err
	}
	err = buildJSDocumentationFunctionTypes(component, w)
	if err != nil {
		return err
	}
	buildJSDocumentationException(component, w)
	buildJSDocumentationInputVector(component, w, ClassIdentifier)

	return nil
}
