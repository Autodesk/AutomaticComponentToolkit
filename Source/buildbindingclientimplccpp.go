package main

import (
	"bytes"
	"fmt"
	"log"
	"path"
	"strings"
	"text/template"
)

func buildCppClientImplementations(component ComponentDefinition, w LanguageWriter, wImpl LanguageWriter, outputFolder string, useStrictC bool, ExplicitLinking bool) error {
	libraryname := component.LibraryName
	BaseName := component.BaseName

	// Implementation of all base-class
	err := buildCppClientImplementationClass(component, component.baseClass(), w, wImpl, false, true)
	if err != nil {
		return err
	}

	// Implementation of all abstract classes
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		if (class.IsAbstract()) {
			clientImplHeader := path.Join(outputFolder, BaseName+"_dynamic_client_"+strings.ToLower(class.ClassName)+".hpp")
			log.Printf("Creating \"%s\"", clientImplHeader)
			dynclientfile, err := CreateLanguageFile(clientImplHeader, w.IndentString)
			if err != nil {
				return err
			}
			dynclientfile.WriteCLicenseHeader(component,
				fmt.Sprintf("This is an autogenerated C++-Header file in order to allow an easy\n use of %s", libraryname),
				true)

			clientImplSource := path.Join(outputFolder, BaseName+"_dynamic_client_"+strings.ToLower(class.ClassName)+".cpp")
			log.Printf("Creating \"%s\"", clientImplSource)
			dynclientfilesource, err := CreateLanguageFile(clientImplSource, w.IndentString)
			if err != nil {
				return err
			}

			err = buildCppClientImplementationClass(component, class, dynclientfile, dynclientfilesource, false, true)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func getComponentPropertyMap(component ComponentDefinition) map[string]interface{} {
	ret := map[string]interface{}{}
	ret["NameSpace"] = component.NameSpace
	ret["NameSpaceUpper"] = strings.ToUpper(component.NameSpace)
	ret["NameSpaceLower"] = strings.ToLower(component.NameSpace)
	return ret
}

func getClassPropertyMap(component ComponentDefinition, class ComponentDefinitionClass) map[string]interface{} {
	ret := getComponentPropertyMap(component)
	ret["ClassName"] = class.ClassName
	ret["ClassNameUpper"] = strings.ToUpper(class.ClassName)
	ret["ClassNameLower"] = strings.ToLower(class.ClassName)
	return ret
}

func getMethodPropertyMap(component ComponentDefinition, class ComponentDefinitionClass, method ComponentDefinitionMethod) map[string]interface{} {
    ret := getClassPropertyMap(component, class)
	ret["MethodName"] = method.MethodName
	ret["MethodNameUpper"] = strings.ToUpper(method.MethodName)
	ret["MethodNameLower"] = strings.ToLower(method.MethodName)
	return ret
}

func writeSubstitution(templateString string, properties map[string]interface{}, w LanguageWriter) error {
	tmpl, err := template.New("msg").Parse(templateString)
	if err != nil { 
		return err 
	}
	buf := &bytes.Buffer{}
	err = tmpl.Execute(buf, properties)
	if err != nil {
		return err
	}
	s := buf.String()
	w.Writeln(s)
	return nil
}

func buildCppClientImplementationBaseClassHeader(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter) error {
	err := error(nil)
	err = buildCppClientImplementationBaseClassHeaderBegin(component, class, w)
	if err != nil {
		return err
	}
	err = buildCppClientImplementationBaseClassHeaderAPIMethods(component, class, w)
	if err != nil {
		return err
	}
	err = buildCppClientImplementationBaseClassHeaderMiddle(component, class, w)
	if err != nil {
		return err
	}
	err = buildCppClientImplementationBaseClassHeaderABIMethods(component, class, w)
	if err != nil {
		return err
	}
	err = buildCppClientImplementationBaseClassHeaderEnd(component, class, w)
	if err != nil {
		return err
	}
	return nil;
}

func buildCppClientImplementationPreamble(component ComponentDefinition, w LanguageWriter) error {
	code := `

// Create a wrapped instance of a client implementation class. This means
// constructing a client implementation class instance, forwarding arguments
// passed to the function, which is then wrapped in a new binding instance of
// the appropriate type. The result can thus be passed into functions that deal
// in binding types.
template <typename tCLASS, typename... tARGS>                         
static tCLASS::tBINDING_PTR CreateWrappedInstance(tARGS&&... args)
{          
  auto ptr = std::make_unique<tCLASS>(std::forward<tARGS>(args)...);  
  ptr->AcquireInstance(); // CBase ctor doesn't acquire         
  return tBINDING_PTR(
    new tCLASS::tBINDING_CLASS(ptr.release()->GetExtendedHandle())
  );
}

// Given a pointer to a binding object, cast the wrapped handle to a client
// implementation instance. The caller is responsible for ensuring that the
// binding object really does wrap a client implementation.
template <typename tCLASS>
static tCLASS* UnsafeGetWrappedInstance(tCLASS::tBINDING_PTR pBindingPtr)
{
	return UnsafeGetWrappedInstance<tCLASS>(pBindingPtr->GetExtendedHandle())
}

// Cast a handle to a client implementation instance. The caller is responsible for
// ensuring that the binding object really does wrap a client implementation.
template <typename tCLASS>
static tCLASS* UnsafeGetWrappedInstance({{.NameSpace}}ExtendedHandle extendedHandle)
{
	return UnsafeGetWrappedInstance<tCLASS>(extendedHandle.m_hHandle);
}

// Cast a handle to a client implementation instance. The caller is responsible for
// ensuring that the binding object really does wrap a client implementation.
template <typename tCLASS>
static tCLASS* UnsafeGetWrappedInstance<tCLASS>({{.NameSpace}}Handle handle)
{
	return (tCLASS*) handle;
}
`
    return writeSubstitution(code, getComponentPropertyMap(component), w)
}

func buildCppClientImplementationBaseClassHeaderBegin(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter) error {
	code := `
#ifndef {{.NameSpace}}_CLIENT_{{.ClassName}}
#define {{.NameSpace}}_CLIENT_{{.ClassName}}

#include "{{.NameSpace}}_dynamic.hpp"

#include <algorithm>
#include <memory>
#include <string>

namespace {{.NameSpace}} {
namespace Binding {
namespace ClientImpl {

class C{{.ClassName}} {
public:

    using tBINDING_PTR = {{.NameSpace}}::Binding::P{{.ClassName}};
    using tBINDING_CLASS = {{.NameSpace}}::Binding::C{{.ClassName}};

    C{{.ClassName}}();
	C{{.ClassName}}(const C{{.ClassName}}& that) = delete;
	C{{.ClassName}}& operator=(const C{{.ClassName}}& that) = delete;
	virtual C{{.ClassName}}();

	{{.NameSpace}}ExtendedHandle GetExtendedHandle() const;

	virtual {{.NameSpace}}_pvoid GetSymbolLookupMethod() const;

	// API methods

`
	return writeSubstitution(code, getClassPropertyMap(component, class), w)
}

func buildCppClientImplementationBaseClassHeaderAPIMethods(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter) error {
	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]
		returnType, parameters, err := buildDynamicCPPMethodDeclaration(method, component.NameSpace, "", "C"+class.ClassName)
		if err != nil {
			return err
		}
		w.Writeln("  virtual %s %s(%s);", returnType, method.MethodName, parameters)
		w.Writeln("")
	}
	return nil
}

func buildCppClientImplementationBaseClassHeaderMiddle(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter) error {
	code := `
	protected:
	
	  // NOTE: helper for derived classes.
	  static {{.NameSpace}}Result LookupSymbolInMap(
		  const char* pProcName, 
		  std::map<std::string, void*>& procAddressMap, 
		  void** ppProcAddress
	  );
	
	  // Lookup method for this class.
	  // NOTE: derived class must wrap this and call it
	  static {{.NameSpace}}Result SymbolLookupFunction_ABI(
		  const char* pProcName, 
		  void** ppProcAddress
	  );
	
	private:
	  {{.NameSpace}}_uint64 m_refcount;`
	  return writeSubstitution(code, getClassPropertyMap(component, class), w)
}

func buildCppClientImplementationBaseClassHeaderABIMethods(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter) error {
	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]
		sComments, _, sParameters, err := WriteCCPPAbiMethod(method, component.NameSpace, class.ClassName, false, false, true)
		if (err != nil) {
			return err
		}
		w.Writeln("  ")
		w.Writelns("  ", sComments)
		w.Writeln("  static %sResult %s_ABI(%s);", component.NameSpace, method.MethodName, sParameters)
	}
	return nil
}

func buildCppClientImplementationBaseClassHeaderEnd(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter) error {
	code := `
	};
	
	} // namespace ClientImpl
	} // namespace Binding
	} // namespace {{.NameSpace}}
	
	#endif
`
	return writeSubstitution(code, getClassPropertyMap(component, class), w)
}


func buildCppClientImplementationBaseClassSource(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter) error {
	err := error(nil)
	err = buildCppClientImplementationBaseClassSourceBegin(component, class, w)
	if (err != nil) {
		return err
	}
	err = buildCppClientImplementationBaseClassSourceAPIMethods(component, class, w)
	if (err != nil) {
		return err
	}
	err = buildCppclientImplementationBaseClassSourceABIMethods(component, class, w)
	if (err != nil) {
		return err
	}
	err = buildCppClientImplementationSourceSymbolLookupFunctionABI(component, class, true, w)
	if (err != nil) {
		return err
	}
	return err
}

func buildCppClientImplementationBaseClassSourceBegin(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter) error {
	code := `
#include "{{.NameSpace}}_dynamic_client.hpp"

using namespace {{.NameSpace}};
using namespace {{.NameSpace}}::Binding::ClientImpl;

C{{.ClassName}}::C{{.ClassName}}()
   : m_refcount(0)
{
}

C{{.ClassName}}::~C{{.ClassName}}()
{
}

{{.NameSpace}}Result C{{.ClassName}}::LookupSymbolInMap(
	const char* pProcName, 
	std::map<std::string, void*>& procAddressMap, 
	void** ppProcAddress
)
{
  try {
    if (pProcName == nullptr)
	  return {{.NameSpaceUpper}}_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
	  return {{.NameSpaceUpper}}_ERROR_INVALIDPARAM;
	auto it = procAddressMap.find(pProcName);
	*ppProcAddress = it != end(procAddressMap) ? it->second : nullptr;
	if (!*ppProcAddress) {
	  return {{.NameSpaceUpper}}_ERROR_COULDNOTFINDLIBRARYEXPORT;
	}
  } catch ({{.NameSpace}}::Binding::E{{.NameSpace}}Exception&) {
    return {{.NameSpaceUpper}}_ERROR_GENERICEXCEPTION;
  } catch (std::exception&) {
    return {{.NameSpaceUpper}}_ERROR_GENERICEXCEPTION;
  } catch (...) {
    return {{.NameSpaceUpper}}_ERROR_GENERICEXCEPTION;
  }
  return {{.NameSpaceUpper}}_SUCCESS;
}
`
    return writeSubstitution(code, getClassPropertyMap(component, class), w)
}

func buildCppClientImplementationSourceSymbolLookupFunctionABI(component ComponentDefinition, class ComponentDefinitionClass, isBaseClass bool, w LanguageWriter) error {
	// TODO: deal with derived classes too. in that case, want to generate code
	// to call the base class on lookup failure.   Then we can dispense with the
	// LOOKUP IMPL BEGIN/END macros.
	err := error(nil)
	properties := getClassPropertyMap(component, class)
	beginCode := `
{{.NameSpace}}Result C{{.ClassName}}::SymbolLookupFunction_ABI(
  const char* pProcName, 
  void** ppProcAddress
)
{
  static std::map<std::string, void*> sProcAddressMap;
  if (sProcAddressMap.empty()) {`
    err = writeSubstitution(beginCode, properties, w)
	if err != nil {
		return err
	}

	methodCode := `    sProcAddressMap["{{.NameSpaceLower}}_{{.ClassNameLower}}_{{.MethodNameLower}}"] = (void*) &{{.MethodName}}_ABI;`
	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]
		methodProperties := getMethodPropertyMap(component, class, method)
		err = writeSubstitution(methodCode, methodProperties, w)
		if err != nil {
			return err
		}
	}

	endCode := ""
	if isBaseClass {
		endCode = `
}
return LookupSymbolInMap(pProcName, sProcAddressMap, ppProcAddress);
}`
	} else {
		endCode = `
}
{{.NameSpace}}Result ret = LookupSymbolInMap(pProcName, sProcAddressMap, ppProcAddress);
if (ret == {{.NameSpaceUpper}}_ERROR_COULDNOTFINDLIBRARYEXPORT) {
	ret = tBASE::SymbolLookupFunction_ABI(pProcName, sProcAddressMap, ppProcAddress);
}
return ret;
}`
	}
	err = writeSubstitution(endCode, properties, w)
	if err != nil {
		return err
	}

	return err
}

func buildCppClientImplementationBaseClassSourceAPIMethods(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter) error {
	beginComment := `
/*************************************************************************************************************************
 API-methods")
**************************************************************************************************************************/
`
    w.Writeln(beginComment)
    return nil
}

func buildCppclientImplementationBaseClassSourceABIMethods(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter) error {
	beginComment := `
/*************************************************************************************************************************
 ABI-methods")
**************************************************************************************************************************/
`
    w.Writeln(beginComment)

	// TODO: need to generate the code here to forward the call.   This is the main obstacle to having this
	// be part of ACT.

	methodCode := `
{{.NameSpace}}Result C{{.ClassName}}::{{.MethodName}}_ABI({{.Parameters}})
{
  try {
    // map parameters
	// forward call to c++ function
    (C{{.ClassName}}*)p{{.ClassName}}.m_hHandle->{{.MethodName}}();
	// post-process parameters
  } catch ({{.NameSpace}}::Binding::E{{.NameSpace}}Exception&) {
    return {{.NameSpaceUpper}}_ERROR_GENERICEXCEPTION;
  } catch (std::exception&) {
    return {{.NameSpaceUpper}}_ERROR_GENERICEXCEPTION;
  } catch (...) {
    return {{.NameSpaceUpper}}_ERROR_GENERICEXCEPTION;
  }
  return {{.NameSpaceUpper}}_SUCCESS;
}`

	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]
		properties := getMethodPropertyMap(component, class, method)
		_, _, sParameters, err := WriteCCPPAbiMethod(method, component.NameSpace, class.ClassName, false, false, true)
		if (err != nil) {
			return err
		}
		properties["Parameters"] = sParameters
		err = writeSubstitution(methodCode, properties, w)
		if err != nil {
			return err
		}
	}

	return nil
}

func buildCppClientImplementationClass(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter, wImpl LanguageWriter, useStrictC bool, ExplicitLinking bool) error {
	theClass := class
	theClassName := theClass.ClassName

	bIsBaseClass := theClass.ClassName == component.baseClass().ClassName

	NameSpace := component.NameSpace
	NameSpaceUpper := strings.ToUpper(NameSpace)
	NameSpaceLower := strings.ToLower(NameSpace)
	BaseName := component.BaseName

	sIncludeGuard := "__" + strings.ToUpper(NameSpace + "_CLIENT_" + theClassName)
	w.Writeln("#ifndef %s", sIncludeGuard)
	w.Writeln("#define %s", sIncludeGuard)

	w.Writeln("")
	
	if (bIsBaseClass) {
		w.Writeln("#include \"%s_dynamic.hpp\"", BaseName)
	} else {
		w.Writeln("#include \"%s_dynamic_client.hpp\"", BaseName)
	}

	if (bIsBaseClass) {
		w.Writeln("")
		w.Writeln("// %s_BEGIN_WRAP_CALL / %s_END_WRAP_CALL: used to implement an 'ABI' wrapper", NameSpaceUpper, NameSpaceUpper)
		w.Writeln("// function.  Call the corresponding instance method between these macros")
		w.Writeln("// to convert exceptions to error codes.")
		w.Writeln("#define %s_BEGIN_WRAP_CALL try", NameSpaceUpper)
		w.Writeln("#define %s_END_WRAP_CALL                                     \\", NameSpaceUpper)
		w.Writeln("catch (%s::Binding::E%sException&) {    \\", NameSpace, NameSpace)
		w.Writeln("  return %s_ERROR_GENERICEXCEPTION;              \\", NameSpaceUpper)
		w.Writeln("} catch (std::exception&) {                               \\")
		w.Writeln("  return %s_ERROR_GENERICEXCEPTION;              \\", NameSpaceUpper)
		w.Writeln("} catch (...) {                                           \\")
		w.Writeln("  return %s_ERROR_GENERICEXCEPTION;              \\", NameSpaceUpper)
		w.Writeln("}                                                         \\")
		w.Writeln("return %s_SUCCESS;", NameSpaceUpper)
		w.Writeln("")
		w.Writeln("")
		
		w.Writeln("// %s_IMPL_DECLARE/IMPLEMENT macros.  Use these for each derived impl class.", NameSpaceUpper)
		w.Writeln("#define %s_IMPL_DECLARE(NAME, BINDINGNAME)                             \\", NameSpaceUpper)
		w.Writeln("  public:                                                              \\")
		w.Writeln("    using tBINDING_PTR = %s::Binding::P ## BINDINGNAME;                \\", NameSpace)
		w.Writeln("    using tBINDING_CLASS = %s::Binding::C ## BINDINGNAME;              \\", NameSpace)
		w.Writeln("    %s GetExtendedHandle();                                            \\", component.getExtendedHandleName())
		w.Writeln("    template <typename... Args>                                        \\")
		w.Writeln("    static tBINDING_PTR CreateWrappedInstance(Args&&... args) {        \\")
		w.Writeln("      auto ptr = std::make_unique<NAME>(std::forward<Args>(args)...);  \\")
		w.Writeln("      ptr->%s(); /* CBase ctor doesn't acquire */          \\", theClass.AcquireMethod)
		w.Writeln("      return tBINDING_PTR(                                             \\")
		w.Writeln("        new tBINDING_CLASS(ptr.release()->GetExtendedHandle())         \\")
		w.Writeln("      );                                                               \\")
		w.Writeln("    }                                                                  \\")
		w.Writeln("    virtual %s_pvoid GetSymbolLookupMethod() override;                 \\", NameSpace)
		w.Writeln("  protected:                                                           \\")
		w.Writeln("    static %sResult SymbolLookupFunction_ABI(                              \\", NameSpace)
		w.Writeln("      const char* pProcName,                                           \\")
		w.Writeln("      void** ppProcAddress                                             \\")
		w.Writeln("    );                                                                 \\")
		w.Writeln("    static NAME* FromExtendedHandle(%s& handle);", component.getExtendedHandleName())
		w.Writeln("")
		w.Writeln("#define %s_IMPL_IMPLEMENT(NAME)                           \\", NameSpaceUpper)
		w.Writeln("  %s NAME::GetExtendedHandle()                                         \\", component.getExtendedHandleName())
		w.Writeln("  {                                                                    \\")
		w.Writeln("    return { this, &NAME::SymbolLookupFunction_ABI };                      \\")
		w.Writeln("  }                                                                    \\")
		w.Writeln("  %s_pvoid NAME::GetSymbolLookupMethod()                               \\", NameSpace)
		w.Writeln("  {                                                                    \\")
		w.Writeln("    return (void*) &NAME::SymbolLookupFunction_ABI;                        \\")
		w.Writeln("  }                                                                    \\")
		w.Writeln("  NAME* NAME::FromExtendedHandle(%s& handle)                    \\", component.getExtendedHandleName())
		w.Writeln("  {                                                                    \\")
		w.Writeln("    return (NAME*) handle.m_hHandle;                            \\")
		w.Writeln("  }                                                                    \\")
		w.Writeln("")
		w.Writeln("")

		w.Writeln("#define %s_IMPL_LOOKUP_IMPLEMENT_BEGIN(NAME, BASE, RAWNAME)        \\", NameSpaceUpper)
		w.Writeln("  %sResult NAME::SymbolLookupFunction_ABI(                    \\", NameSpace)
		w.Writeln("    const char* pProcName,                                \\")
		w.Writeln("    void** ppProcAddress                                  \\")
		w.Writeln("  )                                                       \\")
		w.Writeln("  {                                                       \\")
		w.Writeln("    using tBASE = BASE;                                   \\")
		w.Writeln("    std::string className = #RAWNAME;                     \\")
		w.Writeln("    static std::map<std::string, void*> sProcAddressMap;  \\")
		w.Writeln("    if (sProcAddressMap.empty()) {")
		w.Writeln("")
		w.Writeln("#define %s_IMPL_LOOKUP_ADD(FUNCTION)                                    \\", NameSpaceUpper)
		w.Writeln("      {                                                                 \\")
		w.Writeln("        std::string functionName = #FUNCTION;                           \\")
		w.Writeln("        std::string mapName = \"%s_\" + className +              \\", NameSpaceLower)
		w.Writeln("          std::string(\"_\") + functionName;                              \\")
		w.Writeln("        std::transform(mapName.begin(), mapName.end(), mapName.begin(), \\")
		w.Writeln("                       [](unsigned char c){ return std::tolower(c); }); \\")
		w.Writeln("        sProcAddressMap[mapName] = (void*) &FUNCTION##_ABI;             \\")
		w.Writeln("      }")
		w.Writeln("")
		w.Writeln("#define %s_IMPL_LOOKUP_IMPLEMENT_END()                                \\", NameSpaceUpper)
		w.Writeln("    }                                                              \\")
		w.Writeln("    %sResult ret = LookupSymbolInMap(                     \\", NameSpace)
		w.Writeln("      pProcName, sProcAddressMap, ppProcAddress);                  \\")
		w.Writeln("    if (ret == %s_ERROR_COULDNOTFINDLIBRARYEXPORT) {      \\", NameSpaceUpper)
		w.Writeln("      ret = tBASE::SymbolLookupFunction_ABI(pProcName, ppProcAddress); \\")
		w.Writeln("    }                                                              \\")
		w.Writeln("    return ret;                                                    \\")
		w.Writeln("  }                                                                \\")
		w.Writeln("")
	}
	
	w.Writeln("")
	w.Writeln("#include <algorithm>")
	w.Writeln("#include <memory>")
	w.Writeln("#include <string>")
	w.Writeln("")

	// Declaration and Implementation of abstract or base - class
	w.Writeln("")
	w.Writeln("namespace %s {", NameSpace)
	w.Writeln("namespace ClientImpl {")
	w.Writeln("")
	
	ClientImplClassPrefix := "C"

	clientImplClassName := ClientImplClassPrefix + theClassName
	if (bIsBaseClass) {
		w.Writeln("class %s {", clientImplClassName)
	} else {
		w.Writeln("class %s : public %s {", clientImplClassName, ClientImplClassPrefix +  component.baseClass().ClassName)
		w.Writeln("")
		w.Writeln("  %s_IMPL_DECLARE(%s, %s)", NameSpaceUpper, clientImplClassName, theClassName)
		w.Writeln("")
	}
	w.Writeln("public:")
	w.Writeln("  %s();", clientImplClassName)
	w.Writeln("  virtual ~%s();", clientImplClassName)
	w.Writeln("")

	if (bIsBaseClass) {
		wImpl.Writeln("#include \"%s_dynamic_client.hpp\"", BaseName)
		wImpl.Writeln("")
		wImpl.Writeln("")
		wImpl.Writeln("using namespace %s;", NameSpace)
		wImpl.Writeln("using namespace %s::ClientImpl;", NameSpace)
		wImpl.Writeln("")
	} else {
		wImpl.Writeln("#include \"%s_dynamic_client_%s.hpp\"", BaseName, strings.ToLower(theClassName))
		wImpl.Writeln("")
		wImpl.Writeln("")
		wImpl.Writeln("using namespace %s;", NameSpace)
		wImpl.Writeln("using namespace %s::ClientImpl;", NameSpace)
		wImpl.Writeln("")

		wImpl.Writeln("%s_IMPL_IMPLEMENT(%s)", NameSpaceUpper, clientImplClassName)
		wImpl.Writeln("%s_IMPL_LOOKUP_IMPLEMENT_BEGIN(%s, %s, %s)", NameSpaceUpper, clientImplClassName, ClientImplClassPrefix +  component.baseClass().ClassName, theClassName)
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			wImpl.Writeln("%s_IMPL_LOOKUP_ADD(%s)", NameSpaceUpper, method.MethodName)
		}
		wImpl.Writeln("%s_IMPL_LOOKUP_IMPLEMENT_END()", NameSpaceUpper)
		wImpl.Writeln("")
	}
		
	wImpl.Writeln("%s::%s()", clientImplClassName, clientImplClassName)
	if (bIsBaseClass) {
		wImpl.Writeln("  : m_refcount(0)")
	}
	wImpl.Writeln("{")
	wImpl.Writeln("}")

	wImpl.Writeln("")
	wImpl.Writeln("%s::~%s()", clientImplClassName, clientImplClassName)
	wImpl.Writeln("{")
	wImpl.Writeln("}")
	wImpl.Writeln("")

	w.Writeln("  // API-methods")
	wImpl.Writeln("/*************************************************************************************************************************")
	wImpl.Writeln(" API-methods")
	wImpl.Writeln("**************************************************************************************************************************/")
	wImpl.Writeln("")
	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]
		returnType, parameters, err := buildDynamicCPPMethodDeclaration(method, NameSpace, "", theClassName)
		if err != nil {
			return err
		}
		w.Writeln("  virtual %s %s(%s);", returnType, method.MethodName, parameters)
		w.Writeln("")

		wImpl.Writeln("%s %s::%s(%s)", returnType, clientImplClassName, method.MethodName, parameters)
		wImpl.Writeln("{")
		wImpl.Writeln("  throw %s::Binding::E%sException(%s_ERROR_NOTIMPLEMENTED, \"\");", NameSpace, NameSpace, NameSpaceUpper)
		wImpl.Writeln("}")
		wImpl.Writeln("")
	}
	w.Writeln("")
	w.Writeln("protected:")
	w.Writeln("")
	if (bIsBaseClass) {
		w.Writeln("  // NOTE: helper for derived classes.")
		w.Writeln("  static %sResult LookupSymbolInMap(const char* pProcName, std::map<std::string, void*>& procAddressMap, void** ppProcAddress);", NameSpace)
		w.Writeln("")
		wImpl.Writeln("%sResult %s::LookupSymbolInMap(const char* pProcName, std::map<std::string, void*>& procAddressMap, void** ppProcAddress)", NameSpace, clientImplClassName)
		wImpl.Writeln("{")
		wImpl.Writeln("  %s_BEGIN_WRAP_CALL {", NameSpaceUpper)
		wImpl.Writeln("    if (pProcName == nullptr)")
		wImpl.Writeln("      return %s_ERROR_INVALIDPARAM;", NameSpaceUpper)
		wImpl.Writeln("    if (ppProcAddress == nullptr)")
		wImpl.Writeln("      return %s_ERROR_INVALIDPARAM;", NameSpaceUpper)
		wImpl.Writeln("    auto it = procAddressMap.find(pProcName);")
		wImpl.Writeln("    *ppProcAddress = it != end(procAddressMap) ? it->second : nullptr;")
		wImpl.Writeln("    if (!*ppProcAddress) {")
		wImpl.Writeln("      return %s_ERROR_COULDNOTFINDLIBRARYEXPORT;", NameSpaceUpper)
		wImpl.Writeln("    }")
		wImpl.Writeln("  } %s_END_WRAP_CALL", NameSpaceUpper)
		wImpl.Writeln("}")
		wImpl.Writeln("")
		
		w.Writeln("  // Lookup method for this class.")
		w.Writeln("  // NOTE: derived class must wrap this and call it")
		w.Writeln("  static %sResult SymbolLookupFunction_ABI(const char* pProcName, void** ppProcAddress);", NameSpace)
		wImpl.Writeln("%sResult %s::SymbolLookupFunction_ABI(const char* pProcName, void** ppProcAddress)", NameSpace, clientImplClassName)
		wImpl.Writeln("{")
		wImpl.Writeln("  static std::map<std::string, void*> sProcAddressMap;")
		wImpl.Writeln("  if (sProcAddressMap.empty()) {")
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			wImpl.Writeln("    sProcAddressMap[\"%s_%s_%s\"] = (void*)& %s_ABI;", NameSpaceLower, strings.ToLower(theClassName), strings.ToLower(method.MethodName), method.MethodName)
		}
		wImpl.Writeln("  }")
		wImpl.Writeln("  return LookupSymbolInMap(pProcName, sProcAddressMap, ppProcAddress);")
		wImpl.Writeln("}")
	}
	w.Writeln("")
	w.Writeln("private:")
	if (bIsBaseClass) {
		w.Writeln("  %s_uint64 m_refcount;", NameSpace)
		w.Writeln("")
	}

	w.Writeln("  // ABI-methods")
	wImpl.Writeln("/*************************************************************************************************************************")
	wImpl.Writeln(" ABI-methods")
	wImpl.Writeln("**************************************************************************************************************************/")
	wImpl.Writeln("")
	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]
		sComments, _, sParameters, err := WriteCCPPAbiMethod(method, NameSpace, class.ClassName, false, false, true)
		if (err != nil) {
			return err
		}
		w.Writeln("  ")
		w.Writelns("  ", sComments)
		w.Writeln("  static %sResult %s_ABI(%s);", NameSpace, method.MethodName, sParameters)

		wImpl.Writeln("%sResult %s::%s_ABI(%s)", NameSpace, clientImplClassName, method.MethodName, sParameters)
		wImpl.Writeln("{")
		wImpl.Writeln("  %s_BEGIN_WRAP_CALL {", NameSpaceUpper)
		if (bIsBaseClass) {
			wImpl.Writeln("    // map parameters")
			wImpl.Writeln("    // forward call to C++-function")
			wImpl.Writeln("    // ((%s*)p%s.m_hHandle)->%s();", clientImplClassName, theClassName, method.MethodName)
			wImpl.Writeln("    // post-process parameters")
		} else {
			wImpl.Writeln("    // map parameters")
			wImpl.Writeln("    // forward call to C++-function")
			wImpl.Writeln("    // FromExtendedHandle(p%s)->%s();", theClassName, method.MethodName)
			wImpl.Writeln("    // post-process parameters")
		}
		wImpl.Writeln("  } %s_END_WRAP_CALL", NameSpaceUpper)
		wImpl.Writeln("}")
		wImpl.Writeln("")
	}
	w.Writeln("")
	
	w.Writeln("};")
	w.Writeln("")
	w.Writeln("} // namespace %s", NameSpace)
	w.Writeln("} // namespace ClientImpl")
	w.Writeln("")

	wImpl.Writeln("")

	w.Writeln("#endif // %s", sIncludeGuard)
	w.Writeln("")

	return nil
}