/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildbindingnode.go
// functions to generate NodeJS-bindings of a library's API.
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"fmt"
	"log"
	"path"
	"strings"
)

// BuildBindingNode builds NodeJS-bindings of a library's API
func BuildBindingNode(component ComponentDefinition, outputFolder string, indentString string) error {
	namespace := component.NameSpace
	libraryname := component.LibraryName
	baseName := component.BaseName

	NodeAddOnImplName := path.Join(outputFolder, baseName+"_nodeaddon.cc")
	log.Printf("Creating \"%s\"", NodeAddOnImplName)
	nodeaddonfile, err := CreateLanguageFile(NodeAddOnImplName, indentString)
	if err != nil {
		return err
	}
	nodeaddonfile.WriteCLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated C++ Implementation file for the Node addon class \n of %s", libraryname),
		true)

	NodeWrapperHeaderName := path.Join(outputFolder, baseName+"_nodewrapper.h")
	log.Printf("Creating \"%s\"", NodeWrapperHeaderName)
	nodewrapperhfile, err := CreateLanguageFile(NodeWrapperHeaderName, indentString)
	if err != nil {
		return err
	}
	nodewrapperhfile.WriteCLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated C++ Header file for the Node wrapper class \n of %s", libraryname),
		true)

	NodeWrapperImplName := path.Join(outputFolder, baseName+"_nodewrapper.cc")
	log.Printf("Creating \"%s\"", NodeWrapperImplName)
	nodewrapperccfile, err := CreateLanguageFile(NodeWrapperImplName, indentString)
	if err != nil {
		return err
	}
	nodewrapperccfile.WriteCLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated C++ Implementation file for the Node wrapper class \n of %s", libraryname),
		true)

	err = buildNodeAddOnImplementation(component, nodeaddonfile, namespace, baseName)
	if err != nil {
		return err
	}

	NodeBindingGypName := path.Join(outputFolder, "binding.gyp")
	log.Printf("Creating \"%s\"", NodeBindingGypName)
	bindinggypfile, err := CreateLanguageFile(NodeBindingGypName, indentString)
	if err != nil {
		return err
	}
	buildNodeBindingGyp(component, bindinggypfile)

	return buildNodeWrapperClass(component, nodewrapperhfile, nodewrapperccfile, namespace, baseName)
}

func buildNodeAddOnImplementation(component ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln("")
	w.Writeln("#include <node.h>")
	w.Writeln("#include \"%s_nodewrapper.h\"", BaseName)
	w.Writeln("")
	w.Writeln("using namespace v8;")
	w.Writeln("")
	w.Writeln("void Load%s(const FunctionCallbackInfo<Value>& args)", NameSpace)
	w.Writeln("{")
	w.Writeln("  Isolate* isolate = args.GetIsolate();")
	w.Writeln("  HandleScope scope(isolate);")
	w.Writeln("  args.GetReturnValue().Set(C%sWrapper::NewInstance(args));", NameSpace)
	w.Writeln("}")
	w.Writeln("")
	w.Writeln("void InitAll(v8::Local<Object> exports, v8::Local<Object> module)")
	w.Writeln("{")
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		w.Writeln("  C%s%s::Init();", NameSpace, class.ClassName)
	}
	w.Writeln("  C%sWrapper::Init();", NameSpace)
	w.Writeln("  NODE_SET_METHOD(module, \"exports\", Load%s);", NameSpace)
	w.Writeln("}")
	w.Writeln("")

	w.Writeln("NODE_MODULE(%s_nodeaddon, InitAll)", strings.ToLower(NameSpace))
	w.Writeln("")

	return nil
}

func writeNodeMethodImplementation(method ComponentDefinitionMethod, implw LanguageWriter, NameSpace string, ClassName string, isGlobal bool) error {

	returndeclaration := ""
	inputdeclaration := ""
	inputcheck := ""
	returncode := ""
	functioncode := ""
	requiresInitCall := false

	spacing := "        "

	callParameters := ""
	initCallParameters := ""

	returnParamCount := 0

	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		if (param.ParamPass == "out") || (param.ParamPass == "return") {
			returnParamCount = returnParamCount + 1
		}
	}

	if returnParamCount > 1 {
		inputdeclaration = inputdeclaration + fmt.Sprintf("%sLocal<Object> outObject = Object::New(isolate);\n", spacing)
	}

	for k := 0; k < len(method.Params); k++ {

		initCallParameter := ""
		callParameter := ""

		param := method.Params[k]
		switch param.ParamPass {
		case "in":

			inputcheckfunction := ""

			switch param.ParamType {
			case "uint8":
				inputcheckfunction = "IsUint32"
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sunsigned char n%s = (unsigned char) args[%d]->Uint32Value(isolate->GetCurrentContext()).ToChecked();\n", spacing, param.ParamName, k)
				callParameter = "n" + param.ParamName
				initCallParameter = callParameter

			case "uint16":
				inputcheckfunction = "IsUint32"
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sunsigned short n%s = (unsigned short) args[%d]->Uint32Value(isolate->GetCurrentContext()).ToChecked();\n", spacing, param.ParamName, k)
				callParameter = "n" + param.ParamName
				initCallParameter = callParameter

			case "uint32":
				inputcheckfunction = "IsUint32"
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sunsigned int n%s = (unsigned int) args[%d]->IntegerValue(isolate->GetCurrentContext()).ToChecked();\n", spacing, param.ParamName, k)
				callParameter = "n" + param.ParamName
				initCallParameter = callParameter

			case "uint64":
				inputcheckfunction = "IsString"

				inputdeclaration = inputdeclaration + fmt.Sprintf("%sv8::String::Utf8Value sutf8%s(isolate, args[%d]);\n", spacing, param.ParamName, k)
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sstd::string s%s = *sutf8%s;\n", spacing, param.ParamName, param.ParamName)
				inputdeclaration = inputdeclaration + fmt.Sprintf("%suint64_t n%s = stoull(s%s);\n", spacing, param.ParamName, param.ParamName)
				callParameter = "n" + param.ParamName
				initCallParameter = callParameter

			case "pointer":
				inputcheckfunction = "IsString"

				inputdeclaration = inputdeclaration + fmt.Sprintf("%sv8::String::Utf8Value sutf8%s(isolate, args[%d]);\n", spacing, param.ParamName, k)
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sstd::string s%s = *sutf8%s;\n", spacing, param.ParamName, param.ParamName)
				inputdeclaration = inputdeclaration + fmt.Sprintf("%suint64_t n%s = stoull(s%s);\n", spacing, param.ParamName, param.ParamName)
				callParameter = "(void*) n" + param.ParamName
				initCallParameter = callParameter

			case "int8":
				inputcheckfunction = "IsInt32"
				inputdeclaration = inputdeclaration + fmt.Sprintf("%s char n%s = (char) args[%d]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n", spacing, param.ParamName, k)
				callParameter = "n" + param.ParamName
				initCallParameter = callParameter

			case "int16":
				inputcheckfunction = "IsInt32"
				inputdeclaration = inputdeclaration + fmt.Sprintf("%s short n%s = (short) args[%d]->Int32Value(isolate->GetCurrentContext()).ToChecked();\n", spacing, param.ParamName, k)
				callParameter = "n" + param.ParamName
				initCallParameter = callParameter

			case "int32":
				inputcheckfunction = "IsInt32"
				inputdeclaration = inputdeclaration + fmt.Sprintf("%s int n%s = (int) args[%d]->IntegerValue(isolate->GetCurrentContext()).ToChecked();\n", spacing, param.ParamName, k)
				callParameter = "n" + param.ParamName
				initCallParameter = callParameter

			case "int64":
				inputcheckfunction = "IsString"

				inputdeclaration = inputdeclaration + fmt.Sprintf("%sv8::String::Utf8Value sutf8%s(isolate, args[%d]);\n", spacing, param.ParamName, k)
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sstd::string s%s = *sutf8%s;\n", spacing, param.ParamName, param.ParamName)
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sint64_t n%s = stoll(s%s);\n", spacing, param.ParamName, param.ParamName)
				callParameter = "n" + param.ParamName
				initCallParameter = callParameter

			case "string":
				inputcheckfunction = "IsString"

				inputdeclaration = inputdeclaration + fmt.Sprintf("%sv8::String::Utf8Value sutf8%s(isolate, args[%d]);\n", spacing, param.ParamName, k)
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sstd::string s%s = *sutf8%s;\n", spacing, param.ParamName, param.ParamName)
				callParameter = "s" + param.ParamName + ".c_str()"
				initCallParameter = callParameter

			case "basicarray":
				callParameter = "0, nullptr"
				initCallParameter = callParameter

			case "structarray":
				callParameter = "0, nullptr"
				initCallParameter = callParameter

			case "functiontype":
				callParameter = "nullptr"
				initCallParameter = callParameter

			case "bool":
				inputcheckfunction = "IsBoolean"
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sbool b%s = args[%d]->BooleanValue(isolate->GetCurrentContext()).ToChecked();\n", spacing, param.ParamName, k)
				callParameter = "b" + param.ParamName
				initCallParameter = callParameter

			case "single":
				inputcheckfunction = "IsNumber"
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sfloat f%s = (float) args[%d]->NumberValue(isolate->GetCurrentContext()).ToChecked();\n", spacing, param.ParamName, k)
				callParameter = "f" + param.ParamName
				initCallParameter = callParameter

			case "double":
				inputcheckfunction = "IsNumber"
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sdouble d%s = (double) args[%d]->NumberValue(isolate->GetCurrentContext()).ToChecked();\n", spacing, param.ParamName, k)
				callParameter = "d" + param.ParamName
				initCallParameter = callParameter

			case "enum":
				inputcheckfunction = "IsUint32"
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sunsigned int e%s = (unsigned int) args[%d]->IntegerValue(isolate->GetCurrentContext()).ToChecked();\n", spacing, param.ParamName, k)
				callParameter = fmt.Sprintf("(e%s%s) e%s", NameSpace, param.ParamClass, param.ParamName)
				initCallParameter = callParameter

			case "struct":
				inputcheckfunction = "IsObject"

				inputdeclaration = inputdeclaration + fmt.Sprintf("%ss%s%s s%s = convertObjectTo%s%s(isolate, args[%d]);\n", spacing, NameSpace, param.ParamClass, param.ParamName, NameSpace, param.ParamClass, k)

				callParameter = fmt.Sprintf("&s%s", param.ParamName)
				initCallParameter = callParameter

			case "class", "optionalclass":
				inputcheckfunction = "IsObject"

				inputdeclaration = inputdeclaration + fmt.Sprintf("%sLocal<Object> obj%s = args[%d]->ToObject(isolate->GetCurrentContext()).ToLocalChecked();\n", spacing, param.ParamName, k)
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sC%s%s * instance%s = ObjectWrap::Unwrap<C%s%s>(obj%s);\n", spacing, NameSpace, param.ParamClass, param.ParamName, NameSpace, param.ParamClass, param.ParamName)
				inputdeclaration = inputdeclaration + fmt.Sprintf("%sif (instance%s == nullptr)\n", spacing, param.ParamName)
				inputdeclaration = inputdeclaration + fmt.Sprintf("%s    throw std::runtime_error(\"Invalid Object parameter %d (%s)\");\n", spacing, k, param.ParamName)
				inputdeclaration = inputdeclaration + fmt.Sprintf("%s%sHandle h%s = instance%s->getHandle( obj%s );\n", spacing, NameSpace, param.ParamName, param.ParamName, param.ParamName)

				callParameter = "h" + param.ParamName
				initCallParameter = callParameter

			default:
				return fmt.Errorf("invalid method parameter type \"%s\" for %s.%s(%s)", param.ParamType, ClassName, method.MethodName, param.ParamName)

			}

			if inputcheckfunction != "" {
				inputcheck = inputcheck + fmt.Sprintf("%sif (!args[%d]->%s()) {\n", spacing, k, inputcheckfunction)
				inputcheck = inputcheck + fmt.Sprintf("%s    throw std::runtime_error(\"Expected %s parameter %d (%s)\");\n", spacing, param.ParamType, k, param.ParamName)
				inputcheck = inputcheck + fmt.Sprintf("%s}\n", spacing)
			}

		case "out", "return":

			var argsvalue string
			if returnParamCount > 1 {
				argsvalue = fmt.Sprintf("outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, \"%s\"), ", param.ParamName)

			} else {
				argsvalue = "args.GetReturnValue().Set("
			}

			switch param.ParamType {
			case "uint8":
				returndeclaration = returndeclaration + fmt.Sprintf("%sunsigned char nReturn%s = 0;\n", spacing, param.ParamName)
				callParameter = "&nReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sInteger::NewFromUnsigned(isolate, nReturn%s));\n", spacing, argsvalue, param.ParamName)

			case "uint16":
				returndeclaration = returndeclaration + fmt.Sprintf("%sunsigned short nReturn%s = 0;\n", spacing, param.ParamName)
				callParameter = "&nReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sInteger::NewFromUnsigned(isolate, nReturn%s));\n", spacing, argsvalue, param.ParamName)

			case "uint32":
				returndeclaration = returndeclaration + fmt.Sprintf("%sunsigned int nReturn%s = 0;\n", spacing, param.ParamName)
				callParameter = "&nReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sInteger::NewFromUnsigned(isolate, nReturn%s));\n", spacing, argsvalue, param.ParamName)

			case "uint64":
				returndeclaration = returndeclaration + fmt.Sprintf("%suint64_t nReturn%s = 0;\n", spacing, param.ParamName)
				callParameter = "&nReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sString::NewFromUtf8(isolate, std::to_string(nReturn%s).c_str()));\n", spacing, argsvalue, param.ParamName)

			case "pointer":
				returndeclaration = returndeclaration + fmt.Sprintf("%suint64_t nReturn%s = 0;\n", spacing, param.ParamName)
				callParameter = "&nReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sString::NewFromUtf8(isolate, std::to_string(nReturn%s).c_str()));\n", spacing, argsvalue, param.ParamName)

			case "int8":
				returndeclaration = returndeclaration + fmt.Sprintf("%schar nReturn%s = 0;\n", spacing, param.ParamName)
				callParameter = "&nReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sInteger::New(isolate, nReturn%s));\n", spacing, argsvalue, param.ParamName)

			case "int16":
				returndeclaration = returndeclaration + fmt.Sprintf("%s short nReturn%s = 0;\n", spacing, param.ParamName)
				callParameter = "&nReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sInteger::New(isolate, nReturn%s));\n", spacing, argsvalue, param.ParamName)

			case "int32":
				returndeclaration = returndeclaration + fmt.Sprintf("%s int nReturn%s = 0;\n", spacing, param.ParamName)
				callParameter = "&nReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sInteger::New(isolate, nReturn%s));\n", spacing, argsvalue, param.ParamName)

			case "int64":
				returndeclaration = returndeclaration + fmt.Sprintf("%s int64_t nReturn%s = 0;\n", spacing, param.ParamName)
				callParameter = "&nReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sString::NewFromUtf8(isolate, std::to_string(nReturn%s).c_str() ));\n", spacing, argsvalue, param.ParamName)

			case "string":
				requiresInitCall = true

				returndeclaration = returndeclaration + fmt.Sprintf("%sunsigned int bytesNeeded%s = 0;\n", spacing, param.ParamName)
				returndeclaration = returndeclaration + fmt.Sprintf("%sunsigned int bytesWritten%s = 0;\n", spacing, param.ParamName)
				initCallParameter = fmt.Sprintf("0, &bytesNeeded%s, nullptr", param.ParamName)

				functioncode = functioncode + fmt.Sprintf("%sstd::vector<char> buffer%s;\n", spacing, param.ParamName)
				functioncode = functioncode + fmt.Sprintf("%sbuffer%s.resize(bytesNeeded%s);\n", spacing, param.ParamName, param.ParamName)

				callParameter = fmt.Sprintf("bytesNeeded%s, &bytesWritten%s, &buffer%s[0]", param.ParamName, param.ParamName, param.ParamName)

				returncode = returncode + fmt.Sprintf("%s%sString::NewFromUtf8(isolate, &buffer%s[0]));\n", spacing, argsvalue, param.ParamName)

			case "bool":
				returndeclaration = returndeclaration + fmt.Sprintf("%sbool bReturn%s = false;\n", spacing, param.ParamName)
				callParameter = "&bReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sBoolean::New(isolate, bReturn%s));\n", spacing, argsvalue, param.ParamName)

			case "single":
				returndeclaration = returndeclaration + fmt.Sprintf("%sfloat fReturn%s = 0.0f;\n", spacing, param.ParamName)
				callParameter = "&fReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sNumber::New(isolate, (double)fReturn%s));\n", spacing, argsvalue, param.ParamName)

			case "double":
				returndeclaration = returndeclaration + fmt.Sprintf("%sdouble dReturn%s = 0.0;\n", spacing, param.ParamName)
				callParameter = "&dReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sNumber::New(isolate, dReturn%s));\n", spacing, argsvalue, param.ParamName)

			case "enum":
				returndeclaration = returndeclaration + fmt.Sprintf("%se%s%s eReturn%s;\n", spacing, NameSpace, param.ParamClass, param.ParamName)
				callParameter = "&eReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sInteger::New(isolate, (int)eReturn%s));\n", spacing, argsvalue, param.ParamName)

			case "struct":
				returndeclaration = returndeclaration + fmt.Sprintf("%ss%s%s sReturn%s;\n", spacing, NameSpace, param.ParamClass, param.ParamName)
				callParameter = "&sReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%s%sconvert%s%sToObject(isolate, sReturn%s));\n", spacing, argsvalue, NameSpace, param.ParamClass, param.ParamName)

			case "basicarray":
				callParameter = "0, nullptr, nullptr"
				initCallParameter = callParameter

			case "structarray":
				callParameter = "0, nullptr, nullptr"
				initCallParameter = callParameter

			case "functiontype":
				callParameter = "nullptr"
				initCallParameter = callParameter

			case "class", "optionalclass":
				returndeclaration = returndeclaration + fmt.Sprintf("%s%sHandle hReturn%s = nullptr;\n", spacing, NameSpace, param.ParamName)
				callParameter = "&hReturn" + param.ParamName
				initCallParameter = callParameter

				returncode = returncode + fmt.Sprintf("%sLocal<Object> instanceObj%s = C%s%s::NewInstance(args.Holder(), hReturn%s);\n", spacing, param.ParamName, NameSpace, param.ParamClass, param.ParamName)
				returncode = returncode + fmt.Sprintf("%s%sinstanceObj%s);\n", spacing, argsvalue, param.ParamName)

			default:
				return fmt.Errorf("invalid method parameter type \"%s\" for %s.%s(%s)", param.ParamType, ClassName, method.MethodName, param.ParamName)

			}
		}

		if callParameters != "" {
			callParameters = callParameters + ", " + callParameter
		} else {
			callParameters = callParameters + callParameter
		}

		if initCallParameters != "" {
			initCallParameters = initCallParameters + ", " + initCallParameter
		} else {
			initCallParameters = initCallParameters + initCallParameter
		}

	}

	if returnParamCount > 1 {
		returncode = returncode + fmt.Sprintf("%sargs.GetReturnValue().Set(outObject);\n", spacing)
	}

	implw.Writeln("")

	implw.Writeln("void C%s%s::%s(const FunctionCallbackInfo<Value>& args) ", NameSpace, ClassName, method.MethodName)
	implw.Writeln("{")
	implw.Writeln("    Isolate* isolate = args.GetIsolate();")
	implw.Writeln("    HandleScope scope(isolate);")
	implw.Writeln("    try {")

	fmt.Fprintf(implw.Writer, inputcheck)
	fmt.Fprintf(implw.Writer, inputdeclaration)

	fmt.Fprintf(implw.Writer, returndeclaration)

	implw.Writeln("%ss%sDynamicWrapperTable * wrapperTable = C%sBaseClass::getDynamicWrapperTable(args.Holder());", spacing, NameSpace, NameSpace)
	implw.Writeln("%sif (wrapperTable == nullptr)", spacing)
	implw.Writeln("%s    throw std::runtime_error(\"Could not get wrapper table for %s method %s.\");", spacing, NameSpace, method.MethodName)

	if isGlobal {
		implw.Writeln("%sif (wrapperTable->m_%s == nullptr)", spacing, method.MethodName)
		implw.Writeln("%s    throw std::runtime_error(\"Could not call %s method %s.\");", spacing, NameSpace, method.MethodName)
	} else {
		implw.Writeln("%sif (wrapperTable->m_%s_%s == nullptr)", spacing, ClassName, method.MethodName)
		implw.Writeln("%s    throw std::runtime_error(\"Could not call %s method %s::%s.\");", spacing, NameSpace, ClassName, method.MethodName)
	}

	if !isGlobal {
		implw.Writeln("%s%sHandle instanceHandle = C%sBaseClass::getHandle(args.Holder());", spacing, NameSpace, NameSpace)
	}

	if requiresInitCall {

		if isGlobal {
			implw.Writeln("%s%sResult initErrorCode = wrapperTable->m_%s(%s);", spacing, NameSpace, method.MethodName, initCallParameters)

		} else {
			if initCallParameters != "" {
				initCallParameters = ", " + initCallParameters
			}
			implw.Writeln("%s%sResult initErrorCode = wrapperTable->m_%s_%s(instanceHandle%s);", spacing, NameSpace, ClassName, method.MethodName, initCallParameters)
		}

		if isGlobal {
			implw.Writeln("%sCheckError(isolate, wrapperTable, nullptr, initErrorCode);", spacing)
		} else {
			implw.Writeln("%sCheckError(isolate, wrapperTable, instanceHandle, initErrorCode);", spacing)
		}
	}

	fmt.Fprintf(implw.Writer, functioncode)

	if isGlobal {
		implw.Writeln("%s%sResult errorCode = wrapperTable->m_%s(%s);", spacing, NameSpace, method.MethodName, callParameters)

	} else {
		if callParameters != "" {
			callParameters = ", " + callParameters
		}
		implw.Writeln("%s%sResult errorCode = wrapperTable->m_%s_%s(instanceHandle%s);", spacing, NameSpace, ClassName, method.MethodName, callParameters)
	}

	if isGlobal {
		implw.Writeln("%sCheckError(isolate, wrapperTable, nullptr, errorCode);", spacing)
	} else {
		implw.Writeln("%sCheckError(isolate, wrapperTable, instanceHandle, errorCode);", spacing)
	}

	fmt.Fprintf(implw.Writer, returncode)

	implw.Writeln("")
	implw.Writeln("    } catch (std::exception & E) {")
	implw.Writeln("        RaiseError(isolate, E.what());")
	implw.Writeln("    }")
	implw.Writeln("}")
	implw.Writeln("")

	return nil
}

func buildNodeStructConversion(structdefinition ComponentDefinitionStruct, implw LanguageWriter, NameSpace string) error {

	hasRowVariable := false
	hasColumnVariable := false

	for i := 0; i < len(structdefinition.Members); i++ {

		member := structdefinition.Members[i]
		if member.Rows > 0 {
			hasRowVariable = true

			if member.Columns > 0 {
				hasColumnVariable = true
			}
		}
	}

	implw.Writeln("/*************************************************************************************************************************")
	implw.Writeln(" Class s%s%s Conversion", NameSpace, structdefinition.Name)
	implw.Writeln("**************************************************************************************************************************/")
	implw.Writeln("s%s%s convertObjectTo%s%s(Isolate* isolate, const Local<Value> & pParamValue)", NameSpace, structdefinition.Name, NameSpace, structdefinition.Name)
	implw.Writeln("{")
	implw.Writeln("  s%s%s s%s;", NameSpace, structdefinition.Name, structdefinition.Name)
	implw.Writeln("  Local<Context> context = isolate->GetCurrentContext();")

	if hasRowVariable {
		implw.Writeln("  int rowIndex;")
	}
	if hasColumnVariable {
		implw.Writeln("  int columnIndex;")
	}

	implw.Writeln("")

	for i := 0; i < len(structdefinition.Members); i++ {

		member := structdefinition.Members[i]
		defaultValue, err := GetCMemberDefaultValue(member.Type, member.Class, NameSpace)
		if err != nil {
			return err
		}

		defaultValueAssignment := " = " + defaultValue
		if member.Type == "enum" {
			defaultValueAssignment = ".m_code = " + defaultValue
		}

		if member.Rows > 0 {
			if member.Columns > 0 {
				implw.Writeln("  for (columnIndex = 0; columnIndex < %d; columnIndex++)", member.Columns)
				implw.Writeln("    for (rowIndex = 0; rowIndex < %d; rowIndex++)", member.Rows)
				implw.Writeln("      s%s.m_%s[columnIndex][rowIndex]%s;", structdefinition.Name, member.Name, defaultValueAssignment)
			} else {
				implw.Writeln("  for (rowIndex = 0; rowIndex < %d; rowIndex++)", member.Rows)
				implw.Writeln("    s%s.m_%s[rowIndex]%s;", structdefinition.Name, member.Name, defaultValueAssignment)
			}
		} else {

			implw.Writeln("  s%s.m_%s%s;", structdefinition.Name, member.Name, defaultValueAssignment)
		}

	}

	implw.Writeln("")
	implw.Writeln("  if (pParamValue->IsObject()) {")
	implw.Writeln("    MaybeLocal<Object> maybeObject = pParamValue->ToObject(context);")
	implw.Writeln("")
	implw.Writeln("    if (!maybeObject.IsEmpty()) {")
	implw.Writeln("      Local<Object> obj = maybeObject.ToLocalChecked();")
	implw.Writeln("")

	for i := 0; i < len(structdefinition.Members); i++ {

		member := structdefinition.Members[i]
		implw.Writeln("      // %s Member", member.Name)

		implw.Writeln("      MaybeLocal<Value> maybeVal%s = obj->Get(context, String::NewFromUtf8(isolate, \"%s\"));", member.Name, member.Name)
		implw.Writeln("      if (!maybeVal%s.IsEmpty()) {", member.Name)
		implw.Writeln("        Local<Value> val%s = maybeVal%s.ToLocalChecked();", member.Name, member.Name)

		valueTypeCall := ""
		assignmentOperator := " = "
		switch member.Type {
		case "uint8", "uint16", "uint32":
			valueTypeCall = "Uint32Value"
		case "int8", "int16", "int32":
			valueTypeCall = "Int32Value"
		case "enum":
			valueTypeCall = "Int32Value"
			assignmentOperator = ".m_code = "

		case "uint64", "int64":
			valueTypeCall = "IntegerValue"
		case "pointer":
			valueTypeCall = "IntegerValue"
			assignmentOperator = " = (void *)"
		case "bool":
			valueTypeCall = "BooleanValue"
		case "single":
			assignmentOperator = " = (float)"
			valueTypeCall = "NumberValue"
		case "double":
			valueTypeCall = "NumberValue"
		}

		if member.Rows > 0 {

			implw.Writeln("        if (val%s->IsArray()) {", member.Name)
			implw.Writeln("          Local<Array> array%s = Local<Array>::Cast(val%s);", member.Name, member.Name)

			if member.Columns > 0 {

				implw.Writeln("          for (int colIndex = 0; colIndex < %d; colIndex++) {", member.Columns)
				implw.Writeln("            MaybeLocal<Value> mlocalCol = array%s->Get(context, colIndex);", member.Name)
				implw.Writeln("            Local<Value> localCol;")
				implw.Writeln("            if (mlocalCol.ToLocal(&localCol)) {")
				implw.Writeln("        	  if (localCol->IsArray()) {")
				implw.Writeln("                Local<Array> localColArray = Local<Array>::Cast(localCol);")
				implw.Writeln("                for (int rowIndex = 0; rowIndex < %d; rowIndex++) {", member.Rows)
				implw.Writeln("                  MaybeLocal<Value> mlocalValue = localColArray->Get(context, rowIndex);")
				implw.Writeln("                  Local<Value> localValue;")
				implw.Writeln("                  if (mlocalValue.ToLocal(&localValue)) {")
				implw.Writeln("                    if (localValue->IsNumber()) {")
				implw.Writeln("                      MaybeLocal<Number> localNumber = localValue->ToNumber(context);")
				implw.Writeln("                      s%s.m_%s[colIndex][rowIndex]%slocalNumber.ToLocalChecked()->%s(isolate->GetCurrentContext()).ToChecked();", structdefinition.Name, member.Name, assignmentOperator, valueTypeCall)
				implw.Writeln("                    } else {")
				implw.Writeln("                      isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, \"%s array entry is not a number\" )));", member.Name)
				implw.Writeln("                    }")
				implw.Writeln("                  } else {")
				implw.Writeln("                    isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, \"%s array entry is invalid\" )));", member.Name)
				implw.Writeln("                  }")
				implw.Writeln("                }")
				implw.Writeln("              } else {")
				implw.Writeln("                isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, \"%s array entry is not an array\" )));", member.Name)
				implw.Writeln("              }")
				implw.Writeln("            } else {")
				implw.Writeln("              isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, \"%s array entry is invalid\" )));", member.Name)
				implw.Writeln("            }")
				implw.Writeln("          }")

			} else {

				implw.Writeln("          for (int rowIndex = 0; rowIndex < %d; rowIndex++) {", member.Rows)
				implw.Writeln("            MaybeLocal<Value> mlocalValue = array%s->Get(context, rowIndex);", member.Name)
				implw.Writeln("            Local<Value> localValue;")
				implw.Writeln("            if (mlocalValue.ToLocal(&localValue)) {")
				implw.Writeln("              if (localValue->IsNumber()) {")
				implw.Writeln("                MaybeLocal<Number> localNumber = localValue->ToNumber(context);")
				implw.Writeln("                s%s.m_%s[rowIndex]%slocalNumber.ToLocalChecked()->%s(isolate->GetCurrentContext()).ToChecked();", structdefinition.Name, member.Name, assignmentOperator, valueTypeCall)
				implw.Writeln("              } else {")
				implw.Writeln("                isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, \"%s array entry is not a number\" )));", member.Name)
				implw.Writeln("              }")
				implw.Writeln("            } else {")
				implw.Writeln("              isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, \"%s array entry is invalid\" )));", member.Name)
				implw.Writeln("            }")
				implw.Writeln("          }")

			}

			implw.Writeln("        } else {")
			implw.Writeln("          isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, \"%s member is not an array\" )));", member.Name)
			implw.Writeln("        }")

		} else {
			implw.Writeln("        if (val%s->IsNumber()) {", member.Name)
			implw.Writeln("          MaybeLocal<Number> localVal%s = val%s->ToNumber(context);", member.Name, member.Name)
			implw.Writeln("          s%s.m_%s%slocalVal%s.ToLocalChecked()->%s(isolate->GetCurrentContext()).ToChecked();", structdefinition.Name, member.Name, assignmentOperator, member.Name, valueTypeCall)
			implw.Writeln("        } else {")
			implw.Writeln("          isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, \"%s member is not a number\" )));", member.Name)
			implw.Writeln("        }")
		}

		implw.Writeln("      } else {")
		implw.Writeln("        isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, \"%s member not found in object\" )));", member.Name)
		implw.Writeln("      }")
		implw.Writeln("")

	}

	implw.Writeln("")
	implw.Writeln("    } else {")
	implw.Writeln("      isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, \"invalid object passed.\" )));")
	implw.Writeln("    }")
	implw.Writeln("  } else {")
	implw.Writeln("    isolate->ThrowException(Exception::TypeError(String::NewFromUtf8(isolate, \"expected object parameter.\" )));")
	implw.Writeln("  }")
	implw.Writeln("")
	implw.Writeln("  return s%s;", structdefinition.Name)
	implw.Writeln("}")
	implw.Writeln("")
	implw.Writeln("")

	implw.Writeln("")
	implw.Writeln("Local<Object> convert%s%sToObject(Isolate* isolate, s%s%s s%s)", NameSpace, structdefinition.Name, NameSpace, structdefinition.Name, structdefinition.Name)
	implw.Writeln("{")
	implw.Writeln("  Local<Object> returnInstance = Object::New(isolate);")

	for i := 0; i < len(structdefinition.Members); i++ {

		member := structdefinition.Members[i]

		conversionCall := ""
		conversionValue := fmt.Sprintf("s%s.m_%s", structdefinition.Name, member.Name)
		conversionPostfix := ""
		switch member.Type {
		case "uint8", "uint16", "uint32":
			conversionCall = "Integer::NewFromUnsigned"
		case "int8", "int16", "int32":
			conversionCall = "Integer::New"
		case "enum":
			conversionCall = "Integer::New"
			conversionPostfix = ".m_code"
		case "uint64", "int64":
			conversionCall = "String::NewFromUtf8"
			conversionValue = "std::to_string(" + conversionValue
			conversionPostfix = ").c_str()"
		case "pointer":
			conversionCall = "String::NewFromUtf8"
			conversionValue = "std::to_string((uint_ptr) " + conversionValue
			conversionPostfix = ").c_str()"
		case "bool":
			conversionCall = "Boolean::New"
		case "single":
			conversionCall = "Number::New"
			conversionValue = "(double) " + conversionValue
		case "double":
			conversionCall = "Number::New"

		}

		if member.Rows > 0 {

			if member.Columns > 0 {

				implw.Writeln("  Local<Array> new%s = Array::New(isolate, %d);", member.Name, member.Columns)
				implw.Writeln("  for (int colIndex = 0; colIndex < %d; colIndex++) {", member.Columns)
				implw.Writeln("    Local<Array> colArray = Array::New(isolate, %d);", member.Rows)
				implw.Writeln("    for (int rowIndex = 0; rowIndex < %d; rowIndex++) {", member.Rows)
				implw.Writeln("      colArray->Set(rowIndex, %s(isolate, %s[colIndex][rowIndex]%s));", conversionCall, conversionValue, conversionPostfix)
				implw.Writeln("    }")
				implw.Writeln("    new%s->Set(colIndex, colArray);", member.Name)
				implw.Writeln("  }")
				implw.Writeln("  returnInstance->Set(String::NewFromUtf8(isolate, \"%s\"), new%s);", member.Name, member.Name)
				implw.Writeln("")

			} else {

				implw.Writeln("  Local<Array> new%s = Array::New(isolate, %d);", member.Name, member.Rows)
				implw.Writeln("  for (int rowIndex = 0; rowIndex < %d; rowIndex++) {", member.Rows)
				implw.Writeln("    new%s->Set(rowIndex, %s(isolate, %s[rowIndex]%s));", member.Name, conversionCall, conversionValue, conversionPostfix)
				implw.Writeln("  }")
				implw.Writeln("  returnInstance->Set(String::NewFromUtf8(isolate, \"%s\"), new%s);", member.Name, member.Name)
				implw.Writeln("")

			}

		} else {
			implw.Writeln("  returnInstance->Set(String::NewFromUtf8(isolate, \"%s\"), %s (isolate, %s%s));", member.Name, conversionCall, conversionValue, conversionPostfix)
		}

	}

	implw.Writeln("")
	implw.Writeln("  return returnInstance;")
	implw.Writeln("}")
	implw.Writeln("")

	return nil
}

func buildNodeWrapperClass(component ComponentDefinition, w LanguageWriter, implw LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln("")
	w.Writeln("#ifndef %s_NODEWRAPPER_H", strings.ToUpper(NameSpace))
	w.Writeln("#define %s_NODEWRAPPER_H", strings.ToUpper(NameSpace))
	w.Writeln("")
	w.Writeln("#include \"%s_dynamic.h\"", strings.ToLower(NameSpace))
	w.Writeln("#include <node.h>")
	w.Writeln("#include <node_object_wrap.h>")
	w.Writeln("#include <string>")
	w.Writeln("#include <stdexcept>")
	w.Writeln("")

	w.Writeln("#define NODEWRAPPER_FIELDCOUNT 4")
	w.Writeln("#define NODEWRAPPER_TABLEINDEX 2")
	w.Writeln("#define NODEWRAPPER_HANDLEINDEX 3")

	w.Writeln("/*************************************************************************************************************************")
	w.Writeln(" Forward declarations ")
	w.Writeln("**************************************************************************************************************************/")

	w.Writeln("")
	w.Writeln("class C%sWrapper;", NameSpace)
	w.Writeln("")

	w.Writeln("/*************************************************************************************************************************")
	w.Writeln(" Class C%sBaseClass ", NameSpace)
	w.Writeln("**************************************************************************************************************************/")
	w.Writeln("")

	w.Writeln("class C%sBaseClass : public node::ObjectWrap {", NameSpace)
	w.Writeln("private:")
	w.Writeln("protected:")
	w.Writeln("public:")
	w.Writeln("  C%sBaseClass();", NameSpace)
	w.Writeln("  static void RaiseError(v8::Isolate * isolate, std::string Message);")
	w.Writeln("  static void CheckError(v8::Isolate * isolate, s%sDynamicWrapperTable * sWrapperTable, %sHandle pInstance, %sResult errorCode);", NameSpace, NameSpace, NameSpace)
	w.Writeln("  static void setHandle(%sHandle pHandle);", NameSpace)
	w.Writeln("  static %sHandle getHandle(v8::Local<v8::Object> objecthandle);", NameSpace)
	w.Writeln("  static s%sDynamicWrapperTable * getDynamicWrapperTable(v8::Local<v8::Object> objecthandle);", NameSpace)
	w.Writeln("};")
	w.Writeln("")
	w.Writeln("")

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]

		w.Writeln("/*************************************************************************************************************************")
		w.Writeln(" Class C%s%s ", NameSpace, class.ClassName)
		w.Writeln("**************************************************************************************************************************/")
		w.Writeln("class C%s%s : public C%sBaseClass {", NameSpace, class.ClassName, NameSpace)
		w.Writeln("private:")
		w.Writeln("  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);")
		w.Writeln("  static v8::Persistent<v8::Function> constructor;")

		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			w.Writeln("  static void %s(const v8::FunctionCallbackInfo<v8::Value>& args);", method.MethodName)
		}

		w.Writeln("")
		w.Writeln("public:")
		w.Writeln("  C%s%s();", NameSpace, class.ClassName)
		w.Writeln("  ~C%s%s();", NameSpace, class.ClassName)
		w.Writeln("  ")
		w.Writeln("  static void Init();")
		w.Writeln("  static v8::Local<v8::Object> NewInstance(v8::Local<v8::Object>, %sHandle pHandle);", NameSpace)
		w.Writeln("  ")
		w.Writeln("};")
		w.Writeln("")

	}

	w.Writeln("/*************************************************************************************************************************")
	w.Writeln(" Class C%sWrapper ", NameSpace)
	w.Writeln("**************************************************************************************************************************/")

	w.Writeln("")
	w.Writeln("class C%sWrapper : public C%sBaseClass {", NameSpace, NameSpace)
	w.Writeln("private:")
	w.Writeln("  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);")
	w.Writeln("  static v8::Persistent<v8::Function> constructor;")

	global := component.Global
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		w.Writeln("  static void %s(const v8::FunctionCallbackInfo<v8::Value>& args);", method.MethodName)
	}

	w.Writeln("")
	w.Writeln("public:")
	w.Writeln("  C%sWrapper();", NameSpace)
	w.Writeln("  ~C%sWrapper();", NameSpace)
	w.Writeln("  static void Init();")
	w.Writeln("  static v8::Local<v8::Object> NewInstance(const v8::FunctionCallbackInfo<v8::Value>& args);")
	w.Writeln("};")

	w.Writeln("")
	w.Writeln("#endif // %s_NODEWRAPPER_H", strings.ToUpper(NameSpace))
	w.Writeln("")

	implw.Writeln("")
	implw.Writeln("#include <node.h>")
	implw.Writeln("#include \"%s_nodewrapper.h\"", BaseName)
	implw.Writeln("")
	implw.Writeln("")
	implw.Writeln("using namespace v8;")
	implw.Writeln("")
	implw.Writeln("Persistent<Function> C%sWrapper::constructor;", NameSpace)
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		implw.Writeln("Persistent<Function> C%s%s::constructor;", NameSpace, class.ClassName)
	}
	implw.Writeln("")

	for i := 0; i < len(component.Structs); i++ {
		structdefinition := component.Structs[i]
		err := buildNodeStructConversion(structdefinition, implw, NameSpace)
		if err != nil {
			return err
		}
	}

	implw.Writeln("/*************************************************************************************************************************")
	implw.Writeln(" Class C%sBaseClass Implementation", NameSpace)
	implw.Writeln("**************************************************************************************************************************/")
	implw.Writeln("")
	implw.Writeln("C%sBaseClass::C%sBaseClass()", NameSpace, NameSpace)
	implw.Writeln("    : node::ObjectWrap()")
	implw.Writeln("{")
	implw.Writeln("")
	implw.Writeln("}")
	implw.Writeln("")
	implw.Writeln("void C%sBaseClass::RaiseError(v8::Isolate * isolate, std::string Message)", NameSpace)
	implw.Writeln("{")
	implw.Writeln("    if (isolate != nullptr) {")
	implw.Writeln("        isolate->ThrowException(Exception::TypeError(")
	implw.Writeln("            String::NewFromUtf8(isolate, Message.c_str() )));")
	implw.Writeln("    }")
	implw.Writeln("}")

	implw.Writeln("void C%sBaseClass::CheckError(v8::Isolate * isolate, s%sDynamicWrapperTable * sWrapperTable, %sHandle pInstance, %sResult errorCode)", NameSpace, NameSpace, NameSpace, NameSpace)
	implw.Writeln("{")
	implw.Writeln("    if (errorCode != 0) {")
	implw.Writeln("      std::string sMessage;")

	if len(component.Global.ErrorMethod) > 0 {

		implw.Writeln("      if ((sWrapperTable != nullptr) && (pInstance != nullptr)) {")
		implw.Writeln("        if (sWrapperTable->m_%s != nullptr) {", component.Global.ErrorMethod)
		implw.Writeln("          uint32_t neededChars = 0;")
		implw.Writeln("          bool hasLastError = 0;")
		implw.Writeln("          if (sWrapperTable->m_%s(pInstance, 0, &neededChars, nullptr, &hasLastError) == 0) {", component.Global.ErrorMethod)
		implw.Writeln("            uint32_t dummyChars = 0;")
		implw.Writeln("            std::vector<char> Buffer;")
		implw.Writeln("            Buffer.resize(neededChars + 2);")
		implw.Writeln("            if (sWrapperTable->m_%s(pInstance, neededChars + 1, &dummyChars, Buffer.data(), &hasLastError) == 0) {", component.Global.ErrorMethod)
		implw.Writeln("              Buffer[neededChars + 1] = 0;")
		implw.Writeln("              sMessage = std::string(\": \") + std::string(&Buffer[0]);")
		implw.Writeln("            }")
		implw.Writeln("          }")
		implw.Writeln("        }")
		implw.Writeln("      }")

	}
	implw.Writeln("      throw std::runtime_error(\"%s Error\" + sMessage + \" (\" + std::to_string(errorCode) + \")\");", NameSpace)
	implw.Writeln("    }")
	implw.Writeln("}")

	implw.Writeln("")
	implw.Writeln("void C%sBaseClass::setHandle(%sHandle pHandle)", NameSpace, NameSpace)
	implw.Writeln("{")
	implw.Writeln("    ")
	implw.Writeln("}")
	implw.Writeln("")
	implw.Writeln("%sHandle C%sBaseClass::getHandle(v8::Local<v8::Object> objecthandle)", NameSpace, NameSpace)
	implw.Writeln("{")
	implw.Writeln("    auto Field = objecthandle->GetInternalField(NODEWRAPPER_HANDLEINDEX);")
	implw.Writeln("    v8::Local<v8::External> externalField = Field.As<v8::External>();")
	implw.Writeln("    return (%sHandle *) externalField->Value();", NameSpace)
	implw.Writeln("}")
	implw.Writeln("")
	implw.Writeln("s%sDynamicWrapperTable * C%sBaseClass::getDynamicWrapperTable(v8::Local<v8::Object> objecthandle)", NameSpace, NameSpace)
	implw.Writeln("{")
	implw.Writeln("    auto Field = objecthandle->GetInternalField(NODEWRAPPER_TABLEINDEX);")
	implw.Writeln("    v8::Local<v8::External> externalField = Field.As<v8::External>();")
	implw.Writeln("    return (s%sDynamicWrapperTable *) externalField->Value();", NameSpace)
	implw.Writeln("}")

	implw.Writeln("")
	implw.Writeln("")

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]

		implw.Writeln("/*************************************************************************************************************************")
		implw.Writeln(" Class C%s%s Implementation", NameSpace, class.ClassName)
		implw.Writeln("**************************************************************************************************************************/")
		implw.Writeln("")

		implw.Writeln("C%s%s::C%s%s()", NameSpace, class.ClassName, NameSpace, class.ClassName)
		implw.Writeln("    : C%sBaseClass()", NameSpace)
		implw.Writeln("{")
		implw.Writeln("}")
		implw.Writeln("")
		implw.Writeln("C%s%s::~C%s%s()", NameSpace, class.ClassName, NameSpace, class.ClassName)
		implw.Writeln("{")
		implw.Writeln("}")
		implw.Writeln("")
		implw.Writeln("void C%s%s::Init()", NameSpace, class.ClassName)
		implw.Writeln("{")
		implw.Writeln("    Isolate* isolate = Isolate::GetCurrent();")
		implw.Writeln("")
		implw.Writeln("    // Prepare constructor template")
		implw.Writeln("    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);")
		implw.Writeln("    tpl->SetClassName(String::NewFromUtf8(isolate, \"%s%s\"));", NameSpace, class.ClassName)
		implw.Writeln("    tpl->InstanceTemplate()->SetInternalFieldCount(NODEWRAPPER_FIELDCOUNT);")
		implw.Writeln("")
		implw.Writeln("    // Prototype")

		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			implw.Writeln("    NODE_SET_PROTOTYPE_METHOD(tpl, \"%s\", %s);", method.MethodName, method.MethodName)
		}

		implw.Writeln("    constructor.Reset(isolate, tpl->GetFunction(isolate->GetCurrentContext()).ToLocalChecked());")
		implw.Writeln("")
		implw.Writeln("}")
		implw.Writeln("")

		implw.Writeln("void C%s%s::New(const FunctionCallbackInfo<Value>& args)", NameSpace, class.ClassName)
		implw.Writeln("{")
		implw.Writeln("    Isolate* isolate = args.GetIsolate();")
		implw.Writeln("    HandleScope scope(isolate);")
		implw.Writeln("")
		implw.Writeln("    if (args.IsConstructCall()) {")
		implw.Writeln("        C%sBaseClass * holderObj = ObjectWrap::Unwrap<C%sBaseClass>(args.Holder());", NameSpace, NameSpace)
		implw.Writeln("        C%s%s * %sInstance = new C%s%s();", NameSpace, class.ClassName, strings.ToLower(class.ClassName), NameSpace, class.ClassName)

		//fmt.Fprintf (implw, "        Local<Object> localHolderObj = args.Holder();\n");
		//fmt.Fprintf (implw, "        %sInstance->m_pWrapperObject.Reset (localHolderObj);\n", strings.ToLower (class.ClassName));

		implw.Writeln("        %sInstance->Wrap(args.This());", strings.ToLower(class.ClassName))
		implw.Writeln("        args.GetReturnValue().Set(args.This());")
		implw.Writeln("    } else {")
		implw.Writeln("        RaiseError(isolate, \"%s%s: Invalid call to Constructor\");", NameSpace, class.ClassName)
		implw.Writeln("    }")
		implw.Writeln("}")
		implw.Writeln("")

		implw.Writeln("Local<Object> C%s%s::NewInstance(Local<Object> pParent, %sHandle pHandle)", NameSpace, class.ClassName, NameSpace)
		implw.Writeln("{")
		implw.Writeln("    Isolate* isolate = Isolate::GetCurrent();")
		implw.Writeln("    HandleScope scope(isolate);")
		implw.Writeln("    Local<Function> cons = Local<Function>::New(isolate, constructor);")
		implw.Writeln("    Local<Object> instance;")
		implw.Writeln("    if (cons->NewInstance(isolate->GetCurrentContext()).ToLocal(&instance)) {")
		implw.Writeln("      instance->SetInternalField(NODEWRAPPER_TABLEINDEX, External::New(isolate, C%sBaseClass::getDynamicWrapperTable(pParent)));", NameSpace)
		implw.Writeln("      instance->SetInternalField(NODEWRAPPER_HANDLEINDEX, External::New(isolate, pHandle));")
		implw.Writeln("    }")
		implw.Writeln("    return instance;")
		implw.Writeln("}")
		implw.Writeln("")

		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			err := writeNodeMethodImplementation(method, implw, NameSpace, class.ClassName, false)
			if err != nil {
				return err
			}
		}
	}

	implw.Writeln("/*************************************************************************************************************************")
	implw.Writeln(" Class C%sWrapper Implementation", NameSpace)
	implw.Writeln("**************************************************************************************************************************/")
	implw.Writeln("")

	implw.Writeln("C%sWrapper::C%sWrapper()", NameSpace, NameSpace)
	implw.Writeln("    : C%sBaseClass()", NameSpace)
	implw.Writeln("{")
	implw.Writeln("}")
	implw.Writeln("")
	implw.Writeln("C%sWrapper::~C%sWrapper()", NameSpace, NameSpace)
	implw.Writeln("{")
	implw.Writeln("")
	implw.Writeln("}")
	implw.Writeln("")
	implw.Writeln("void C%sWrapper::Init()", NameSpace)
	implw.Writeln("{")
	implw.Writeln("    Isolate* isolate = Isolate::GetCurrent();")
	implw.Writeln("    // Prepare constructor template")
	implw.Writeln("    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);")
	implw.Writeln("    tpl->SetClassName(String::NewFromUtf8(isolate, \"%sWrapper\"));", NameSpace)
	implw.Writeln("    tpl->InstanceTemplate()->SetInternalFieldCount(NODEWRAPPER_FIELDCOUNT);")
	implw.Writeln("    ")
	implw.Writeln("    // Prototype")
	implw.Writeln("    ")
	global = component.Global
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		implw.Writeln("    NODE_SET_PROTOTYPE_METHOD(tpl, \"%s\", %s);", method.MethodName, method.MethodName)
	}

	implw.Writeln("    constructor.Reset(isolate, tpl->GetFunction(isolate->GetCurrentContext()).ToLocalChecked());")
	implw.Writeln("}")
	implw.Writeln("")
	implw.Writeln("void C%sWrapper::New(const FunctionCallbackInfo<Value>& args)", NameSpace)
	implw.Writeln("{")
	implw.Writeln("    Isolate* isolate = args.GetIsolate();")
	implw.Writeln("    HandleScope scope(isolate);")
	implw.Writeln("")
	implw.Writeln("    try {")
	implw.Writeln("        if (args.IsConstructCall()) {")

	implw.Writeln("            // Get Library Name as Argument")
	implw.Writeln("            #ifdef _WIN32")
	implw.Writeln("            std::string sLibraryName = \"%s.dll\";", BaseName)
	implw.Writeln("            #elif __APPLE__")
	implw.Writeln("            std::string sLibraryName = \"%s.dylib\";", BaseName)
	implw.Writeln("            #elif __linux__")
	implw.Writeln("            std::string sLibraryName = \"%s.so\";", BaseName)
	implw.Writeln("            #endif")
	implw.Writeln("            if (args[0]->IsString()) {")
	implw.Writeln("                v8::String::Utf8Value stringParam(isolate, args[0]);")
	implw.Writeln("                sLibraryName = *stringParam;")
	implw.Writeln("            }")

	implw.Writeln("            // Invoked as constructor: `new %sWrapper(...)`", NameSpace)
	implw.Writeln("            C%sWrapper* obj = new C%sWrapper();", NameSpace, NameSpace)

	implw.Writeln("            Local<Object> newObject = args.This();")
	implw.Writeln("            std::auto_ptr<s%sDynamicWrapperTable> wrapperTable( new s%sDynamicWrapperTable );", NameSpace, NameSpace)
	implw.Writeln("            CheckError(isolate, nullptr, nullptr, Load%sWrapperTable(wrapperTable.get(), sLibraryName.c_str()));", NameSpace)
	implw.Writeln("            newObject->SetInternalField(NODEWRAPPER_TABLEINDEX, External::New(isolate, wrapperTable.release()));")

	// write out enums
	for i := 0; i < len(component.Enums); i++ {
		enum := component.Enums[i]
		for j := 0; j < len(enum.Options); j++ {
			option := enum.Options[j]
			implw.Writeln("            newObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, \"e%s_%s\"), Integer::New(isolate, %d));", enum.Name, option.Name, option.Value)
		}
	}

	implw.Writeln("            obj->Wrap(newObject);")
	implw.Writeln("            args.GetReturnValue().Set(newObject);")
	implw.Writeln("        } else {")
	implw.Writeln("            // Invoked as plain function `%sWrapper(...)`, turn into construct call.", NameSpace)
	implw.Writeln("            const int argc = 1;")
	implw.Writeln("            Local<Value> argv[argc] = { args[0] };")
	implw.Writeln("            Local<Function> cons = Local<Function>::New(isolate, constructor);")
	implw.Writeln("            args.GetReturnValue().Set(cons->NewInstance(isolate->GetCurrentContext(), argc, argv).ToLocalChecked());")
	implw.Writeln("        }")
	implw.Writeln("    } catch (std::exception & E) {")
	implw.Writeln("        RaiseError(isolate, E.what());")
	implw.Writeln("    }")
	implw.Writeln("}")
	implw.Writeln("")
	implw.Writeln("Local<Object> C%sWrapper::NewInstance(const FunctionCallbackInfo<Value>& args)", NameSpace)
	implw.Writeln("{")
	implw.Writeln("    Isolate* isolate = Isolate::GetCurrent();")
	implw.Writeln("    HandleScope scope(isolate);")
	implw.Writeln("    Local<Function> cons = Local<Function>::New(isolate, constructor);")
	implw.Writeln("    Local<Object> instance;")
	implw.Writeln("    const int argc = 1;")
	implw.Writeln("    Local<Value> argv[argc] = { args[0] };")
	implw.Writeln("    cons->NewInstance(isolate->GetCurrentContext(), argc, argv).ToLocal(&instance);")
	implw.Writeln("    return instance;")
	implw.Writeln("}")

	implw.Writeln("")

	global = component.Global
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]

		err := writeNodeMethodImplementation(method, implw, NameSpace, "Wrapper", true)
		if err != nil {
			return err
		}
	}

	implw.Writeln("")

	return nil
}

func buildNodeBindingGyp(component ComponentDefinition, w LanguageWriter) error {

	BaseName := component.BaseName

	w.Writeln("{")
	w.Writeln("  \"targets\": [")
	w.Writeln("    {")
	w.Writeln("      \"target_name\": \"%s_nodeaddon\",", BaseName)
	w.Writeln("      \"sources\": [ \"%s_nodeaddon.cc\", \"%s_nodewrapper.cc\", \"%s_dynamic.cc\" ],", BaseName, BaseName, BaseName)
	w.Writeln("      \"cflags\": [ \"-fexceptions \" ],")
	w.Writeln("      \"cflags_cc\": [ \"-fexceptions \" ],")
	w.Writeln("      \"msvs_settings\": {")
	w.Writeln("        \"VCCLCompilerTool\": { \"ExceptionHandling\": 1 }")
	w.Writeln("      },")
	w.Writeln("      \"conditions\": [")
	w.Writeln("        [\"OS=='win'\", {	\"defines\": [ \"_HAS_EXCEPTIONS=1\" ] }]")
	w.Writeln("      ]")

	w.Writeln("    }")
	w.Writeln("  ]")
	w.Writeln("}")
	w.Writeln("")

	return nil

}
