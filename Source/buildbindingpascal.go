/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildbindingpascal.go
// functions to generate dynamic Pascal-bindings of a library's API in form of dynamically loaded functions
// handles.
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"fmt"
	"log"
	"path"
	"strings"
)

// BuildBindingPascalDynamic builds dynamic Pascal bindings of a library's API in form of dynamically loaded functions
// handles.
func BuildBindingPascalDynamic(componentdefinition ComponentDefinition, outputFolder string, outputFolderExample string, indentString string) error {
	forceRecreation := false

	namespace := componentdefinition.NameSpace;
	libraryname := componentdefinition.LibraryName;
	baseName := componentdefinition.BaseName;
	
	DynamicPascalImpl := path.Join(outputFolder, "Unit_" + namespace+".pas");
	log.Printf("Creating \"%s\"", DynamicPascalImpl)
	dynpascalfile, err := CreateLanguageFile (DynamicPascalImpl, indentString)
	if err != nil {
		return err;
	}

	dynpascalfile.Writeln("{$IFDEF FPC}{$MODE DELPHI}{$ENDIF}")
	dynpascalfile.WritePascalLicenseHeader(componentdefinition,
		fmt.Sprintf("This is an autogenerated Pascal Header file in order to allow an easy\n use of %s", libraryname),
		true)
	
	err = buildDynamicPascalImplementation(componentdefinition, dynpascalfile, namespace, baseName)
	if err != nil {
		return err;
	}
	
	if len(outputFolderExample) > 0 {
		DynamicPascalExample := path.Join(outputFolderExample, namespace+"_Example.lpr");
		if (forceRecreation || !FileExists(DynamicPascalExample)) {
			log.Printf("Creating \"%s\"", DynamicPascalExample)
			dynpascalexamplefile, err := CreateLanguageFile (DynamicPascalExample, indentString)
			dynpascalexamplefile.WritePascalLicenseHeader(componentdefinition,
				fmt.Sprintf("This is an autogenerated Pascal application that demonstrates the\n usage of the Pascal bindings of %s", libraryname),
				true)
			err = buildDynamicPascalExample(dynpascalexamplefile, componentdefinition.Global, namespace, baseName, outputFolder)
			if err != nil {
				return err;
			}
		} else {
			log.Printf("Omitting recreation of Pascal example \"%s\"", DynamicPascalExample)
		}

		DynamicPascalExampleLPI := path.Join(outputFolderExample, namespace+"_Example.lpi");
		if (forceRecreation || !FileExists(DynamicPascalExampleLPI)) {
			log.Printf("Creating \"%s\"", DynamicPascalExampleLPI)
			dynpascalexampleLPIfile, err := CreateLanguageFile (DynamicPascalExampleLPI, indentString)
			err = buildDynamicPascalExampleLPI(dynpascalexampleLPIfile, namespace, baseName, outputFolder)
			if err != nil {
				return err;
			}
		} else {
			log.Printf("Omitting recreation of Pascal example \"%s\"", DynamicPascalExampleLPI)
		}
	}



	return nil;
}


func writeEnumConversionInterface(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string) error {

	if (len(componentdefinition.Enums) > 0) {
		w.Writeln ("(*************************************************************************************************************************");
		w.Writeln (" Enum conversion");
		w.Writeln ("**************************************************************************************************************************)");
		w.Writeln ("");

		for i := 0; i < len(componentdefinition.Enums); i++ {
			enum := componentdefinition.Enums[i];
			w.Writeln ("  function convert%sToConst (const AValue: T%s%s): Integer;", enum.Name, NameSpace, enum.Name);
			w.Writeln ("  function convertConstTo%s (const AValue: Integer): T%s%s;", enum.Name, NameSpace, enum.Name);
		}
		
		w.Writeln ("");
	}

	return nil;
}


func writeEnumConversionImplementation(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string) error {


	if (len(componentdefinition.Enums) > 0) {
		w.Writeln ("(*************************************************************************************************************************");
		w.Writeln (" Enum conversion");
		w.Writeln ("**************************************************************************************************************************)");
		w.Writeln ("");

		for i := 0; i < len(componentdefinition.Enums); i++ {
			enum := componentdefinition.Enums[i];
			w.Writeln ("  function convert%sToConst (const AValue: T%s%s): Integer;", enum.Name, NameSpace, enum.Name);
			w.Writeln ("  begin");
			w.Writeln ("    case AValue of");
			
			for j := 0; j < len(enum.Options); j++ {						
				option := enum.Options[j];
				w.Writeln ("      e%s%s: Result := %d;", enum.Name, option.Name, option.Value);
			}
			
			w.Writeln ("      else ");
			w.Writeln ("        raise E%sException.CreateCustomMessage (%s_ERROR_INVALIDPARAM, 'invalid enum value');", NameSpace, strings.ToUpper (NameSpace));
			w.Writeln ("    end;");
			w.Writeln ("  end;");
			w.Writeln ("  ");
			w.Writeln ("  function convertConstTo%s (const AValue: Integer): T%s%s;", enum.Name, NameSpace, enum.Name);
			w.Writeln ("  begin");
			w.Writeln ("    case AValue of");
			
			for j := 0; j < len(enum.Options); j++ {						
				option := enum.Options[j];
				w.Writeln ("      %d: Result := e%s%s;", option.Value, enum.Name, option.Name);
			}
			
			w.Writeln ("      else ");
			w.Writeln ("        raise E%sException.CreateCustomMessage (%s_ERROR_INVALIDPARAM, 'invalid enum constant');", NameSpace, strings.ToUpper (NameSpace));
			w.Writeln ("    end;");
			w.Writeln ("  end;");
			w.Writeln ("  ");
			w.Writeln ("  ");
		}
		
		w.Writeln ("");
	}

	return nil;
}


func buildDynamicPascalImplementation(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln ("unit Unit_%s;", NameSpace)
	w.Writeln ("")
	w.Writeln ("interface")
	w.Writeln ("")
	w.Writeln ("uses")
	w.Writeln ("  {$IFDEF WINDOWS}")
	w.Writeln ("    Windows,")
	w.Writeln ("  {$ELSE}")
	w.Writeln ("    dynlibs,")
	w.Writeln ("  {$ENDIF}")
	w.Writeln ("  Types,")
	w.Writeln ("  Classes,")
	w.Writeln ("  SysUtils;")
	w.Writeln ("")
	
	
	err := writePascalBaseTypeDefinitions (componentdefinition, w, NameSpace, BaseName);
	if (err != nil) {
		return err;
	}
	
	w.Writeln ("(*************************************************************************************************************************");
	w.Writeln (" Declaration of handle classes ");
	w.Writeln ("**************************************************************************************************************************)");
	w.Writeln ("");
	w.Writeln ("type");	
	w.Writeln ("  T%sBaseClass = class;", NameSpace);	
	w.Writeln ("  T%sWrapper = class;", NameSpace);	
	
	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i];				
		w.Writeln ("  T%s%s = class;", NameSpace, class.ClassName);	
	}
	w.Writeln ("");
	
	
	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		w.Writeln ("")
		w.Writeln ("(*************************************************************************************************************************")
		w.Writeln (" Function type definitions for %s", class.ClassName)
		w.Writeln ("**************************************************************************************************************************)")
		w.Writeln ("");

		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			err := writePascalFunctionType(method, w, NameSpace, class.ClassName, false, "  ")
			if err != nil {
				return err;
			}
		}

	}

	w.Writeln ("(*************************************************************************************************************************")
	w.Writeln (" Global function definitions ");
	w.Writeln ("**************************************************************************************************************************)")
	w.Writeln ("");
	
	global := componentdefinition.Global;
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
				
		err := writePascalFunctionType(method, w, NameSpace, "Wrapper", true, "  ")
		if err != nil {
			return err;
		}
	}
	

	w.Writeln ("(*************************************************************************************************************************");
	w.Writeln (" Exception definition");
	w.Writeln ("**************************************************************************************************************************)");
	w.Writeln ("")
	w.Writeln ("  E%sException = class (Exception)", NameSpace);	
	w.Writeln ("  private");	
	w.Writeln ("    FErrorCode: T%sResult;", NameSpace);	
	w.Writeln ("    FCustomMessage: String;");	
	w.Writeln ("  public");	
	w.Writeln ("    property ErrorCode: T%sResult read FErrorCode;", NameSpace);	
	w.Writeln ("    property CustomMessage: String read FCustomMessage;");	
	w.Writeln ("    constructor Create (AErrorCode: T%sResult; AMessage: String);", NameSpace);	
	w.Writeln ("    constructor CreateCustomMessage (AErrorCode: T%sResult; AMessage: String);", NameSpace);	
	w.Writeln ("  end;");	
	w.Writeln ("")
	
	
	w.Writeln ("(*************************************************************************************************************************");
	w.Writeln (" Base class definition");
	w.Writeln ("**************************************************************************************************************************)");
	w.Writeln ("")
	w.Writeln ("  T%sBaseClass = class (TObject)", NameSpace);	
	w.Writeln ("  private");	
	w.Writeln ("    FWrapper: T%sWrapper;", NameSpace);	
	w.Writeln ("    FHandle: T%sHandle;", NameSpace);	
	w.Writeln ("  public");	
	w.Writeln ("    constructor Create (AWrapper: T%sWrapper; AHandle: T%sHandle);", NameSpace, NameSpace);	
	w.Writeln ("    destructor Destroy; override;");	
	w.Writeln ("  end;");	
	w.Writeln ("")

	
	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		w.Writeln ("")
		w.Writeln ("(*************************************************************************************************************************")
		w.Writeln (" Class definition for %s", class.ClassName)
		w.Writeln ("**************************************************************************************************************************)")
		w.Writeln ("");
		
		parentClassName := class.ParentClass
		if parentClassName == "" {
			parentClassName = "BaseClass"
		}
		

		w.Writeln ("  T%s%s = class (T%s%s)", NameSpace, class.ClassName, NameSpace, parentClassName);	
		w.Writeln ("  private");	
		w.Writeln ("  public");	
		w.Writeln ("    constructor Create (AWrapper: T%sWrapper; AHandle: T%sHandle);", NameSpace, NameSpace);	
		w.Writeln ("    destructor Destroy; override;");	
		
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			err := writePascalClassMethodDefinition(method, w, NameSpace, class.ClassName, false, "    ", false)
			if err != nil {
				return err;
			}
		}
		
		w.Writeln ("  end;");	
		w.Writeln ("")
	}
	

	w.Writeln ("(*************************************************************************************************************************");
	w.Writeln (" Wrapper definition");
	w.Writeln ("**************************************************************************************************************************)");
	w.Writeln ("")
	w.Writeln ("  T%sWrapper = class (TObject)", NameSpace);	
	w.Writeln ("  private");	
	w.Writeln ("    FModule: HMODULE;");	
	
	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			
			w.Writeln ("    F%s%s_%sFunc: T%s%s_%sFunc;", NameSpace, class.ClassName, method.MethodName, NameSpace, class.ClassName, method.MethodName);
		}
	}

	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		
		w.Writeln ("    F%s%sFunc: T%s%sFunc;", NameSpace, method.MethodName, NameSpace, method.MethodName);
	}

	w.Writeln ("")
	w.Writeln ("    {$IFDEF MSWINDOWS}");
	w.Writeln ("    function LoadFunction (AFunctionName: AnsiString; FailIfNotExistent: Boolean = True): FARPROC;");	
	w.Writeln ("    {$ELSE}");
	w.Writeln ("    function LoadFunction (AFunctionName: AnsiString; FailIfNotExistent: Boolean = True): Pointer;");	
	w.Writeln ("    {$ENDIF MSWINDOWS}");
	w.Writeln ("")
	w.Writeln ("    procedure checkBinaryVersion();")
	w.Writeln ("")

	w.Writeln ("  protected");

	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			
			w.Writeln ("    property %s%s_%sFunc: T%s%s_%sFunc read F%s%s_%sFunc;", NameSpace, class.ClassName, method.MethodName, NameSpace, class.ClassName, method.MethodName, NameSpace, class.ClassName, method.MethodName);
		}

	}

	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
				
		w.Writeln ("    property %s%sFunc: T%s%sFunc read F%s%sFunc;", NameSpace, method.MethodName, NameSpace, method.MethodName, NameSpace, method.MethodName);
				
	}

	w.Writeln ("    procedure CheckError (AInstance: T%sBaseClass; AErrorCode: T%sResult);", NameSpace, NameSpace);	

	w.Writeln ("  public");	

	w.Writeln ("    constructor Create (ADLLName: String);");	
	w.Writeln ("    destructor Destroy; override;");	


	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
						
		err := writePascalClassMethodDefinition(method, w, NameSpace, "Wrapper", true, "    ", false)
		if err != nil {
			return err;
		}
	}


	w.Writeln ("  end;");	
	w.Writeln ("")

	
	writeEnumConversionInterface (componentdefinition, w, NameSpace);
	
	
	w.Writeln ("")
	w.Writeln ("implementation")
	w.Writeln ("")

	writeEnumConversionImplementation (componentdefinition, w, NameSpace);
		
	w.Writeln ("")
	w.Writeln ("(*************************************************************************************************************************");
	w.Writeln (" Exception implementation");
	w.Writeln ("**************************************************************************************************************************)");
	w.Writeln ("")
	w.Writeln ("  constructor E%sException.Create (AErrorCode: T%sResult; AMessage: String);", NameSpace, NameSpace);	
	w.Writeln ("  var");	
	w.Writeln ("    ADescription: String;");	
	w.Writeln ("  begin");	
	w.Writeln ("    FErrorCode := AErrorCode;");	
	w.Writeln ("    case FErrorCode of");	
	
	for _, error := range componentdefinition.Errors.Errors {
		w.Writeln ("      %s_ERROR_%s: ADescription := '%s';", strings.ToUpper (NameSpace), error.Name, error.Description);		
	}
	
	w.Writeln ("      else");		
	w.Writeln ("        ADescription := 'unknown';");	
	w.Writeln ("    end;");	
	
	
	w.Writeln ("")
	w.Writeln ("    inherited Create (Format ('%s Error - %%s (#%%d, %%s)', [ ADescription, AErrorCode, AMessage ]));", componentdefinition.LibraryName);	
	w.Writeln ("  end;");	
	w.Writeln ("")
	w.Writeln ("  constructor E%sException.CreateCustomMessage (AErrorCode: T%sResult; AMessage: String);", NameSpace, NameSpace);	
	w.Writeln ("  begin");	
	w.Writeln ("    FCustomMessage := AMessage;");	
	w.Writeln ("    FErrorCode := AErrorCode;");	
	w.Writeln ("    inherited Create (Format ('%%s (%%d)', [FCustomMessage, AErrorCode]));");	
	w.Writeln ("  end;");	
	w.Writeln ("")
	
	w.Writeln ("(*************************************************************************************************************************");
	w.Writeln (" Base class implementation");
	w.Writeln ("**************************************************************************************************************************)");
	w.Writeln ("")
	w.Writeln ("  constructor T%sBaseClass.Create (AWrapper: T%sWrapper; AHandle: T%sHandle);", NameSpace, NameSpace, NameSpace);	
	w.Writeln ("  begin");	
	w.Writeln ("    if not Assigned (AWrapper) then");	
	w.Writeln ("      raise E%sException.Create (%s_ERROR_INVALIDPARAM, '');", NameSpace, strings.ToUpper (NameSpace));	
	w.Writeln ("    if not Assigned (AHandle) then");	
	w.Writeln ("      raise E%sException.Create (%s_ERROR_INVALIDPARAM, '');", NameSpace, strings.ToUpper (NameSpace));	
	w.Writeln ("")
	w.Writeln ("    inherited Create ();");
	w.Writeln ("    FWrapper := AWrapper;");
	w.Writeln ("    FHandle := AHandle;");
	w.Writeln ("  end;");
	w.Writeln ("")
	w.Writeln ("  destructor T%sBaseClass.Destroy;", NameSpace);
	w.Writeln ("  begin");
	w.Writeln ("    FWrapper.%s(self);", componentdefinition.Global.ReleaseMethod);
	w.Writeln ("    inherited;");
	w.Writeln ("  end;");
	w.Writeln ("")

	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		w.Writeln ("(*************************************************************************************************************************")
		w.Writeln (" Class implementation for %s", class.ClassName)
		w.Writeln ("**************************************************************************************************************************)")
		w.Writeln ("");
				
		w.Writeln ("  constructor T%s%s.Create (AWrapper: T%sWrapper; AHandle: T%sHandle);", NameSpace, class.ClassName, NameSpace, NameSpace);	
		w.Writeln ("  begin");	
		w.Writeln ("    inherited Create (AWrapper, AHandle);");	
		w.Writeln ("  end;");	
		w.Writeln ("")
		w.Writeln ("  destructor T%s%s.Destroy;", NameSpace, class.ClassName);	
		w.Writeln ("  begin");	
		w.Writeln ("    inherited;");	
		w.Writeln ("  end;");	
				
		w.Writeln ("")

		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
						
			err := writePascalClassMethodImplementation(method, w, NameSpace, class.ClassName, false, "  ")
			if err != nil {
				return err;
			}
		}
		
	}
	

	w.Writeln ("(*************************************************************************************************************************");
	w.Writeln (" Wrapper class implementation");
	w.Writeln ("**************************************************************************************************************************)");
	w.Writeln ("")
	w.Writeln ("  constructor T%sWrapper.Create (ADLLName: String);", NameSpace);	
	w.Writeln ("  {$IFDEF MSWINDOWS}");	
	w.Writeln ("  var");	
	w.Writeln ("    AWideString: WideString;");	
	w.Writeln ("  {$ENDIF MSWINDOWS}");	
	w.Writeln ("  begin");	
	w.Writeln ("    inherited Create;");	
	w.Writeln ("    {$IFDEF MSWINDOWS}");	
	w.Writeln ("      AWideString := UTF8Decode(ADLLName + #0);");	
	w.Writeln ("      FModule := LoadLibraryW (PWideChar (AWideString));");	
	w.Writeln ("    {$ELSE}");	
	w.Writeln ("      FModule := dynlibs.LoadLibrary (ADLLName);");	
	w.Writeln ("    {$ENDIF MSWINDOWS}");	
	w.Writeln ("    if FModule = 0 then");	
	w.Writeln ("      raise E%sException.Create (%s_ERROR_COULDNOTLOADLIBRARY, '');", NameSpace, strings.ToUpper (NameSpace));	
	w.Writeln ("")

	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			
			w.Writeln ("    F%s%s_%sFunc := LoadFunction ('%s');", NameSpace, class.ClassName, method.MethodName, GetCExportName (NameSpace, class.ClassName, method, false));
		}

	}

	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		
		w.Writeln ("    F%s%sFunc := LoadFunction ('%s');", NameSpace, method.MethodName, GetCExportName (NameSpace, "Wrapper", method, true));
	}
	w.Writeln ("    ")
	w.Writeln ("    checkBinaryVersion();");
	w.Writeln ("  end;");
	w.Writeln ("")
	w.Writeln ("  destructor T%sWrapper.Destroy;", NameSpace);
	w.Writeln ("  begin");
	w.Writeln ("    {$IFDEF MSWINDOWS}");
	w.Writeln ("      if FModule <> 0 then");
	w.Writeln ("        FreeLibrary (FModule);");	
	w.Writeln ("    {$ELSE}");	
	w.Writeln ("      if FModule <> 0 then");	
	w.Writeln ("        UnloadLibrary (FModule);");	
	w.Writeln ("    {$ENDIF MSWINDOWS}");	
	w.Writeln ("    inherited;");	
	w.Writeln ("  end;");	
	w.Writeln ("")
	w.Writeln ("  procedure T%sWrapper.CheckError (AInstance: T%sBaseClass; AErrorCode: T%sResult);", NameSpace, NameSpace, NameSpace);	
	w.Writeln ("  var")
	w.Writeln ("    AErrorMessage: String;")
	w.Writeln ("  begin")
    w.Writeln ("    if AInstance <> nil then begin");
    w.Writeln ("      if AInstance.FWrapper <> Self then");
    w.Writeln ("        raise E%sException.CreateCustomMessage (%s_ERROR_INVALIDCAST, 'invalid wrapper call');", NameSpace, strings.ToUpper (NameSpace));
    w.Writeln ("    end;");
	
	w.Writeln ("    if AErrorCode <> %s_SUCCESS then begin", strings.ToUpper (NameSpace));
	w.Writeln ("      AErrorMessage := '';");
	if (len (componentdefinition.Global.ErrorMethod) > 0) {
		w.Writeln ("      if Assigned (AInstance) then");
		w.Writeln ("        %s (AInstance, AErrorMessage);", componentdefinition.Global.ErrorMethod);
	}
	w.Writeln ("      raise E%sException.Create (AErrorCode, AErrorMessage);", NameSpace);
	w.Writeln ("    end;")
	w.Writeln ("  end;")
	w.Writeln ("")
	
	w.Writeln ("  {$IFDEF MSWINDOWS}");	
	w.Writeln ("  function T%sWrapper.LoadFunction (AFunctionName: AnsiString; FailIfNotExistent: Boolean): FARPROC;", NameSpace);	
	w.Writeln ("  begin");	
	w.Writeln ("    Result := GetProcAddress (FModule, PAnsiChar (AFunctionName));");	
	w.Writeln ("    if FailIfNotExistent and not Assigned (Result) then");	
	w.Writeln ("      raise E%sException.CreateCustomMessage (%s_ERROR_COULDNOTFINDLIBRARYEXPORT, 'could not find function ' + AFunctionName);", NameSpace, strings.ToUpper (NameSpace));	
	w.Writeln ("  end;");	
	w.Writeln ("  {$ELSE}");
	w.Writeln ("  function T%sWrapper.LoadFunction (AFunctionName: AnsiString; FailIfNotExistent: Boolean): Pointer;", NameSpace);	
	w.Writeln ("  begin");
	w.Writeln ("    Result := dynlibs.GetProcAddress (FModule, AFunctionName);");	
	w.Writeln ("    if FailIfNotExistent and not Assigned (Result) then");	
	w.Writeln ("      raise E%sException.CreateCustomMessage (%s_ERROR_COULDNOTFINDLIBRARYEXPORT, 'could not find function ' + AFunctionName);", NameSpace, strings.ToUpper (NameSpace));	
	w.Writeln ("  end;");
	w.Writeln ("  {$ENDIF MSWINDOWS}");
	w.Writeln ("")


	w.Writeln ("  procedure T%sWrapper.checkBinaryVersion();", NameSpace)
	w.Writeln ("  var")
	w.Writeln ("    AMajor, AMinor, AMicro: Cardinal;")
	w.Writeln ("  begin")
	w.Writeln ("    %s(AMajor, AMinor, AMicro);", global.VersionMethod)
	w.Writeln ("    if (AMajor <> %s_VERSION_MAJOR) or (AMinor < %s_VERSION_MINOR) then", strings.ToUpper(NameSpace), strings.ToUpper(NameSpace))
	w.Writeln ("      raise E%sException.Create(%s_ERROR_INCOMPATIBLEBINARYVERSION, '');", NameSpace, strings.ToUpper(NameSpace))
	w.Writeln ("  end;")
	w.Writeln ("  ")

	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
						
		err := writePascalClassMethodImplementation(method, w, NameSpace, "Wrapper", true, "  " )
		if err != nil {
			return err;
		}
	}
	
	w.Writeln ("")
	w.Writeln ("end.")

	return nil
}

func getPascalClassParameters(method ComponentDefinitionMethod, NameSpace string, ClassName string, isGlobal bool, isImplementation bool) (string, string, error) {
	parameters := "";
	returnType := "";
	
	for k := 0; k < len(method.Params); k++ {
		param := method.Params [k];
		ParamTypeName, err := getPascalParameterType(param.ParamType, NameSpace, param.ParamClass, false, isImplementation);
		if err != nil {
			return "", "", err;
		}
		
		switch (param.ParamPass) {
			case "in":
				if (parameters != "") {
					parameters = parameters + "; ";
				}			
				parameters = parameters + "const A" + param.ParamName + ": " + ParamTypeName;
				
			case "out":
				if (parameters != "") {
					parameters = parameters + "; ";
				}			
				parameters = parameters + "out A" + param.ParamName + ": " + ParamTypeName;

			case "return":
				if (returnType != "") {
					return "", "", fmt.Errorf ("duplicate return value \"%s\" for Pascal method \"%s\"", param.ParamName, method.MethodName);
				}
				returnType = ParamTypeName;
		}
	}

	return parameters, returnType, nil;
}



func writePascalClassMethodDefinition (method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, isGlobal bool, spacing string, isImplementation bool) (error) {

	parameters, returnType, err := getPascalClassParameters (method, NameSpace, ClassName, isGlobal, isImplementation);
	if (err != nil) {
		return err;
	}
	
	classPrefix := "";
	if (isImplementation && isGlobal) {
		classPrefix = "class ";
	}

	if (returnType == "") {
		w.Writeln ( spacing + "%sprocedure %s(%s);", classPrefix, method.MethodName, parameters);
	} else {
		w.Writeln ( spacing + "%sfunction %s(%s): %s;", classPrefix, method.MethodName, parameters, returnType);
	}
	
	return nil;
}


func writePascalClassMethodImplementation (method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, isGlobal bool, spacing string) (error) {

	parameters, returnType, err := getPascalClassParameters (method, NameSpace, ClassName, isGlobal, false);
	if (err != nil) {
		return err;
	}
	
	
	defineCommands := make([]string, 0);
	initCommands := make([]string, 0);
	resultCommands := make([]string, 0);
	postInitCommands := make([]string, 0);
	wrapperCallPrefix := "";
	wrapperInstanceName := "";
	
	doInitCall := false;
	
	
	callFunctionName := "";	
	callFunctionParameters := "";
	initCallParameters := "";
	errorInstanceHandle := "";
	
	if isGlobal {
		callFunctionName = fmt.Sprintf ("%s%sFunc", NameSpace, method.MethodName);
		errorInstanceHandle = "nil";
		wrapperInstanceName = "Self";
	} else {
		callFunctionName = fmt.Sprintf ("%s%s_%sFunc", NameSpace, ClassName, method.MethodName);		
		callFunctionParameters = "FHandle";
		errorInstanceHandle = "Self";
		wrapperCallPrefix = "FWrapper.";
		wrapperInstanceName = "FWrapper";
	}
	
	initCallParameters = callFunctionParameters;
	
	
	for k := 0; k < len(method.Params); k++ {
		param := method.Params [k];
		PlainParamTypeName, err := getPascalParameterType(param.ParamType, NameSpace, param.ParamClass, true, false);
		if err != nil {
			return err;
		}
		
		if (callFunctionParameters != "") {
			callFunctionParameters = callFunctionParameters + ", ";
		}			

		if (initCallParameters != "") {
			initCallParameters = initCallParameters + ", ";
		}			
		
		switch (param.ParamPass) {
			case "in":

				switch (param.ParamType) {
					case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double":
						callFunctionParameters = callFunctionParameters + "A" + param.ParamName;
						initCallParameters = initCallParameters + "A" + param.ParamName;

					case "string":
						callFunctionParameters = callFunctionParameters + "PAnsiChar (A" + param.ParamName + ")";
						initCallParameters = initCallParameters + "PAnsiChar (A" + param.ParamName + ")";
						
					case "enum":
						callFunctionParameters = callFunctionParameters + "convert" + param.ParamClass + "ToConst (A" + param.ParamName + ")";
						initCallParameters = initCallParameters + "convert" + param.ParamClass + "ToConst (A" + param.ParamName + ")";

					case "bool":
						callFunctionParameters = callFunctionParameters + "Ord (A" + param.ParamName + ")";
						initCallParameters = initCallParameters + "Ord (A" + param.ParamName + ")";
						
					case "struct":
						callFunctionParameters = callFunctionParameters + "@A" + param.ParamName;
						initCallParameters = initCallParameters + "@A" + param.ParamName;

					case "basicarray":
						basicPlainTypeName, err := getPascalParameterType(param.ParamClass, NameSpace, "", true, false);
						if err != nil {
							return err;
						}

						defineCommands = append (defineCommands, "  Ptr" + param.ParamName + ": P" + basicPlainTypeName + ";");
						defineCommands = append (defineCommands, "  Len" + param.ParamName + ": QWord;");
						initCommands = append (initCommands, fmt.Sprintf ("  Len%s := Length (A%s);", param.ParamName, param.ParamName));
						initCommands = append (initCommands, fmt.Sprintf ("  if Len%s > $FFFFFFFF then", param.ParamName));
						initCommands = append (initCommands, fmt.Sprintf ("    raise E%sException.CreateCustomMessage (%s_ERROR_INVALIDPARAM, 'array has too many entries.');", NameSpace, strings.ToUpper (NameSpace)));
						initCommands = append (initCommands, fmt.Sprintf ("  if Len%s > 0 then", param.ParamName));
						initCommands = append (initCommands, fmt.Sprintf ("    Ptr%s := @A%s[0]", param.ParamName, param.ParamName));
						initCommands = append (initCommands, fmt.Sprintf ("  else"));
						initCommands = append (initCommands, fmt.Sprintf ("    Ptr%s := nil;", param.ParamName));
						initCommands = append (initCommands, "");
						
						callFunctionParameters = callFunctionParameters + "QWord (Len" + param.ParamName + "), Ptr" + param.ParamName;						
						initCallParameters = initCallParameters + "QWord (Len" + param.ParamName + "), Ptr" + param.ParamName;						

					case "structarray":

						defineCommands = append (defineCommands, "  Ptr" + param.ParamName + ": P" + NameSpace + param.ParamClass + ";");
						defineCommands = append (defineCommands, "  Len" + param.ParamName + ": QWord;");
						initCommands = append (initCommands, fmt.Sprintf ("  Len%s := Length (A%s);", param.ParamName, param.ParamName));
						initCommands = append (initCommands, fmt.Sprintf ("  if Len%s > $FFFFFFFF then", param.ParamName));
						initCommands = append (initCommands, fmt.Sprintf ("    raise E%sException.CreateCustomMessage (%s_ERROR_INVALIDPARAM, 'array has too many entries.');", NameSpace, strings.ToUpper (NameSpace)));
						initCommands = append (initCommands, fmt.Sprintf ("  if Len%s > 0 then", param.ParamName));
						initCommands = append (initCommands, fmt.Sprintf ("    Ptr%s := @A%s[0]", param.ParamName, param.ParamName));
						initCommands = append (initCommands, fmt.Sprintf ("  else"));
						initCommands = append (initCommands, fmt.Sprintf ("    Ptr%s := nil;", param.ParamName));
						initCommands = append (initCommands, "");
						
						callFunctionParameters = callFunctionParameters + "QWord (Len" + param.ParamName + "), Ptr" + param.ParamName;						
						initCallParameters = initCallParameters + "QWord (Len" + param.ParamName + "), Ptr" + param.ParamName;						

					case "functiontype":
						initCommands = append (initCommands, fmt.Sprintf ("  if not Assigned (A%s) then", param.ParamName));
						initCommands = append (initCommands, fmt.Sprintf ("    raise E%sException.CreateCustomMessage (%s_ERROR_INVALIDPARAM, 'A%s is a nil value.');", NameSpace, strings.ToUpper (NameSpace), param.ParamName));
						callFunctionParameters = callFunctionParameters + "A" + param.ParamName;
						initCallParameters = initCallParameters + "A" + param.ParamName;

					case "handle":
						initCommands = append (initCommands, fmt.Sprintf ("  if not Assigned (A%s) then", param.ParamName));
						initCommands = append (initCommands, fmt.Sprintf ("    raise E%sException.CreateCustomMessage (%s_ERROR_INVALIDPARAM, 'A%s is a nil value.');", NameSpace, strings.ToUpper (NameSpace), param.ParamName));
						callFunctionParameters = callFunctionParameters + "A" + param.ParamName + ".FHandle";
						initCallParameters = initCallParameters + "A" + param.ParamName + ".FHandle";

					default:
						return fmt.Errorf ("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName);
				}

			
				
			case "out":
			
				switch (param.ParamType) {
					case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double":
						callFunctionParameters = callFunctionParameters + "A" + param.ParamName;
						initCallParameters = initCallParameters + "A" + param.ParamName;

					case "string":
						defineCommands = append (defineCommands, "  bytesNeeded" + param.ParamName + ": Cardinal;");
						defineCommands = append (defineCommands, "  bytesWritten" + param.ParamName + ": Cardinal;");
						defineCommands = append (defineCommands, "  buffer" + param.ParamName + ": array of Char;");
						initCommands = append (initCommands, "  bytesNeeded" + param.ParamName + ":= 0;");
						initCommands = append (initCommands, "  bytesWritten" + param.ParamName + ":= 0;");
						
						initCallParameters = initCallParameters + fmt.Sprintf("0, bytesNeeded%s, nil", param.ParamName)
						
						postInitCommands = append (postInitCommands, fmt.Sprintf("  SetLength (buffer%s, bytesNeeded%s + 2);", param.ParamName, param.ParamName));
						
						callFunctionParameters = callFunctionParameters + fmt.Sprintf("bytesNeeded%s + 1, bytesWritten%s, @buffer%s[0]", param.ParamName, param.ParamName, param.ParamName)

						resultCommands = append (resultCommands, fmt.Sprintf ("  buffer%s[bytesNeeded%s + 1] := #0;", param.ParamName, param.ParamName));
						resultCommands = append (resultCommands, fmt.Sprintf ("  A%s := StrPas (@buffer%s[0]);", param.ParamName, param.ParamName));

						doInitCall = true;
						
					case "enum":
						defineCommands = append (defineCommands, "  Result" + param.ParamName + ": Integer;");
						initCommands = append (initCommands, "  Result" + param.ParamName + " := 0;");
			
						callFunctionParameters = callFunctionParameters + "Result" + param.ParamName;
						initCallParameters = initCallParameters + "Result" + param.ParamName;
						resultCommands = append (resultCommands, fmt.Sprintf ("  A%s := convertConstTo%s (Result%s);", param.ParamName, param.ParamClass, param.ParamName));

					case "bool":
						defineCommands = append (defineCommands, "  Result" + param.ParamName + ": Cardinal;");
						initCommands = append (initCommands, "  Result" + param.ParamName + " := 0;");
			
						callFunctionParameters = callFunctionParameters + "PByte (@Result" + param.ParamName + ")^";
						initCallParameters = initCallParameters + "PByte (@Result" + param.ParamName + ")^";
						resultCommands = append (resultCommands, fmt.Sprintf ("  A%s := Result%s <> 0;", param.ParamName, param.ParamName));
						
					case "struct":
						callFunctionParameters = callFunctionParameters + "@A" + param.ParamName;
						initCallParameters = initCallParameters + "@A" + param.ParamName;
						
					case "basicarray", "structarray":
						
						defineCommands = append (defineCommands, "  countNeeded" + param.ParamName + ": QWord;");
						defineCommands = append (defineCommands, "  countWritten" + param.ParamName + ": QWord;");
						initCommands = append (initCommands, "  countNeeded" + param.ParamName + ":= 0;");
						initCommands = append (initCommands, "  countWritten" + param.ParamName + ":= 0;");
						
						initCallParameters = initCallParameters + fmt.Sprintf("0, countNeeded%s, nil", param.ParamName)
						
						postInitCommands = append (postInitCommands, fmt.Sprintf("  SetLength (A%s, countNeeded%s);", param.ParamName, param.ParamName));
						
						callFunctionParameters = callFunctionParameters + fmt.Sprintf("countNeeded%s, countWritten%s, @A%s[0]", param.ParamName, param.ParamName, param.ParamName)

						doInitCall = true;
					
					case "handle":
						defineCommands = append (defineCommands, "  H" + param.ParamName + ": " + PlainParamTypeName + ";");
						initCommands = append (initCommands, "  Result := nil;");
						initCommands = append (initCommands, "  A%s := nil;", param.ParamName);
						initCommands = append (initCommands, "  H" + param.ParamName + " := nil;");
						callFunctionParameters = callFunctionParameters + "H" + param.ParamName;
						initCallParameters = initCallParameters + "nil";
						
						resultCommands = append (resultCommands, fmt.Sprintf ("  if Assigned (H%s) then", param.ParamName));
						resultCommands = append (resultCommands, fmt.Sprintf ("    A%s := T%s%s.Create (%s, H%s);", param.ParamName, NameSpace, param.ParamClass, wrapperInstanceName, param.ParamName));

					default:
						return fmt.Errorf ("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName);
				}


			case "return":

				switch (param.ParamType) {
					case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double":
						callFunctionParameters = callFunctionParameters + "Result";

					case "string":
						defineCommands = append (defineCommands, "  bytesNeeded" + param.ParamName + ": Cardinal;");
						defineCommands = append (defineCommands, "  bytesWritten" + param.ParamName + ": Cardinal;");
						defineCommands = append (defineCommands, "  buffer" + param.ParamName + ": array of Char;");
						initCommands = append (initCommands, "  bytesNeeded" + param.ParamName + ":= 0;");
						initCommands = append (initCommands, "  bytesWritten" + param.ParamName + ":= 0;");
						
						initCallParameters = initCallParameters + fmt.Sprintf("0, bytesNeeded%s, nil", param.ParamName)

						postInitCommands = append (postInitCommands, fmt.Sprintf("  SetLength (buffer%s, bytesNeeded%s + 2);", param.ParamName, param.ParamName));
						
						callFunctionParameters = callFunctionParameters + fmt.Sprintf("bytesNeeded%s + 2, bytesWritten%s, @buffer%s[0]", param.ParamName, param.ParamName, param.ParamName)

						resultCommands = append (resultCommands, fmt.Sprintf ("  buffer%s[bytesNeeded%s + 1] := #0;", param.ParamName, param.ParamName));
						resultCommands = append (resultCommands, fmt.Sprintf ("  Result := StrPas (@buffer%s[0]);", param.ParamName));

						doInitCall = true;

						
					case "enum":
						defineCommands = append (defineCommands, "  Result" + param.ParamName + ": Integer;");
						initCommands = append (initCommands, "  Result" + param.ParamName + " := 0;");
			
						callFunctionParameters = callFunctionParameters + "Result" + param.ParamName;
						initCallParameters = initCallParameters + "Result" + param.ParamName;
						resultCommands = append (resultCommands, fmt.Sprintf ("  Result := convertConstTo%s (Result%s);", param.ParamClass, param.ParamName));

					case "bool":
						defineCommands = append (defineCommands, "  Result" + param.ParamName + ": Cardinal;");
						initCommands = append (initCommands, "  Result" + param.ParamName + " := 0;");
			
						callFunctionParameters = callFunctionParameters + "PByte (@Result" + param.ParamName + ")^";
						initCallParameters = initCallParameters + "PByte (@Result" + param.ParamName + ")^";
						resultCommands = append (resultCommands, fmt.Sprintf ("  Result := (Result%s <> 0);", param.ParamName));
						
					case "struct":
						callFunctionParameters = callFunctionParameters + "@Result";

					case "basicarray", "structarray":
						defineCommands = append (defineCommands, "  countNeeded" + param.ParamName + ": QWord;");
						defineCommands = append (defineCommands, "  countWritten" + param.ParamName + ": QWord;");
						initCommands = append (initCommands, "  countNeeded" + param.ParamName + ":= 0;");
						initCommands = append (initCommands, "  countWritten" + param.ParamName + ":= 0;");
						
						initCallParameters = initCallParameters + fmt.Sprintf("0, countNeeded%s, nil", param.ParamName)
						
						postInitCommands = append (postInitCommands, fmt.Sprintf("  SetLength (Result, countNeeded%s);", param.ParamName));
						
						callFunctionParameters = callFunctionParameters + fmt.Sprintf("countNeeded%s, countWritten%s, @Result[0]", param.ParamName, param.ParamName)

						doInitCall = true;

					case "handle":
						defineCommands = append (defineCommands, "  H" + param.ParamName + ": " + PlainParamTypeName + ";");
						initCommands = append (initCommands, "  Result := nil;");
						initCommands = append (initCommands, "  H" + param.ParamName + " := nil;");
						callFunctionParameters = callFunctionParameters + "H" + param.ParamName;
						resultCommands = append (resultCommands, fmt.Sprintf ("  if Assigned (H%s) then", param.ParamName));
						resultCommands = append (resultCommands, fmt.Sprintf ("    Result := T%s%s.Create (%s, H%s);", NameSpace, param.ParamClass, wrapperInstanceName, param.ParamName));

					default:
						return fmt.Errorf ("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName);
				}
			
				
				
		}
	}
	
	

	if (returnType == "") {
		w.Writeln (spacing + "procedure T%s%s.%s(%s);", NameSpace, ClassName, method.MethodName, parameters);
	} else {
		w.Writeln (spacing + "function T%s%s.%s(%s): %s;", NameSpace, ClassName, method.MethodName, parameters, returnType);
	}
	
	if len (defineCommands) > 0 {
		w.Writeln (spacing + "var");
		w.Writelns (spacing, defineCommands);	
	}
		
	w.Writeln (spacing + "begin");
	w.Writelns (spacing, initCommands);	

	if (doInitCall) {
		w.Writeln (spacing + "  %sCheckError (%s, %s%s (%s));", wrapperCallPrefix, errorInstanceHandle, wrapperCallPrefix, callFunctionName, initCallParameters);
	}
	
	w.Writelns (spacing, postInitCommands);	
	
	w.Writeln (spacing + "  %sCheckError (%s, %s%s (%s));", wrapperCallPrefix, errorInstanceHandle, wrapperCallPrefix, callFunctionName, callFunctionParameters);
	
	w.Writelns (spacing, resultCommands);	
	
	w.Writeln (spacing + "end;");
	w.Writeln ("");
	
	return nil;
}


func writePascalFunctionType (method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, isGlobal bool, spacing string) (error) {

	PascalCallbackName := "";
	parameters := "";
	if (isGlobal) {
		PascalCallbackName = fmt.Sprintf ("T%s%sFunc", NameSpace, method.MethodName);
	} else {
		PascalCallbackName = fmt.Sprintf ("T%s%s_%sFunc", NameSpace, ClassName, method.MethodName);
		parameters = fmt.Sprintf ("p%s: T%sHandle", ClassName, NameSpace);
	}

	w.Writeln ( spacing + "(**");
	w.Writeln ( spacing + "* %s", method.MethodDescription);
	w.Writeln ( spacing + "*");
	if (!isGlobal) {
		w.Writeln ( spacing + "* @param[in] p%s - %s instance.", ClassName, ClassName);
	}
	

	for k := 0; k < len(method.Params); k++ {
		param := method.Params [k];
		
		pascalParams, err := generatePlainPascalParameter(param, ClassName, method.MethodName, NameSpace);
		if (err != nil) {
			return err;
		}

		for _, pascalParam := range pascalParams {
			w.Writeln (spacing + pascalParam.ParamComment);
			if (parameters != "") {
				parameters = parameters + "; ";
			}
			parameters = parameters + pascalParam.ParamConvention + pascalParam.ParamName + ": " + pascalParam.ParamType;
		}

	}
	
	w.Writeln (spacing + "* @return error code or 0 (success)");
	w.Writeln (spacing + "*)");
			
	w.Writeln (spacing + "%s = function (%s): T%sResult; cdecl;", PascalCallbackName, parameters, NameSpace);
	w.Writeln (spacing + "");
	
	return nil;
}





func generatePlainPascalParameters(method ComponentDefinitionMethod, className string, NameSpace string) ([]pascalParameter, error) {
	parameters := []pascalParameter{};
	for k := 0; k < len(method.Params); k++ {
		param := method.Params [k];
		
		cParam, err := generatePlainPascalParameter(param, className, method.MethodName, NameSpace);
		if err != nil {
			return nil, nil;
		}
		parameters = append(parameters, cParam...);
	}

	return parameters, nil;
}


func buildDynamicPascalExample(w LanguageWriter, global ComponentDefinitionGlobal, NameSpace string, BaseName string, outputFolder string) error {
	w.Writeln("program %sPascalTest;", NameSpace)
	w.Writeln("")
	w.Writeln("uses")
	w.Writeln("  {$IFDEF UNIX}{$IFDEF UseCThreads}")
	w.Writeln("  cthreads,")
	w.Writeln("  {$ENDIF}{$ENDIF}")
	w.Writeln("  Classes, SysUtils, CustApp,")
	w.Writeln("  Unit_%s", NameSpace)
	w.Writeln("  { you can add units after this };")
	w.Writeln("")
	w.Writeln("type")
	w.Writeln("")
	w.Writeln("T%s_Example = class(TCustomApplication)", NameSpace)
	w.Writeln("protected")
	w.Writeln("  procedure DoRun; override;")
	w.Writeln("  procedure Test%s ();", NameSpace)
	w.Writeln("public")
	w.Writeln("  constructor Create(TheOwner: TComponent); override;")
	w.Writeln("  destructor Destroy; override;")
	w.Writeln("end;")
	w.Writeln("")
	w.Writeln("")
	w.Writeln("procedure T%s_Example.Test%s ();", NameSpace, NameSpace)
	w.Writeln("var")
	w.Writeln("  A%sWrapper: T%sWrapper;", NameSpace, NameSpace)
	w.Writeln("  AMajor, AMinor, AMicro: Cardinal;")
	w.Writeln("  ALibPath: string;")
	w.Writeln("begin")
	w.Writeln("  writeln ('loading DLL');")
	w.Writeln("  ALibPath := ''; // TODO add the location of the shared library binary here")
	w.Writeln("  A%sWrapper := T%sWrapper.Create (ALibPath + '/' + '%s.dll');", NameSpace, NameSpace, BaseName)
	w.Writeln("  try")
	w.Writeln("    writeln ('loading DLL Done');")
	w.Writeln("    A%sWrapper.%s(AMajor, AMinor, AMicro);", NameSpace, global.VersionMethod)
	w.Writeln("    writeln (Format('%s.version = %s', [AMajor, AMinor, AMicro]));",NameSpace, "%d.%d.%d")
	w.Writeln("  finally")
	w.Writeln("    FreeAndNil(A%sWrapper);", NameSpace)
	w.Writeln("  end;")
	w.Writeln("end;")
	w.Writeln("")
	w.Writeln("procedure T%s_Example.DoRun;", NameSpace)
	w.Writeln("begin")
	w.Writeln("  try")
	w.Writeln("    Test%s();", NameSpace)
	w.Writeln("  except")
	w.Writeln("    On E: Exception do")
	w.Writeln("      writeln ('Fatal error: ', E.Message);")
	w.Writeln("  end;")
	w.Writeln("  Terminate")
	w.Writeln("end;")

	w.Writeln("")

	w.Writeln("constructor T%s_Example.Create(TheOwner: TComponent);", NameSpace)
	w.Writeln("begin")
	w.Writeln("  inherited Create(TheOwner);")
	w.Writeln("  StopOnException:=True;")
	w.Writeln("end;")

	w.Writeln("")

	w.Writeln("destructor T%s_Example.Destroy;", NameSpace)
	w.Writeln("begin")
	w.Writeln("  inherited Destroy;")
	w.Writeln("end;")
	w.Writeln("")

	w.Writeln("")
	w.Writeln("var")
	w.Writeln("  Application: T%s_Example;", NameSpace)
	w.Writeln("begin")
	w.Writeln("  Application:=T%s_Example.Create(nil);", NameSpace)
	w.Writeln("  Application.Run;")
	w.Writeln("  Application.Free;")
	w.Writeln("end.")


	return nil
}

func buildDynamicPascalExampleLPI(w LanguageWriter, NameSpace string, BaseName string, outputFolder string) error {
	w.Writeln ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
	w.Writeln ("<CONFIG>");
	w.Writeln ("  <ProjectOptions>");
	w.Writeln ("    <Version Value=\"%d\"/>", 10);
	w.Writeln ("    <PathDelim Value=\"\\\"/>");
	w.Writeln ("    <General>");
	w.Writeln ("      <Flags>");
	w.Writeln ("        <MainUnitHasCreateFormStatements Value=\"False\" />");
	w.Writeln ("        <MainUnitHasTitleStatement Value=\"False\" />");
	w.Writeln ("        <MainUnitHasScaledStatement Value=\"False\" />");
	w.Writeln ("      </Flags>");
	w.Writeln ("      <SessionStorage Value=\"InProjectDir\" />");
	w.Writeln ("      <MainUnit Value=\"%d\"/>", 0);
	w.Writeln ("      <Title Value=\"%s_Example\" />", NameSpace);
	w.Writeln ("      <UseAppBundle Value=\"False\" />");
	w.Writeln ("      <ResourceType Value=\"res\" />");
	w.Writeln ("    </General>");
	w.Writeln ("    <BuildModes Count=\"%d\">", 2);
	w.Writeln ("      <Item1 Name=\"Release\" Default=\"True\"/>");
	w.Writeln ("      <Item2 Name=\"Debug\">");
	w.Writeln ("        <CompilerOptions>");
	w.Writeln ("          <Version Value=\"11\" />");
	w.Writeln ("          <PathDelim Value=\"\\\"/>");
	w.Writeln ("          <Target>");
	w.Writeln ("            <Filename Value=\"bin\\$(TargetCPU)-$(TargetOS)\\Release\\%s_Example\"/>", NameSpace);
	w.Writeln ("          </Target>");
	w.Writeln ("          <SearchPaths>");
	w.Writeln ("            <IncludeFiles Value=\"$(ProjOutDir)\"/>");
	w.Writeln ("            <OtherUnitFiles Value=\"..\\..\\Bindings\\Pascal\"/>");
	w.Writeln ("            <UnitOutputDirectory Value=\"lib\\$(TargetCPU)-$(TargetOS)\"/>");
	w.Writeln ("          </SearchPaths>");
	w.Writeln ("          <Parsing>");
	w.Writeln ("            <SyntaxOptions>");
	w.Writeln ("              <IncludeAssertionCode Value=\"True\"/>");
	w.Writeln ("            </SyntaxOptions>");
	w.Writeln ("          </Parsing>");
	w.Writeln ("          <CodeGeneration>");
	w.Writeln ("            <RelocatableUnit Value=\"True\" />");
	w.Writeln ("          </CodeGeneration>");
	w.Writeln ("          <Linking>");
	w.Writeln ("            <Debugging>");
	w.Writeln ("              <UseExternalDbgSyms Value=\"True\"/>");
	w.Writeln ("            </Debugging>");
	w.Writeln ("            <Options>");
	w.Writeln ("              <ExecutableType Value=\"Library\"/>");
	w.Writeln ("            </Options>");
	w.Writeln ("          </Linking>");
	w.Writeln ("        </CompilerOptions>");
	w.Writeln ("      </Item2>");
	w.Writeln ("    </BuildModes>");
	w.Writeln ("    <PublishOptions>");
	w.Writeln ("      <Version Value=\"%d\"/>", 2);
	w.Writeln ("    </PublishOptions>");

	w.Writeln ("    <RunParams>");
	w.Writeln ("      <local>");
	w.Writeln ("        <FormatVersion Value=\"1\"/>");
	w.Writeln ("      </local>");
	w.Writeln ("    </RunParams>");

	w.Writeln ("    <Units Count=\"%d\">", 2);
	w.Writeln ("      <Unit0>");
	w.Writeln ("        <Filename Value=\"%s_Example.lpr\"/>", NameSpace);
	w.Writeln ("        <IsPartOfProject Value=\"True\"/>");
	w.Writeln ("      </Unit0>");
	w.Writeln ("      <Unit1>");
	w.Writeln ("        <Filename Value=\"Unit_%s.pas\"/>", NameSpace);
	w.Writeln ("        <IsPartOfProject Value=\"True\"/>");
	w.Writeln ("      </Unit1>");
	w.Writeln ("    </Units>");

	w.Writeln ("  </ProjectOptions>");
	w.Writeln ("  <CompilerOptions>");
	w.Writeln ("    <Version Value=\"%d\"/>", 11);
	w.Writeln ("    <PathDelim Value=\"\\\"/>");
	w.Writeln ("    <Target>");
	w.Writeln ("      <Filename Value=\"bin\\$(TargetCPU)-$(TargetOS)\\Release\\%s_Example\"/>", NameSpace);
	w.Writeln ("    </Target>");
	w.Writeln ("    <SearchPaths>");
	w.Writeln ("      <IncludeFiles Value=\"$(ProjOutDir)\"/>");
	w.Writeln ("      <OtherUnitFiles Value=\"..\\..\\Bindings\\Pascal\"/>");
	w.Writeln ("      <UnitOutputDirectory Value=\"lib\\$(TargetCPU)-$(TargetOS)\"/>");
	w.Writeln ("    </SearchPaths>");
	w.Writeln ("    <Parsing>");
	w.Writeln ("      <SyntaxOptions>");
	w.Writeln ("        <IncludeAssertionCode Value=\"True\"/>");
	w.Writeln ("      </SyntaxOptions>");
	w.Writeln ("    </Parsing>");
	w.Writeln ("    <CodeGeneration>");
	w.Writeln ("      <RelocatableUnit Value=\"True\"/>");
	w.Writeln ("    </CodeGeneration>");
	w.Writeln ("    <Linking>");
	w.Writeln ("      <Debugging>");
	w.Writeln ("        <StripSymbols Value=\"True\"/>");
	w.Writeln ("        <UseExternalDbgSyms Value=\"True\"/>");
	w.Writeln ("      </Debugging>");
	w.Writeln ("      <Options>");
	w.Writeln ("        <ExecutableType Value=\"Library\"/>");
	w.Writeln ("      </Options>");
	w.Writeln ("    </Linking>");
	w.Writeln ("  </CompilerOptions>");
	w.Writeln ("  <Debugging>");
	w.Writeln ("    <Exceptions Count=\"%d\">", 3);
	w.Writeln ("      <Item1>");
	w.Writeln ("        <Name Value=\"EAbort\"/>");
	w.Writeln ("      </Item1>");
	w.Writeln ("      <Item2>");
	w.Writeln ("        <Name Value=\"ECodetoolError\"/>");
 	w.Writeln ("      </Item2>");
	w.Writeln ("      <Item3>");
	w.Writeln ("        <Name Value=\"EFOpenError\"/>");
	w.Writeln ("      </Item3>");
	w.Writeln ("    </Exceptions>");     
	w.Writeln ("  </Debugging>");
	w.Writeln ("</CONFIG>");    	
	w.Writeln ("");

	return nil;
	
}
