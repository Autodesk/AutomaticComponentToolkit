/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildbindinggo.go
// functions to generate Go-bindings of a library's API.
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"path"
	"errors"
	"strings"
)

// BuildBindingGo builds Go-bindings of a library's API
func BuildBindingGo(component ComponentDefinition, outputFolder string) error {
	namespace := component.NameSpace;
	libraryname := component.LibraryName;
	baseName := component.BaseName;

	GoIntfName := path.Join(outputFolder, baseName + ".go");
	log.Printf ("Creating \"%s\"", GoIntfName);
	gofile, err := os.Create(GoIntfName);
	if (err != nil) {
		log.Fatal (err);
	}

	GoImplName := path.Join(outputFolder, baseName + "_impl.go");
	log.Printf ("Creating \"%s\"", GoImplName);
	goimplfile, err := os.Create(GoImplName);
	if (err != nil) {
		log.Fatal (err);
	}

	WriteLicenseHeader(gofile, component,
		fmt.Sprintf ("This is an autogenerated Go wrapper file in order to allow an easy\n use of %s", libraryname),
		true);
	WriteLicenseHeader(goimplfile, component,
		fmt.Sprintf ("This is an autogenerated Go implementation file in order to allow an easy\n use of %s", libraryname),
		true);

	return buildGoWrapper (component, gofile, goimplfile, namespace);
}

func buildGoWrapper (component ComponentDefinition, w io.Writer, implw io.Writer, NameSpace string) (error) {

	global := component.Global;

	fmt.Fprintf (w, "\n");
	fmt.Fprintf (w, "package main\n");
	fmt.Fprintf (w, "\n");

	fmt.Fprintf (w, "\n");
	fmt.Fprintf (w, "/*************************************************************************************************************************\n");
	fmt.Fprintf (w, " Declaration of enums\n");
	fmt.Fprintf (w, "**************************************************************************************************************************/\n");
	fmt.Fprintf (w, "\n");

	for i := 0; i < len(component.Enums); i++ {
		enum := component.Enums[i];
		fmt.Fprintf (w, "type E%s%s int\n", NameSpace, enum.Name);

		fmt.Fprintf (w, "const (\n");
		
		for j := 0; j < len(enum.Options); j++ {			
				
			option := enum.Options[j];
			fmt.Fprintf (w, "    e%s_%s = %d\n", enum.Name, option.Name, option.Value);
		}
		
		fmt.Fprintf (w, ")\n");
		fmt.Fprintf (w, "\n");
	}
	
	
	fmt.Fprintf (w, "\n");

	if len(component.Structs) > 0 {
		fmt.Fprintf (w, "/*************************************************************************************************************************\n");
		fmt.Fprintf (w, " Declaration of structs\n");
		fmt.Fprintf (w, "**************************************************************************************************************************/\n");
		fmt.Fprintf (w, "\n");
			
		for i := 0; i < len(component.Structs); i++ {
			structinfo := component.Structs[i];
			fmt.Fprintf (w, "type s%s%s struct {\n", NameSpace, structinfo.Name);
			
			for j := 0; j < len(structinfo.Members); j++ {			

				member := structinfo.Members[j];
			
				arraysuffix := "";
				if (member.Rows > 0) {
					if (member.Columns > 0) {
						arraysuffix = fmt.Sprintf ("[%d][%d]", member.Columns, member.Rows)
					} else {
						arraysuffix = fmt.Sprintf ("[%d]",member.Rows)
					}
				}
			
				switch (member.Type) {
					case "uint8":
						fmt.Fprintf (w, "    %s%s uint8;\n", member.Name, arraysuffix);
					case "uint16":
						fmt.Fprintf (w, "    %s%s uint16;\n", member.Name, arraysuffix);
					case "uint32":
						fmt.Fprintf (w, "    %s%s uint32;\n", member.Name, arraysuffix);
					case "uint64":				
						fmt.Fprintf (w, "    %s%s uint64;\n", member.Name, arraysuffix);
					case "int8":
						fmt.Fprintf (w, "    %s%s int8;\n", member.Name, arraysuffix);
					case "int16":
						fmt.Fprintf (w, "    %s%s int16;\n", member.Name, arraysuffix);
					case "int32":
						fmt.Fprintf (w, "    %s%s int32;\n", member.Name, arraysuffix);
					case "int64":				
						fmt.Fprintf (w, "    %s%s int64;\n", member.Name, arraysuffix);
					case "bool":				
						fmt.Fprintf (w, "    %s%s bool;\n", member.Name, arraysuffix);
					case "single":
						fmt.Fprintf (w, "    %s%s float32;\n", member.Name, arraysuffix);
					case "double":
						fmt.Fprintf (w, "    %s%s float64;\n", member.Name, arraysuffix);
					case "string":
						return fmt.Errorf ("it is not possible for struct s%s%s to contain a string value", NameSpace, structinfo.Name);
					case "handle":
						return fmt.Errorf ("it is not possible for struct s%s%s to contain a handle value", NameSpace, structinfo.Name);
					case "enum":
						fmt.Fprintf (w, "    %s%s E%s%s;\n", member.Name, arraysuffix, NameSpace, member.Class);
				}
				
			}
			
			fmt.Fprintf (w, "}\n");
			fmt.Fprintf (w, "\n");
		}
		
		fmt.Fprintf (w, "\n");

	}

	fmt.Fprintf (w, "/*************************************************************************************************************************\n");
	fmt.Fprintf (w, " Declaration of interfaces\n");
	fmt.Fprintf (w, "**************************************************************************************************************************/\n");
	fmt.Fprintf (w, "\n");
	fmt.Fprintf (w, "type %sHandle interface {\n", NameSpace);
	fmt.Fprintf (w, "    Close() error\n");
	fmt.Fprintf (w, "}\n");
	fmt.Fprintf (w, "\n");

	
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "package main\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "// #include <string.h>\n");
	fmt.Fprintf (implw, "import \"C\"\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "import (\n");
	fmt.Fprintf (implw, "    \"fmt\"\n");
	fmt.Fprintf (implw, "    \"errors\"\n");
	fmt.Fprintf (implw, "    \"syscall\"\n");
	fmt.Fprintf (implw, "    \"unsafe\"\n");
	fmt.Fprintf (implw, ")\n");
	fmt.Fprintf (implw, "\n");


	fmt.Fprintf (implw, "type %sImplementation struct {\n", NameSpace);
	fmt.Fprintf (implw, "    Initialized bool\n");
	fmt.Fprintf (implw, "    DLLHandle syscall.Handle\n");
	
	
	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i];
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j];
			fmt.Fprintf (implw, "    %s_%s_%s%s uintptr\n", NameSpace, strings.ToLower (class.ClassName), strings.ToLower (method.MethodName), method.DLLSuffix);	
		}
	}
	
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j];

		fmt.Fprintf (implw, "    %s_%s%s uintptr\n", NameSpace, strings.ToLower (method.MethodName), method.DLLSuffix);	
	}
	
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");


	fmt.Fprintf (implw, "type %sImplementationHandle interface {\n", NameSpace);
	fmt.Fprintf (implw, "    %sHandle\n", NameSpace);
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "    GetDLLInHandle () (uintptr)\n");
	fmt.Fprintf (implw, "    GetDLLOutHandle () (uintptr)\n");
	fmt.Fprintf (implw, "    GetWrapper () (*%sImplementation)\n", NameSpace);
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "type %sImplementationHandleStruct struct {\n", NameSpace);
	fmt.Fprintf (implw, "    Implementation * %sImplementation\n", NameSpace);
	fmt.Fprintf (implw, "    DLLhandle uintptr\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func (handle *%sImplementationHandleStruct) Close () (error) {\n", NameSpace);
	fmt.Fprintf (implw, "\n");	
	fmt.Fprintf (implw, "    if (handle.DLLhandle != 0) {\n");
	fmt.Fprintf (implw, "        if (handle.Implementation == nil) {\n");
	fmt.Fprintf (implw, "            return errors.New (\"Uninitialized DLL Implementation Handle\");\n");
	fmt.Fprintf (implw, "        }\n");
	fmt.Fprintf (implw, "\n");	
	fmt.Fprintf (implw, "        dllhandle := handle.DLLhandle;\n");
	fmt.Fprintf (implw, "        handle.DLLhandle = 0;\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "        return handle.Implementation.CallFunction (handle.Implementation.%s_%s, dllhandle);\n", NameSpace, strings.ToLower (component.Global.ReleaseMethod));
	fmt.Fprintf (implw, "    }\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "    return nil;\n");
    fmt.Fprintf (implw, "}\n");
    fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func (handle *%sImplementationHandleStruct) GetDLLInHandle () (uintptr) {\n", NameSpace);
	fmt.Fprintf (implw, "    return handle.DLLhandle;\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func (handle *%sImplementationHandleStruct) GetDLLOutHandle () (uintptr) {\n", NameSpace);
	fmt.Fprintf (implw, "    return uintptr (unsafe.Pointer (&handle.DLLhandle));\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func (handle *%sImplementationHandleStruct) GetWrapper () (*%sImplementation) {\n", NameSpace, NameSpace);
	fmt.Fprintf (implw, "    return handle.Implementation;\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func Int64OutValue (reference * int64) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (unsafe.Pointer (reference));\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "func UInt64OutValue (reference * uint64) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (unsafe.Pointer (reference));\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func Float32OutValue (reference * float32) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (unsafe.Pointer (reference));\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func Float64OutValue (reference * float64) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (unsafe.Pointer (reference));\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func Int64InValue (value int64) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (value);\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func UInt8InValue (value uint8) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (value);\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func UInt16InValue (value uint16) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (value);\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func UInt32InValue (value uint32) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (value);\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func Uint64InValue (value uint64) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (value);\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func Float32InValue (value float32) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (*(*uint32)(unsafe.Pointer(&value)));\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func Float64InValue (value float64) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (*(*uint64)(unsafe.Pointer(&value)));\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func StringInValue (value string) uintptr {\n");
	fmt.Fprintf (implw, "    bytePtr, err := syscall.BytePtrFromString (value);\n");
	fmt.Fprintf (implw, "    if err != nil {\n");
	fmt.Fprintf (implw, "        return 0;\n");
	fmt.Fprintf (implw, "    }	\n");
	fmt.Fprintf (implw, "    return uintptr(unsafe.Pointer (bytePtr));\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func PtrOutValue (ptr * uintptr) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (unsafe.Pointer (ptr));\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "func BytesOutValue (bytePtr * []byte) uintptr {\n");
	fmt.Fprintf (implw, "    return uintptr (unsafe.Pointer (bytePtr));\n");
	fmt.Fprintf (implw, "}\n");
	
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func Get%sErrorMessage	(errorcode uint32) (string) {\n", NameSpace);
	fmt.Fprintf (implw, "    switch (errorcode) {\n");
	
	for i := 0; i < len(component.Errors.Errors); i++ {
		errorcode := component.Errors.Errors[i];
		fmt.Fprintf (implw, "        case %d: return \"%s\";\n", errorcode.Code, errorcode.Name);
	}
	
	fmt.Fprintf (implw, "        default:\n");
	fmt.Fprintf (implw, "            return \"unknown\";\n");
	fmt.Fprintf (implw, "    }\n");
	fmt.Fprintf (implw, "}\n");

	
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func (implementation *%sImplementation) GetWrapperHandle (handle %sHandle) (%sImplementationHandle, error) {\n", NameSpace, NameSpace, NameSpace);
	fmt.Fprintf (implw, "    implementation_handle, ok := handle.(%sImplementationHandle);\n", NameSpace);
	fmt.Fprintf (implw, "    if ok {\n");
	fmt.Fprintf (implw, "        handle_implementation := implementation_handle.GetWrapper ();\n");
	fmt.Fprintf (implw, "        if (handle_implementation == implementation) {\n");
	fmt.Fprintf (implw, "            return implementation_handle, nil;\n");
	fmt.Fprintf (implw, "        }		\n");
	fmt.Fprintf (implw, "        return nil, errors.New (\"Invalid Implementation for DLL handle.\");	\n");
	fmt.Fprintf (implw, "    }	\n");
	fmt.Fprintf (implw, "    return nil, errors.New (\"Could not cast DLL handle.\");	\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func (implementation *%sImplementation) Initialize (DLLFileName string) error {	\n", NameSpace);
	fmt.Fprintf (implw, "    implementation.Initialized = false;\n");
	fmt.Fprintf (implw, "    implementation.DLLHandle = 0;\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "    dllHandle, err := syscall.LoadLibrary(DLLFileName);\n");
	fmt.Fprintf (implw, "    if (err != nil) {\n");
	fmt.Fprintf (implw, "        return err;\n");
	fmt.Fprintf (implw, "    }\n");
	fmt.Fprintf (implw, "\n");

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i];
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j];
			functionName := fmt.Sprintf ("%s_%s_%s%s", strings.ToLower (NameSpace), strings.ToLower (class.ClassName), strings.ToLower (method.MethodName), method.DLLSuffix);
			fmt.Fprintf (implw, "    implementation.%s_%s_%s%s, err = syscall.GetProcAddress (dllHandle, \"%s\");\n", NameSpace, strings.ToLower (class.ClassName), strings.ToLower (method.MethodName), method.DLLSuffix, functionName);
			fmt.Fprintf (implw, "    if (err != nil) {\n");
			fmt.Fprintf (implw, "        return errors.New (\"Could not get function %s: \" + err.Error());\n", functionName);
			fmt.Fprintf (implw, "    }\n");
			fmt.Fprintf (implw, "    \n");
		}
	}
	
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j];
		
		functionName := fmt.Sprintf ("%s_%s%s", strings.ToLower (NameSpace), strings.ToLower (method.MethodName), method.DLLSuffix);
		fmt.Fprintf (implw, "    implementation.%s_%s%s, err = syscall.GetProcAddress (dllHandle, \"%s\");\n", NameSpace, strings.ToLower (method.MethodName), method.DLLSuffix, functionName);
		fmt.Fprintf (implw, "    if (err != nil) {\n");
		fmt.Fprintf (implw, "        return errors.New (\"Could not get function %s: \" + err.Error());\n", functionName);
		fmt.Fprintf (implw, "    }\n");
		fmt.Fprintf (implw, "    \n");
	}
	
	
	fmt.Fprintf (implw, "    implementation.DLLHandle =  dllHandle;\n");
	fmt.Fprintf (implw, "    implementation.Initialized = true;	\n");
	fmt.Fprintf (implw, "    return nil;\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func (implementation *%sImplementation) NewHandle () (%sImplementationHandle) {	\n", NameSpace, NameSpace);
	fmt.Fprintf (implw, "    handle := new (%sImplementationHandleStruct);\n", NameSpace);
	fmt.Fprintf (implw, "    handle.Implementation = implementation;\n");
	fmt.Fprintf (implw, "    handle.DLLhandle = 0;	\n");
	fmt.Fprintf (implw, "    return handle;	\n");
	fmt.Fprintf (implw, "}\n");	
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "func (implementation *%sImplementation) CallFunction (funcptr uintptr, parameters ... uintptr) (error) {\n", NameSpace);
	fmt.Fprintf (implw, "    var ret uintptr;\n");
	fmt.Fprintf (implw, "    if (!implementation.Initialized) {\n");
	fmt.Fprintf (implw, "        return errors.New (\"%s Implementation has not been initialized!\");\n", NameSpace);
	fmt.Fprintf (implw, "    }\n");
	fmt.Fprintf (implw, "	\n");
	fmt.Fprintf (implw, "    switch len(parameters) { \n");
	fmt.Fprintf (implw, "        case 0: ret, _, _ = syscall.Syscall (funcptr, 0, 0, 0, 0); \n");
	fmt.Fprintf (implw, "        case 1: ret, _, _ = syscall.Syscall (funcptr, 1, uintptr (parameters[0]), 0, 0); \n");
	fmt.Fprintf (implw, "        case 2: ret, _, _ = syscall.Syscall (funcptr, 2, uintptr (parameters[0]), uintptr (parameters[1]), 0); \n");
	fmt.Fprintf (implw, "        case 3: ret, _, _ = syscall.Syscall (funcptr, 3, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2])); \n");
	fmt.Fprintf (implw, "        case 4: ret, _, _ = syscall.Syscall6 (funcptr, 4, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), 0, 0); \n");
	fmt.Fprintf (implw, "        case 5: ret, _, _ = syscall.Syscall6 (funcptr, 5, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), 0);	\n");
	fmt.Fprintf (implw, "        case 6: ret, _, _ = syscall.Syscall6 (funcptr, 6, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]));\n");
	fmt.Fprintf (implw, "        case 7: ret, _, _ = syscall.Syscall9 (funcptr, 7, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), 0, 0);\n");
	fmt.Fprintf (implw, "        case 8: ret, _, _ = syscall.Syscall9 (funcptr, 8, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), uintptr (parameters[7]), 0);\n");
	fmt.Fprintf (implw, "        case 9: ret, _, _ = syscall.Syscall9 (funcptr, 9, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), uintptr (parameters[7]), uintptr (parameters[8]));\n");
	fmt.Fprintf (implw, "        case 10: ret, _, _ = syscall.Syscall12 (funcptr, 10, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), uintptr (parameters[7]), uintptr (parameters[8]), uintptr (parameters[9]), 0, 0);\n");
	fmt.Fprintf (implw, "        case 11: ret, _, _ = syscall.Syscall12 (funcptr, 11, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), uintptr (parameters[7]), uintptr (parameters[8]), uintptr (parameters[9]), uintptr (parameters[10]), 0);\n");
	fmt.Fprintf (implw, "        case 12: ret, _, _ = syscall.Syscall12 (funcptr, 12, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), uintptr (parameters[7]), uintptr (parameters[8]), uintptr (parameters[9]), uintptr (parameters[10]), uintptr (parameters[11]));\n");
	fmt.Fprintf (implw, "        default: \n");
	fmt.Fprintf (implw, "            return errors.New (\"Invalid DLL function parameter count!\");\n");
	fmt.Fprintf (implw, "    }\n");
	fmt.Fprintf (implw, "    \n");
	fmt.Fprintf (implw, "    if (int(ret) != 0) {\n");
	fmt.Fprintf (implw, "        return errors.New (fmt.Sprintf (\"%s Error: %%.04x (%%s)\", int(ret), Get%sErrorMessage (uint32(ret))));\n", NameSpace, NameSpace);
	fmt.Fprintf (implw, "    }\n");
	fmt.Fprintf (implw, "\n");
	fmt.Fprintf (implw, "    return nil;\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
	
	
	fmt.Fprintf (w, "type %sGoInterface interface {\n", NameSpace);
	
	spacing := "    ";
	classdefinitions := "";

   		
	for i := 0; i < len(component.Classes); i++ {
	
		class := component.Classes[i];
		
		classdefinitions = classdefinitions + fmt.Sprintf ("\n");
		classdefinitions = classdefinitions + fmt.Sprintf ("/*************************************************************************************************************************\n");
		classdefinitions = classdefinitions + fmt.Sprintf (" Class definition %s%s\n", NameSpace, class.ClassName);
		classdefinitions = classdefinitions + fmt.Sprintf ("**************************************************************************************************************************/\n");
		classdefinitions = classdefinitions + fmt.Sprintf ("\n");
		classdefinitions = classdefinitions + fmt.Sprintf ("%stype %s%s struct {\n", spacing, NameSpace, class.ClassName);
		classdefinitions = classdefinitions + fmt.Sprintf ("%s    Interface %sGoInterface;\n", spacing, NameSpace);
		classdefinitions = classdefinitions + fmt.Sprintf ("%s    Handle %sHandle;\n", spacing, NameSpace);
		classdefinitions = classdefinitions + fmt.Sprintf ("%s}\n", spacing);
		classdefinitions = classdefinitions + fmt.Sprintf ("%s\n", spacing);

		classdefinitions = classdefinitions + fmt.Sprintf ("%sfunc (instance *%s%s) Close () (error) {\n", spacing, NameSpace, class.ClassName);
		classdefinitions = classdefinitions + fmt.Sprintf ("%s    return instance.Handle.Close ();\n", spacing);
		classdefinitions = classdefinitions + fmt.Sprintf ("%s}\n", spacing);
		classdefinitions = classdefinitions + fmt.Sprintf ("%s\n", spacing);
		

		for 	j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j];
			
			err := writeGoMethod (method, w, implw, NameSpace, class.ClassName, false, &classdefinitions);
			if (err != nil) {
				return err;
			}
		}
	}	


	classdefinitions = classdefinitions + fmt.Sprintf ("\n");
	classdefinitions = classdefinitions + fmt.Sprintf ("/*************************************************************************************************************************\n");
	classdefinitions = classdefinitions + fmt.Sprintf (" Class definition %sWrapper\n", NameSpace);
	classdefinitions = classdefinitions + fmt.Sprintf ("**************************************************************************************************************************/\n");
	classdefinitions = classdefinitions + fmt.Sprintf ("\n");
	classdefinitions = classdefinitions + fmt.Sprintf ("%stype %sWrapper struct {\n", spacing, NameSpace);
	classdefinitions = classdefinitions + fmt.Sprintf ("%s    Interface %sGoInterface;\n", spacing, NameSpace);
	classdefinitions = classdefinitions + fmt.Sprintf ("%s}\n", spacing);
	classdefinitions = classdefinitions + fmt.Sprintf ("%s\n", spacing);
	
	global = component.Global;
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j];
			
		err := writeGoMethod (method, w, implw, NameSpace, "Wrapper", true, &classdefinitions);
		if (err != nil) {
			return err;
		}
	}
	
	fmt.Fprintf (w, "\n");
	fmt.Fprintf (w, "}\n");
	fmt.Fprintf (w, "\n");
	
	fmt.Fprintf (w, classdefinitions);
	
	fmt.Fprintf (implw, "func %sLoadWrapper (DllFileName string) (%sWrapper, error) {\n", NameSpace, NameSpace);
	fmt.Fprintf (implw, "    var Wrapper %sWrapper;\n", NameSpace);
	fmt.Fprintf (implw, "    var Instance %sImplementation;\n", NameSpace);
	fmt.Fprintf (implw, "    \n");
	fmt.Fprintf (implw, "    err := Instance.Initialize (DllFileName);\n");
	fmt.Fprintf (implw, "    if (err != nil) {\n");
	fmt.Fprintf (implw, "        return Wrapper, err;\n");
	fmt.Fprintf (implw, "    }\n");
	fmt.Fprintf (implw, "    \n");
	fmt.Fprintf (implw, "    Wrapper.Interface = &Instance;\n");
	fmt.Fprintf (implw, "    \n");
	fmt.Fprintf (implw, "    return Wrapper, nil;\n");
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");
		
	
	return nil;
}



func getGoBasicType (paramType string) (string, error) {
	
	switch (paramType) {
		case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "bool":
			return paramType, nil;
	
		case "single":
			return "float32", nil;
			
		case "double":
			return "float64", nil;
		
			
	}
		
	return "", errors.New ("Invalid basic type: " + paramType);
		
}


func writeGoMethod (method ComponentDefinitionMethod, w io.Writer, implw io.Writer, NameSpace string, ClassName string, isGlobal bool, classdefinitions * string) (error) {

	parameters := "";
	callparameters := "";
	returnvalues := "";
	comments := "";
	spacing := "    ";
	

	impldeclarations := fmt.Sprintf ("%svar err error = nil;\n", spacing);
	implcasts := "";

	implreturnvalues := "";
	
	errorreturn := "";
	for k := 0; k < len(method.Params); k++ {
		param := method.Params [k];
		
		if (param.ParamPass == "out") || (param.ParamPass == "return") {
		
			switch (param.ParamType) {
				case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double":
					errorreturn = errorreturn + fmt.Sprintf ("0, ")
				case "enum":
					errorreturn = errorreturn + fmt.Sprintf ("0, ")
				case "bool":
					errorreturn = errorreturn + fmt.Sprintf ("false, ")
				case "string":
					errorreturn = errorreturn + fmt.Sprintf ("\"\", ")
				case "struct":
					errorreturn = errorreturn + fmt.Sprintf ("s%s, ", param.ParamName)
				case "handle":
					errorreturn = errorreturn + fmt.Sprintf ("h%s, ", param.ParamName)
				case "functiontype":
					errorreturn = errorreturn + fmt.Sprintf ("0, ")
				
				case "basicarray":
					basicType, err := getGoBasicType (param.ParamClass);
					if (err != nil) {
						return err;
					}
					
					errorreturn = errorreturn + fmt.Sprintf ("make ([]%s, 0), ", basicType);
					
				case "structarray":
					errorreturn = errorreturn + fmt.Sprintf ("make ([]s%s%s, 0), ", NameSpace, param.ParamClass);
					
				default:
					return fmt.Errorf ("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName);
			}					
		}				
	}
	errorreturn = errorreturn + "err";
	

	if (!isGlobal) {
		implcasts = implcasts + fmt.Sprintf ("%s\n", spacing);
		implcasts = implcasts + fmt.Sprintf ("%simplementation_%s, err := implementation.GetWrapperHandle (%s);\n", spacing, strings.ToLower (ClassName), ClassName);
		implcasts = implcasts + fmt.Sprintf ("%sif (err != nil) {\n", spacing);
		implcasts = implcasts + fmt.Sprintf ("%s    return %s;\n", spacing, errorreturn);
		implcasts = implcasts + fmt.Sprintf ("%s}\n", spacing);
	}

	implcommandparameters := "";
	implcommandpreparation := "";
	implcommandpost := "";

	classreturnvariables := "";
	classreturnimplementation := "";
	classreturnstring := "";
	classreturntypes := "";
	
	for k := 0; k < len(method.Params); k++ {
		param := method.Params [k];
		switch (param.ParamPass) {				
		case "in":
		
			if (parameters != "") {
				parameters = parameters + ", ";
			}
			if (callparameters != "") {
				callparameters = callparameters + ", ";
			}
			
			switch (param.ParamType) {
				case "uint8":
					comments = comments + fmt.Sprintf("    * @param[in] n%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("n%s uint8", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", UInt8InValue (n%s)", param.ParamName);
					callparameters = callparameters + "n" + param.ParamName;

				case "uint16":
					comments = comments + fmt.Sprintf("    * @param[in] n%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("n%s uint16", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", UInt16InValue (n%s)", param.ParamName);
					callparameters = callparameters + "n" + param.ParamName;
				
				case "uint32":
					comments = comments + fmt.Sprintf("    * @param[in] n%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("n%s uint32", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", UInt32InValue (n%s)", param.ParamName);
					callparameters = callparameters + "n" + param.ParamName;
				
				case "uint64":
					comments = comments + fmt.Sprintf("    * @param[in] n%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("n%s uint64", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", UInt64InValue (n%s)", param.ParamName);
					callparameters = callparameters + "n" + param.ParamName;
				
				case "int8":
					comments = comments + fmt.Sprintf("    * @param[in] n%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("n%s int8", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int8InValue (n%s)", param.ParamName);
					callparameters = callparameters + "n" + param.ParamName;

				case "int16":
					comments = comments + fmt.Sprintf("    * @param[in] n%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("n%s int16", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int16InValue (n%s)", param.ParamName);
					callparameters = callparameters + "n" + param.ParamName;
					
				case "int32":
					comments = comments + fmt.Sprintf("    * @param[in] n%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("n%s int32", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int32InValue (n%s)", param.ParamName);
					callparameters = callparameters + "n" + param.ParamName;
					
				case "int64":
					comments = comments + fmt.Sprintf("    * @param[in] n%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("n%s int64", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int64InValue (n%s)", param.ParamName);
					callparameters = callparameters + "n" + param.ParamName;
					
				case "bool":
					comments = comments + fmt.Sprintf("    * @param[in] b%s - %s\n", param.ParamName, param.ParamDescription);
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar n%s uint32 = 0;\n", spacing, param.ParamName);
					impldeclarations = impldeclarations + fmt.Sprintf ("%sif (b%s) {\n", spacing, param.ParamName);
					impldeclarations = impldeclarations + fmt.Sprintf ("%s    n%s = 1;\n", spacing, param.ParamName);
					impldeclarations = impldeclarations + fmt.Sprintf ("%s}\n", spacing);
					impldeclarations = impldeclarations + fmt.Sprintf ("%s\n", spacing);
					parameters = parameters + fmt.Sprintf ("b%s bool", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", UInt32InValue (n%s)", param.ParamName);
					callparameters = callparameters + "b" + param.ParamName;
					
				case "single":				
					comments = comments + fmt.Sprintf("    * @param[in] f%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("f%s float32", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Float32InValue (f%s)", param.ParamName);
					callparameters = callparameters + "f" + param.ParamName;

				case "double":				
					comments = comments + fmt.Sprintf("    * @param[in] d%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("d%s float64", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Float64InValue (d%s)", param.ParamName);
					callparameters = callparameters + "d" + param.ParamName;
												
				case "string":
					comments = comments + fmt.Sprintf("    * @param[in] s%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("s%s string", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", StringInValue (s%s)", param.ParamName);
					callparameters = callparameters + "s" + param.ParamName;

				case "enum":				
					comments = comments + fmt.Sprintf("    * @param[in] e%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("e%s E%s%s", param.ParamName, NameSpace, param.ParamClass)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", uintptr (e%s)", param.ParamName);
					callparameters = callparameters + "e" + param.ParamName;

				case "struct":
					comments = comments + fmt.Sprintf("    * @param[in] s%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("s%s s%s%s", param.ParamName, NameSpace, param.ParamClass)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", uintptr (unsafe.Pointer (&s%s))", param.ParamName);
					callparameters = callparameters + "s" + param.ParamName;

				case "basicarray":
					basicType, err := getGoBasicType (param.ParamClass);
					if (err != nil) {
						return err;
					}
					
					comments = comments + fmt.Sprintf("    * @param[in] %s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("%s []%s", param.ParamName, basicType)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", 0, 0");
					callparameters = callparameters + param.ParamName;


				case "structarray":					
					comments = comments + fmt.Sprintf("    * @param[in] %s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("%s []s%s%s", param.ParamName, NameSpace, param.ParamClass)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", 0, 0");
					callparameters = callparameters + param.ParamName;

				case "functiontype":
					comments = comments + fmt.Sprintf("    * @param[in] p%s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("p%s int64", param.ParamName)
					implcommandparameters = implcommandparameters + fmt.Sprintf (", 0");
					callparameters = callparameters + "p" + param.ParamName;
				
				case "handle":
					comments = comments + fmt.Sprintf("    * @param[in] %s - %s\n", param.ParamName, param.ParamDescription);
					parameters = parameters + fmt.Sprintf ("%s %sHandle", param.ParamName, NameSpace)
				
					implcasts = implcasts + fmt.Sprintf ("%simplementation_%s, err := implementation.GetWrapperHandle (%s);\n", spacing, strings.ToLower (param.ParamName), param.ParamName);
					implcasts = implcasts + fmt.Sprintf ("%sif (err != nil) {\n", spacing);
					implcasts = implcasts + fmt.Sprintf ("%s    return %s;\n", spacing, errorreturn);
					implcasts = implcasts + fmt.Sprintf ("%s}\n", spacing);
					implcasts = implcasts + fmt.Sprintf ("%s\n", spacing);
				
					implcommandparameters = implcommandparameters + fmt.Sprintf (", implementation_%s.GetDLLInHandle ()", strings.ToLower (param.ParamName));
					callparameters = callparameters + param.ParamName;
				
				default:
					return fmt.Errorf ("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName);
			}
			
		case "out", "return":
		
			switch (param.ParamType) {
				case "uint8":				
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("uint8, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar n%s int64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("uint8(n%s), ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int64OutValue (&n%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "n" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "n" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("uint8, ");

				case "uint16":				
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("uint16, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar n%s int64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("uint16(n%s), ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int64OutValue (&n%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "n" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "n" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("uint16, ");
					
				case "uint32":				
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("uint32, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar n%s int64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("uint32(n%s), ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int64OutValue (&n%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "n" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "n" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("uint32, ");
					
				case "uint64":
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("uint64, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar n%s uint64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("n%s, ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", UInt64OutValue (&n%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "n" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "n" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("uint64, ");
				
				case "int8":				
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("int8, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar n%s int64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("int8(n%s), ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int64OutValue (&n%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "n" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "n" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("int8, ");

				case "int16":				
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("int16, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar n%s int64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("int16(n%s), ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int64OutValue (&n%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "n" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "n" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("int16, ");
					
				case "int32":				
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("int32, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar n%s int64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("int32(n%s), ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int64OutValue (&n%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "n" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "n" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("int32, ");
					
				case "int64":
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("int64, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar n%s int64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("n%s, ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int64OutValue (&n%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "n" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "n" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("int64, ");

				case "bool":
					comments = comments + fmt.Sprintf("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("bool, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar b%s int64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("(b%s != 0), ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Int64OutValue (&b%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "b" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "b" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("bool, ");

				case "single":				
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("float32, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar f%s float32 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("f%s, ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Float32OutValue (&f%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "f" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "f" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("float32, ");

				case "double":
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("float64, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar d%s float64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("d%s, ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", Float64OutValue (&d%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "d" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "d" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("float64, ");
					
				case "string":
					comments = comments + fmt.Sprintf("    * @return %s\n", param.ParamDescription);
				
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%svar neededfor%s int64 = 0;\n", spacing, param.ParamName);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%svar filledin%s int64 = 0;\n", spacing, param.ParamName);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%serr = implementation.CallFunction (implementation.%s_%s_%s%s, implementation_%s.GetDLLInHandle()%s, Int64InValue (0), Int64InValue (0), Int64OutValue (&neededfor%s));\n", spacing, NameSpace, strings.ToLower(ClassName), strings.ToLower(method.MethodName), method.DLLSuffix, strings.ToLower(ClassName), implcommandparameters, param.ParamName);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%sif (err != nil) {\n", spacing);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%s    return %s;\n", spacing, errorreturn);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%s}\n", spacing);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%s\n", spacing);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%sif (neededfor%s < 0) {\n", spacing, param.ParamName);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%s    err = errors.New (\"%s_%s: invalid character count (%s)\");\n", spacing, ClassName, method.MethodName, param.ParamName);						
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%s    return %s;\n", spacing, errorreturn);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%s}\n", spacing);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%s\n", spacing);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%sbufferSize%s := neededfor%s + 1;\n", spacing, param.ParamName, param.ParamName);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%sbuffer%s := make([]byte, bufferSize%s);\n", spacing, param.ParamName, param.ParamName);
					implcommandpreparation = implcommandpreparation + fmt.Sprintf ("%s\n", spacing);

					implcommandparameters = implcommandparameters + fmt.Sprintf (", uintptr (unsafe.Pointer (&buffer%s[0])), Int64InValue (bufferSize%s), Int64OutValue (&filledin%s)", param.ParamName, param.ParamName, param.ParamName);

					implcommandpost = implcommandpost + fmt.Sprintf ("%sif (filledin%s < 0) {\n", spacing, param.ParamName);
					implcommandpost = implcommandpost + fmt.Sprintf ("%s    err = errors.New (\"%s_%s: invalid buffer size (%s)\");\n", spacing, ClassName, method.MethodName, param.ParamName);						
					implcommandpost = implcommandpost + fmt.Sprintf ("%s    return %s;\n", spacing, errorreturn);
					implcommandpost = implcommandpost + fmt.Sprintf ("%s}\n\n", spacing);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("string (buffer%s[:filledin%s]), ", param.ParamName, param.ParamName);
				
					returnvalues = returnvalues + fmt.Sprintf ("string, ")
					classreturnvariables = classreturnvariables + "s" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "s" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("string, ");

				case "enum":
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("E%s%s, ", NameSpace, param.ParamClass)
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar e%s uint64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("E%s%s (e%s), ", NameSpace, param.ParamClass, param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", UInt64OutValue (&e%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "e" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "e" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("E%s%s, ", NameSpace, param.ParamClass);


				case "basicarray":
					basicType, err := getGoBasicType (param.ParamClass);
					if (err != nil) {
						return err;
					}
					
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("[]%s, ", basicType)
					impldeclarations = impldeclarations + fmt.Sprintf ("%sarray%s := make ([]%s, 0);\n", spacing, param.ParamName, basicType);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("array%s, ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", 0, 0, 0");
					classreturnvariables = classreturnvariables + "array" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "array" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("[]%s, ", basicType);

				case "structarray":					
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("[]s%s%s, ", NameSpace, param.ParamClass)
					impldeclarations = impldeclarations + fmt.Sprintf ("%sarray%s := make ([]s%s%s, 0);\n", spacing, param.ParamName, NameSpace, param.ParamClass);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("array%s, ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", 0, 0, 0");
					classreturnvariables = classreturnvariables + "array" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "array" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("[]s%s%s, ", NameSpace, param.ParamClass);
					
				case "functiontype":
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("uint64, ")
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar p%s uint64 = 0;\n", spacing, param.ParamName);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("p%s, ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", UInt64OutValue (&p%s)", param.ParamName);
					classreturnvariables = classreturnvariables + "p" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "p" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("uint64, ");

				case "struct":
					comments = comments + fmt.Sprintf ("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("s%s%s, ", NameSpace, param.ParamClass)
					impldeclarations = impldeclarations + fmt.Sprintf ("%svar s%s s%s%s;\n", spacing, param.ParamName, NameSpace, param.ParamClass);
					implreturnvalues = implreturnvalues + fmt.Sprintf ("s%s, ", param.ParamName);
					implcommandparameters = implcommandparameters + fmt.Sprintf (", 0");
					classreturnvariables = classreturnvariables + "s" + param.ParamName + ", ";
					classreturnstring = classreturnstring + "s" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("s%s%s, ", NameSpace, param.ParamClass);
					
				case "handle":
					comments = comments + fmt.Sprintf("    * @return %s\n", param.ParamDescription);
					returnvalues = returnvalues + fmt.Sprintf ("%sHandle, ", NameSpace)
					impldeclarations = impldeclarations + fmt.Sprintf ("%sh%s := implementation.NewHandle();\n", spacing, param.ParamName);

					implcommandparameters = implcommandparameters + fmt.Sprintf (", h%s.GetDLLOutHandle ()", param.ParamName);
					
					implreturnvalues = implreturnvalues + fmt.Sprintf ("h%s, ", param.ParamName);
					classreturnvariables = classreturnvariables + "h" + param.ParamName + ", ";
					classreturnimplementation = classreturnimplementation + fmt.Sprintf ("%s    var c%s %s%s;\n", spacing, param.ParamName, NameSpace, param.ParamClass);
					classreturnimplementation = classreturnimplementation + fmt.Sprintf ("%s    c%s.Interface = instance.Interface;\n", spacing, param.ParamName);
					classreturnimplementation = classreturnimplementation + fmt.Sprintf ("%s    c%s.Handle = h%s;\n", spacing, param.ParamName, param.ParamName);
					
					classreturnstring = classreturnstring + "c" + param.ParamName + ", ";
					classreturntypes = classreturntypes + fmt.Sprintf ("%s%s, ", NameSpace, param.ParamClass);
					

				default:
					return fmt.Errorf ("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, ClassName, method.MethodName, param.ParamName);
			}
			
		default:
			return fmt.Errorf ("invalid method parameter passing \"%s\" for %s.%s (%s)", param.ParamPass, ClassName, method.MethodName, param.ParamName);
		}
		
	} 
	
	fmt.Fprintf (w, "\n");
	fmt.Fprintf (w, "    /**\n");
	fmt.Fprintf (w, "    * %s\n", method.MethodDescription);
	fmt.Fprintf (w, "    *\n");
	fmt.Fprintf (w, "    * @param[in] %s - %s instance.\n", ClassName, ClassName);
	fmt.Fprintf (w, comments);
	fmt.Fprintf (w, "    */\n");
	
	handleparameter := "";
	
	if isGlobal {
		fmt.Fprintf (w, "    %s (%s) (%serror)\n", method.MethodName, parameters, returnvalues);
	} else {
		handleparameter = fmt.Sprintf ("%s %sHandle", ClassName, NameSpace);
		if (parameters != "") {
			handleparameter = handleparameter + ", ";
		}
		
		fmt.Fprintf (w, "    %s_%s (%s%s) (%serror)\n", ClassName, method.MethodName, handleparameter, parameters, returnvalues);

	}
	
	
	
	if isGlobal {
	
		// Implementation
		fmt.Fprintf (implw, "func (implementation *%sImplementation) %s (%s%s) (%serror) {\n", NameSpace, method.MethodName, handleparameter, parameters, returnvalues);
		fmt.Fprintf (implw, impldeclarations);
		fmt.Fprintf (implw, implcasts);
		fmt.Fprintf (implw, "\n");
		fmt.Fprintf (implw, implcommandpreparation);
		
		fmt.Fprintf (implw, "    err = implementation.CallFunction (implementation.%s_%s%s%s);\n", NameSpace, strings.ToLower (method.MethodName), method.DLLSuffix, implcommandparameters);
		
	} else {
	
		// Implementation
		fmt.Fprintf (implw, "func (implementation *%sImplementation) %s_%s (%s%s) (%serror) {\n", NameSpace, ClassName, method.MethodName, handleparameter, parameters, returnvalues);
		fmt.Fprintf (implw, impldeclarations);
		fmt.Fprintf (implw, implcasts);
		fmt.Fprintf (implw, "\n");
		fmt.Fprintf (implw, implcommandpreparation);

		fmt.Fprintf (implw, "    err = implementation.CallFunction (implementation.%s_%s_%s%s, implementation_%s.GetDLLInHandle()%s);\n", NameSpace, strings.ToLower (ClassName), strings.ToLower (method.MethodName), method.DLLSuffix, strings.ToLower (ClassName), implcommandparameters);
	
	}
		
	fmt.Fprintf (implw, "    if (err != nil) {\n");
	fmt.Fprintf (implw, "        return %s;\n", errorreturn);
	fmt.Fprintf (implw, "    }\n");
	fmt.Fprintf (implw, "    \n");
	fmt.Fprintf (implw, implcommandpost);
	fmt.Fprintf (implw, "    return %serr;\n", implreturnvalues);
	fmt.Fprintf (implw, "}\n");
	fmt.Fprintf (implw, "\n");

	
	if isGlobal {
	
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%sfunc (instance *%s%s) %s (%s) (%serror) {\n", spacing, NameSpace, ClassName, method.MethodName, parameters, classreturntypes);
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%s    %serror := instance.Interface.%s (%s);\n", spacing, classreturnvariables, method.MethodName, callparameters);
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%s", classreturnimplementation);
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%s    return %serror;\n", spacing, classreturnstring);
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%s}\n", spacing);
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%s\n", spacing);
		
	} else {

		if (callparameters != "") {
			callparameters = ", " + callparameters;
		}
	
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%sfunc (instance *%s%s) %s (%s) (%serror) {\n", spacing, NameSpace, ClassName, method.MethodName, parameters, classreturntypes);
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%s    %serror := instance.Interface.%s_%s (instance.Handle%s);\n", spacing, classreturnvariables, ClassName, method.MethodName, callparameters);
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%s", classreturnimplementation);
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%s    return %serror;\n", spacing, classreturnstring);
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%s}\n", spacing);
		*classdefinitions = *classdefinitions + fmt.Sprintf ("%s\n", spacing);
	
	}

	return nil;
}
