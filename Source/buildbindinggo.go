/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildbindinggo.go
// functions to generate Go-bindings of a library's API.
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"errors"
	"fmt"
	"log"
	"path"
	"strings"
	"unicode"
	"unicode/utf8"
)

// BuildBindingGo builds Go-bindings of a library's API
func BuildBindingGo(component ComponentDefinition, outputFolder string, outputFolderExample string, indentString string) error {
	forceRecreation := false

	CTypesHeaderName := path.Join(outputFolder, component.BaseName+"_types.h")
	err := CreateCTypesHeader(component, CTypesHeaderName)
	if err != nil {
		return err
	}

	DynamicCHeader := path.Join(outputFolder, component.BaseName+"_dynamic.h")
	log.Printf("Creating \"%s\"", DynamicCHeader)
	dynhfile, err := CreateLanguageFile(DynamicCHeader, indentString)
	if err != nil {
		return err
	}
	dynhfile.WriteCLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated plain C Header file in order to allow an easy\n use of %s", component.LibraryName),
		true)
	err = buildDynamicCCPPHeader(component, dynhfile, component.NameSpace, component.BaseName, false, false)
	if err != nil {
		return err
	}

	DynamicCImpl := path.Join(outputFolder, component.BaseName+"_dynamic.cc")
	log.Printf("Creating \"%s\"", DynamicCImpl)
	dyncppfile, err := CreateLanguageFile(DynamicCImpl, indentString)
	if err != nil {
		return err
	}
	dyncppfile.WriteCLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated plain C Header file in order to allow an easy\n use of %s", component.LibraryName),
		true)

	err = buildDynamicCImplementation(component, dyncppfile, component.NameSpace, component.BaseName, true)
	if err != nil {
		return err
	}

	fnFile, err := CreateLanguageFile(path.Join(outputFolder, "cfunc.go"), "  ")
	if err != nil {
		return err
	}

	fnFile.WriteCLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Go wrapper file in order to allow an easy\nuse of %s.", component.LibraryName),
		true)

	fnFile.Writeln("// Code generated by Automatic Component Toolkit (ACT); DO NOT EDIT.")
	err = buildCFuncsWrapper(component, fnFile)
	if err != nil {
		return err
	}

	GoIntfName := path.Join(outputFolder, component.BaseName+".go")
	log.Printf("Creating \"%s\"", GoIntfName)
	gofile, err := CreateLanguageFile(GoIntfName, "	")
	if err != nil {
		return err
	}

	gofile.WriteCLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Go wrapper file in order to allow an easy\nuse of %s.", component.LibraryName),
		true)

	gofile.Writeln("// Code generated by Automatic Component Toolkit (ACT); DO NOT EDIT.")

	err = buildGoWrapper(component, gofile)
	if err != nil {
		return err
	}

	if len(outputFolderExample) > 0 {
		goExample := path.Join(outputFolderExample, component.NameSpace+"_example"+".go")
		if forceRecreation || !FileExists(goExample) {
			log.Printf("Creating \"%s\"", goExample)
			goExampleFile, err := CreateLanguageFile(goExample, "	")
			if err != nil {
				return err
			}
			goExampleFile.WriteCLicenseHeader(component,
				fmt.Sprintf("This is an autogenerated Go application that demonstrates the\n usage of the Go bindings of %s", component.LibraryName),
				true)
			buildGoExample(component, goExampleFile, outputFolder)
		} else {
			log.Printf("Omitting recreation of Go example file \"%s\"", goExample)
		}
	}
	return nil
}

func buildCFuncsWrapper(component ComponentDefinition, w LanguageWriter) error {
	packageName := strings.ToLower(component.BaseName)

	w.Writeln("")
	w.Writeln("package %s", packageName)
	w.Writeln("")
	w.Writeln("/*")
	w.Writeln("#include \"%s_types.h\"", packageName)

	/*
		TODO
		err := buildCFuncs(component, w)
		if err != nil {
			return err
		} */

	w.Writeln("*/")
	w.Writeln("import \"C\"")
	w.Writeln("")
	return nil
}

func buildGoExample(component ComponentDefinition, w LanguageWriter, outputFolder string) {
	packageName := lowerFirst(component.BaseName)

	w.Writeln("")
	w.Writeln("package main")
	w.Writeln("")
	w.Writeln("import (")
	w.Writeln("  \"fmt\"")
	w.Writeln("  \"log\"")
	w.Writeln("  \"../../Bindings/Go\"")
	w.Writeln(")")
	w.Writeln("")
	w.Writeln("func main() {")
	w.Writeln("  nMajor, nMinor, nMicro, err := %.s%s()", packageName, component.Global.VersionMethod)
	w.Writeln("  if err != nil {")
	w.Writeln("    log.Fatal(err)")
	w.Writeln("  }")
	w.Writeln("  versionString := fmt.Sprintf(\"%s.version = %s\", nMajor, nMinor, nMicro)", component.BaseName, "%d.%d.%d")
	w.Writeln("  ")
	if len(component.Global.PrereleaseMethod) > 0 {
		w.Writeln("  hasInfo, preReleaseInfo, err := %s.%s()", packageName, component.Global.PrereleaseMethod)
		w.Writeln("  if err != nil {")
		w.Writeln("    log.Fatal(err)")
		w.Writeln("  }")
		w.Writeln("  if hasInfo {")
		w.Writeln("    versionString += \"-\"+preReleaseInfo")
		w.Writeln("  }")
		w.Writeln("")
	}
	if len(component.Global.BuildinfoMethod) > 0 {
		w.Writeln("  hasInfo, buildInfo, err := %s()", component.Global.BuildinfoMethod)
		w.Writeln("  if err != nil {")
		w.Writeln("    log.Fatal(err)")
		w.Writeln("  }")
		w.Writeln("  if hasInfo {")
		w.Writeln("    versionString += \"+\"+buildInfo")
		w.Writeln("  }")
		w.Writeln("")
	}

	w.Writeln("  fmt.Println(versionString)")
	w.Writeln("}")
	w.Writeln("")
}

func buildCFuncsForward(component ComponentDefinition, w LanguageWriter) error {
	if len(component.Functions) <= 0 {
		return nil
	}

	w.Writeln("")
	for _, fn := range component.Functions {
		var paramTypes []string
		for _, param := range fn.Params {
			cParams, err := generateCCPPParameter(param, "", fn.FunctionName, component.NameSpace, false)
			if err != nil {
				return err
			}
			for _, cParam := range cParams {
				paramTypes = append(paramTypes, cParam.ParamType)
			}
		}
		w.Writeln("void %s%s_cgo(%s);", component.NameSpace, fn.FunctionName, strings.Join(paramTypes, ", "))
	}
	return nil
}

func buildCFuncs(component ComponentDefinition, w LanguageWriter) error {
	if len(component.Functions) <= 0 {
		return nil
	}

	for _, fn := range component.Functions {
		w.Writeln("")
		var paramTypes []string
		var paramNames []string
		var params []string
		for _, param := range fn.Params {

			cParams, err := generateCCPPParameter(param, "", fn.FunctionName, component.NameSpace, false)
			if err != nil {
				return err
			}
			for _, cParam := range cParams {
				paramTypes = append(paramTypes, cParam.ParamType)
				paramNames = append(paramNames, cParam.ParamName)
				params = append(params, fmt.Sprintf("%s %s", cParam.ParamType, cParam.ParamName))
			}
		}
		fnName := lowerFirst(fn.FunctionName)
		w.Writeln("extern void %s(%s);", fnName, strings.Join(paramTypes, ", "))
		w.Writeln("void %s%s_cgo(%s){", component.NameSpace, fn.FunctionName, strings.Join(params, ", "))
		w.Writeln("  %s(%s);", fnName, strings.Join(paramNames, ", "))
		w.Writeln("}")
	}
	return nil
}

func buildGoFuncs(component ComponentDefinition, w LanguageWriter) error {
	if len(component.Functions) <= 0 {
		return nil
	}

	for _, fn := range component.Functions {
		fnName := lowerFirst(fn.FunctionName)
		var paramCToGo []string
		var params []string
		var paramsC []string
		for _, param := range fn.Params {
			param.ParamName = lowerFirst(param.ParamName)
			tp, err := getGoType(param.ParamType, component.NameSpace, param.ParamClass, param.ParamName, param.ParamPass == "return")
			if err != nil {
				return err
			}
			params = append(params, fmt.Sprintf("%s %s", param.ParamName, tp.Type))
			paramsC = append(paramsC, fmt.Sprintf("%s %s", param.ParamName, tp.CType))
			paramCToGo = append(paramCToGo, tp.CToGo)
		}
		w.Writeln("")
		w.Writeln("// %sFunc %s", fn.FunctionName, endWithDot(lowerFirst(fn.FunctionDescription)))
		w.Writeln("type %sFunc = func(%s)", fn.FunctionName, strings.Join(params, ", "))
		w.Writeln("")
		w.Writeln("var %sFunc %sFunc", fnName, fn.FunctionName)
		w.Writeln("")
		w.Writeln("//export %s", fnName)
		w.Writeln("func %s(%s) {", fnName, strings.Join(paramsC, ", "))
		w.Writeln("  if %sFunc == nil {", fnName)
		w.Writeln("    return")
		w.Writeln("  }")
		w.Writeln("  %sFunc(%s)", fnName, strings.Join(paramCToGo, ", "))
		w.Writeln("}")
	}
	return nil
}

func buildGoEnums(component ComponentDefinition, w LanguageWriter) {
	if len(component.Enums) <= 0 {
		return
	}

	w.Writeln("")
	for _, enum := range component.Enums {
		w.Writeln("// %s represents a %s enum.", enum.Name, component.NameSpace)
		w.Writeln("type %s int", enum.Name)
		w.Writeln("")

		w.Writeln("const (")

		for j := 0; j < len(enum.Options); j++ {

			option := enum.Options[j]
			w.Writeln("  %s_%s = %d", enum.Name, option.Name, option.Value)
		}
		w.Writeln(")")
		w.Writeln("")
	}
}

func buildGoStructs(component ComponentDefinition, w LanguageWriter) error {
	if len(component.Structs) <= 0 {
		return nil
	}

	for _, structinfo := range component.Structs {
		w.Writeln("// %s represents a %s struct.", structinfo.Name, component.NameSpace)
		w.Writeln("type %s struct {", structinfo.Name)

		for _, member := range structinfo.Members {
			arraysuffix := ""
			if member.Rows > 0 {
				if member.Columns > 0 {
					arraysuffix = fmt.Sprintf("[%d][%d]", member.Columns, member.Rows)
				} else {
					arraysuffix = fmt.Sprintf("[%d]", member.Rows)
				}
			}

			switch member.Type {
			case "string":
				return fmt.Errorf("it is not possible for struct %s to contain a string value", structinfo.Name)
			case "class", "optionalclass":
				return fmt.Errorf("it is not possible for struct %s to contain a ref value", structinfo.Name)
			case "enum":
				w.Writeln("  %s%s %s", member.Name, arraysuffix, member.Class)
			default:
				tp, err := getGoType(member.Type, component.NameSpace, member.Class, member.Name, false)
				if err != nil {
					return err
				}
				w.Writeln("  %s%s %s", member.Name, arraysuffix, tp.Type)
			}

		}
		w.Writeln("}")
		w.Writeln("")
	}
	return nil
}

func buildGoErrorHandling(component ComponentDefinition, w LanguageWriter, packageName string) {
	w.Writeln("// Error constants for %s.", component.NameSpace)
	for i := 0; i < len(component.Errors.Errors); i++ {
		errorcode := component.Errors.Errors[i]
		w.Writeln("const %s_ERROR_%s = %d;", strings.ToUpper(component.NameSpace), errorcode.Name, errorcode.Code)
	}
	w.Writeln("")

	w.Writeln("// WrappedError is an error that wraps a %s error.", component.NameSpace)
	w.Writeln("type WrappedError struct {")
	w.Writeln("  Code uint32")
	w.Writeln("  Message string")
	w.Writeln("}")
	w.Writeln("")
	w.Writeln("func (e *WrappedError) Error() string {")
	w.Writeln("  return fmt.Sprintf(\"%s: %%s (%%d)\", e.Message, e.Code)", packageName)
	w.Writeln("}")
	w.Writeln("")
	w.Writeln("func errorMessage(errorcode uint32) string {")
	w.Writeln("  switch (errorcode) {")

	for i := 0; i < len(component.Errors.Errors); i++ {
		errorcode := component.Errors.Errors[i]
		w.Writeln("  case %s_ERROR_%s:", strings.ToUpper(component.NameSpace), errorcode.Name)
		w.Writeln("    return \"%s\";", errorcode.Description)
	}
	w.Writeln("  default:")
	w.Writeln("    return \"unknown\";")
	w.Writeln("  }")
	w.Writeln("}")
	w.Writeln("")
	w.Writeln("func makeError(errorcode uint32) error {")
	w.Writeln("  return &WrappedError{errorcode, errorMessage(uint32(errorcode))}")
	w.Writeln("}")
}

func buildGoClass(component ComponentDefinition, class ComponentDefinitionClass, w LanguageWriter, NameSpace string, packageName string) error {
	w.Writeln("")
	w.Writeln("// %s represents a %s class.", class.ClassName, NameSpace)
	w.Writeln("type %s struct {", class.ClassName)
	if component.Global.BaseClassName == class.ClassName {
		w.Writeln("  _     		[0]func() // uncomparable; to make == not compile")
		w.Writeln("  Ref   		ref       // identifies a C value, see ref type")
		w.Writeln("  wrapperRef Wrapper")
		w.Writeln("  gcPtr 		*ref      // used to trigger the finalizer when the Value is not referenced any more")
	} else {
		if len(class.ParentClass) > 0 {
			w.Writeln("  %s", class.ParentClass)
		} else {
			w.Writeln("  %s", component.Global.BaseClassName)
		}
	}
	w.Writeln("}")
	w.Writeln("")
	if component.Global.BaseClassName == class.ClassName {
		w.Writeln("// New%s creates a new %s.", class.ClassName, class.ClassName)
		w.Writeln("// The wrapped C pointer will be freed when the Go pointer is finalized,")
		w.Writeln("// but one can release it manually calling Release.")
		w.Writeln("func (wrapper Wrapper) New%s(r ref) %s {", class.ClassName, class.ClassName)
		w.Writeln("  gcPtr := new(ref)")
		w.Writeln("  *gcPtr = r")
		w.Writeln("  runtime.SetFinalizer(gcPtr, wrapper.releaseC)")
		w.Writeln("  return %s{Ref: r, gcPtr: gcPtr, wrapperRef: wrapper}", class.ClassName)
		w.Writeln("}")
		w.Writeln("")
		w.Writeln("// Release releases the C pointer.")
		w.Writeln("func (inst %s) Release() error {", class.ClassName)
		w.Writeln("  err := inst.wrapperRef.%s(inst)", component.Global.ReleaseMethod)
		w.Writeln("  *inst.gcPtr = nil")
		w.Writeln("  return err")
		w.Writeln("}")
		w.Writeln("")
		w.Writeln("// Equal reports whether inst and w refer to the same C pointer.")
		w.Writeln("func (inst %s) Equal(w %s) bool {", class.ClassName, class.ClassName)
		w.Writeln("  return inst.Ref == w.Ref")
		w.Writeln("}")
	} else {
		w.Writeln("func (wrapper Wrapper) New%s(r ref) %s {", class.ClassName, class.ClassName)
		if class.ParentClass != "" && class.ParentClass != component.Global.BaseClassName {
			w.Writeln("  return %s{wrapper.New%s(r)}", class.ClassName, class.ParentClass)
		} else {
			w.Writeln("  return %s{wrapper.New%s(r)}", class.ClassName, component.Global.BaseClassName)
		}
		w.Writeln("}")
		w.Writeln("")
	}
	for j := 0; j < len(class.Methods); j++ {
		method := class.Methods[j]

		err := writeGoMethod(method, w, NameSpace, packageName, class.ClassName, false)
		if err != nil {
			return err
		}
	}
	return nil
}

// WriteCGoAbiMethod writes an ABI method in CGo-Style
func WriteCGoAbiMethod(method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, isGlobal bool) error {
	CMethodName := ""
	var parameters, callParameters []string
	if isGlobal {
		CMethodName = fmt.Sprintf("%s_%s", strings.ToLower(NameSpace), strings.ToLower(method.MethodName))
	} else {
		CMethodName = fmt.Sprintf("%s_%s_%s", strings.ToLower(NameSpace), strings.ToLower(ClassName), strings.ToLower(method.MethodName))
		parameters = append(parameters, fmt.Sprintf("%s_%s p%s", NameSpace, ClassName, ClassName))
		callParameters = append(callParameters, fmt.Sprintf("p%s", ClassName))
	}

	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		cParams, err := generateCCPPParameter(param, ClassName, method.MethodName, NameSpace, false)
		if err != nil {
			return err
		}
		for _, cParam := range cParams {
			parameters = append(parameters, cParam.ParamType + " " + cParam.ParamName)
			callParameters = append(callParameters, cParam.ParamName)

		}
	}

	w.Writeln("")
	w.Writeln("%sResult CCall_%s(%sHandle libraryHandle, %s)", NameSpace, CMethodName, NameSpace, strings.Join(parameters, ", "))
	w.Writeln("{")
	w.Writeln("  if (libraryHandle == 0) ")
	w.Writeln("    return %s_ERROR_INVALIDCAST;", strings.ToUpper(NameSpace))
	w.Writeln("  s%sDynamicWrapperTable * wrapperTable = (s%sDynamicWrapperTable *) libraryHandle;", NameSpace, NameSpace)

	callParametersStr := strings.Join(callParameters, ", ")
	if isGlobal {
		w.Writeln("  return wrapperTable->m_%s (%s);", method.MethodName, callParametersStr)
	} else {
		w.Writeln("  return wrapperTable->m_%s_%s (%s);", ClassName, method.MethodName, callParametersStr)
	}
	w.Writeln("}")
	w.Writeln("")

	return nil
}

func writeGoCCall(component ComponentDefinition, method ComponentDefinitionMethod, w LanguageWriter, className string, isGlobal bool) error {
	err := WriteCGoAbiMethod(method, w, component.NameSpace, className, isGlobal)
	if err != nil {
		return err
	}
	return nil
}

func writeGoCCalls(component ComponentDefinition, w LanguageWriter) error {
	for _, class := range component.Classes {
		for _, method := range class.Methods {
			err := writeGoCCall(component, method, w, class.ClassName, false)
			if err != nil {
				return err
			}
		}
	}
	for _, method := range component.Global.Methods {
		err := writeGoCCall(component, method, w, "Wrapper", true)
		if err != nil {
			return err
		}
	}
	return nil

}

func buildGoWrapper(component ComponentDefinition, w LanguageWriter) error {

	var err error

	packageName := strings.ToLower(component.BaseName)

	w.Writeln("")
	w.Writeln("package %s", packageName)
	w.Writeln("")
	w.Writeln("/*")
	w.Writeln("#include \"%s_dynamic.cc\"", packageName)
	w.Writeln("")
	w.Writeln("%sHandle load%sLibrary (const char * pFileName)", component.NameSpace, component.NameSpace)
	w.Writeln("{")
	w.Writeln("  %sResult nResult;", component.NameSpace)
	w.Writeln("  s%sDynamicWrapperTable * pWrapperTable = (s%sDynamicWrapperTable *) malloc (sizeof (s%sDynamicWrapperTable));", component.NameSpace, component.NameSpace, component.NameSpace)
	w.Writeln("  if (pWrapperTable != NULL) {")
	w.Writeln("    nResult = Init%sWrapperTable (pWrapperTable);", component.NameSpace)
	w.Writeln("    if (nResult != %s_SUCCESS) {", strings.ToUpper(component.NameSpace))
	w.Writeln("      free (pWrapperTable);")
	w.Writeln("      return 0;")
	w.Writeln("    }")
	w.Writeln("")
	w.Writeln("    nResult = Load%sWrapperTable (pWrapperTable, pFileName);", component.NameSpace)
	w.Writeln("    if (nResult != %s_SUCCESS) {", strings.ToUpper(component.NameSpace))
	w.Writeln("      free (pWrapperTable);")
	w.Writeln("      return 0;")
	w.Writeln("    }")
	w.Writeln("")
	w.Writeln("    return (%sHandle) pWrapperTable;", component.NameSpace)
	w.Writeln("  }")
	w.Writeln("}")
	w.Writeln("")
	w.Writeln("void unload%sLibrary (%sHandle nLibraryHandle)", component.NameSpace, component.NameSpace)
	w.Writeln("{")
	w.Writeln("  s%sDynamicWrapperTable * pWrapperTable = (s%sDynamicWrapperTable *) malloc (sizeof (s%sDynamicWrapperTable));", component.NameSpace, component.NameSpace, component.NameSpace)
	w.Writeln("  if (pWrapperTable != NULL) {")
	w.Writeln("    Release%sWrapperTable (pWrapperTable);", component.NameSpace)
	w.Writeln("    free (pWrapperTable);")
	w.Writeln("  }")
	w.Writeln("}")
	w.Writeln("")

	/* TODO!

	err = buildCFuncsForward(component, w)
	if err != nil {
		return err
	}
	*/

	err = writeGoCCalls(component, w)
	if err != nil {
		return err
	}

	w.Writeln("*/")
	w.Writeln("import \"C\"")
	w.Writeln("")
	w.Writeln("import (")
	w.Writeln("  \"fmt\"")
	w.Writeln("  \"unsafe\"")
	w.Writeln("  \"runtime\"")
	w.Writeln(")")
	w.Writeln("")
	w.Writeln("type ref = C.%sHandle", component.NameSpace)
	w.Writeln("")

	buildGoEnums(component, w)
	err = buildGoStructs(component, w)
	if err != nil {
		return err
	}

	buildGoErrorHandling(component, w, packageName)

	err = buildGoFuncs(component, w)
	if err != nil {
		return err
	}

	w.Writeln("")
	w.Writeln("// Wrapper represents the number wrapper")
	w.Writeln("type Wrapper struct {")
	w.Writeln("  _ [0]func() // uncomparable; to make == not compile")
	w.Writeln("  LibraryHandle ref")
	w.Writeln("}")

	for _, class := range component.Classes {
		err = buildGoClass(component, class, w, component.NameSpace, packageName)
		if err != nil {
			return err
		}
	}

	w.Writeln("")

	for _, method := range component.Global.Methods {
		err := writeGoMethod(method, w, component.NameSpace, packageName, "Wrapper", true)
		if err != nil {
			return err
		}
	}

	w.Writeln("func (wrapper Wrapper) releaseC(r *ref) error {")
	w.Writeln("  if r == nil || *r == nil {")
	w.Writeln("    return nil")
	w.Writeln("  }")
	w.Writeln("  return wrapper.%s(%s{Ref: *r})", component.Global.ReleaseMethod, component.Global.BaseClassName)
	w.Writeln("}")
	w.Writeln("")
	w.Writeln("func (wrapper Wrapper) CheckBinaryVersion() error {")
	w.Writeln("  var nBindingMajor uint32 = %d;", majorVersion(component.Version))
	w.Writeln("  var nBindingMinor uint32 = %d;", minorVersion(component.Version))
	w.Writeln("  nMajor, nMinor, _, err := wrapper.%s()", component.Global.VersionMethod)
	w.Writeln("  if err != nil {")
	w.Writeln("    return err;")
	w.Writeln("  }")
	w.Writeln("  if (nMajor != nBindingMajor) || (nMinor < nBindingMinor) {")
	w.Writeln("    return makeError(0)")
	w.Writeln("  }")
	w.Writeln("  return nil")
	w.Writeln("}")
	w.Writeln("")

	w.Writeln("func LoadLibrary (libraryPath string) (Wrapper, error) {")
	w.Writeln("  var wrapper Wrapper;")
	w.Writeln("  wrapper.LibraryHandle = C.load%sLibrary (C.CString (libraryPath));", component.NameSpace)
	w.Writeln("  if (wrapper.LibraryHandle == nil) {")
	w.Writeln("    return wrapper, makeError (%s_ERROR_COULDNOTLOADLIBRARY)", strings.ToUpper(component.NameSpace))
	w.Writeln("  }")
	w.Writeln("  ")
	w.Writeln("  return wrapper, nil")
	w.Writeln("  ")
	w.Writeln("}")

	return nil
}

type goType struct {
	Type  string
	CType string
	CToGo string
	GoToC string
	Empty string
}

func getGoType(paramType, namespace, paramClass, paramName string, isPtr bool) (tp goType, err error) {
	var ptrStr string
	if isPtr {
		ptrStr = "*"
	}
	switch paramType {
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "uintptr":
		tp.Type = ptrStr + paramType
		tp.CType = fmt.Sprintf("%sC.%s_t", ptrStr, paramType)
		if isPtr {
			tp.CToGo = fmt.Sprintf("(%s)(%s)", tp.Type, paramName)
			tp.GoToC = fmt.Sprintf("(%s)(%s)", tp.CType, paramName)
		} else {
			tp.CToGo = fmt.Sprintf("%s(%s)", tp.Type, paramName)
			tp.GoToC = fmt.Sprintf("%s(%s)", tp.CType, paramName)
			tp.Empty = "0"
		}
	case "bool":
		tp.Type = ptrStr + paramType
		tp.CType = fmt.Sprintf("%sC.%s", ptrStr, paramType)
		if isPtr {
			tp.CToGo = fmt.Sprintf("(%s)(%s)", tp.Type, paramName)
			tp.GoToC = fmt.Sprintf("(%s)(%s)", tp.CType, paramName)
		} else {
			tp.CToGo = fmt.Sprintf("%s(%s)", tp.Type, paramName)
			tp.GoToC = fmt.Sprintf("%s(%s)", tp.CType, paramName)
			tp.Empty = "false"
		}
	case "single":
		tp.Type = ptrStr + "float32"
		tp.CType = ptrStr + "C.float"
		if isPtr {
			tp.CToGo = fmt.Sprintf("(%s)(%s)", tp.Type, paramName)
			tp.GoToC = fmt.Sprintf("(%s)(%s)", tp.CType, paramName)
		} else {
			tp.CToGo = fmt.Sprintf("%s(%s)", tp.Type, paramName)
			tp.GoToC = fmt.Sprintf("%s(%s)", tp.CType, paramName)
			tp.Empty = "0"
		}
	case "double":
		tp.Type = ptrStr + "float64"
		tp.CType = ptrStr + "C.double"
		if isPtr {
			tp.CToGo = fmt.Sprintf("(%s)(%s)", tp.Type, paramName)
			tp.GoToC = fmt.Sprintf("(%s)(%s)", tp.CType, paramName)
		} else {
			tp.CToGo = fmt.Sprintf("%s(%s)", tp.Type, paramName)
			tp.GoToC = fmt.Sprintf("%s(%s)", tp.CType, paramName)
			tp.Empty = "0"
		}
	case "string":
		tp.Type = ptrStr + "string"
		tp.CType = ptrStr + "*C.char"
		tp.CToGo = ""
		tp.GoToC = fmt.Sprintf("(%s)(unsafe.Pointer(&[]byte(%s)[0]))", tp.CType, paramName)
		tp.Empty = "\"\""
	case "pointer":
		tp.Type = "uint64"
		tp.CType = fmt.Sprintf("C.uint64_t")
		tp.CToGo = fmt.Sprintf("%s(%s)", tp.Type, paramName)
		tp.GoToC = fmt.Sprintf("(%s)(%s)", tp.CType, paramName)
		tp.Empty = "0"
	case "enum":
		tp.Type = ptrStr + paramClass
		tp.CType = fmt.Sprintf("%sC.e%s%s", ptrStr, namespace, paramClass)
		if isPtr {
			tp.CToGo = fmt.Sprintf("(*%s)(%s)", tp.Type, paramName)
			tp.GoToC = fmt.Sprintf("(*%s)(%s)", tp.CType, paramName)
		} else {
			tp.CToGo = fmt.Sprintf("%s(%s)", tp.Type, paramName)
			tp.GoToC = fmt.Sprintf("%s(%s)", tp.CType, paramName)
			tp.Empty = "0"
		}
	case "struct":
		tp.Type = ptrStr + paramClass
		tp.CType = fmt.Sprintf("%sC.s%s%s", ptrStr, namespace, paramClass)
		if isPtr {
			tp.CToGo = fmt.Sprintf("(*%s)(unsafe.Pointer(%s))", tp.Type, paramName)
		} else {
			tp.CToGo = fmt.Sprintf("*(*%s)(unsafe.Pointer(&%s))", tp.Type, paramName)
		}
		tp.GoToC = fmt.Sprintf("(*%s)(unsafe.Pointer(&%s))", tp.CType, paramName)
		tp.Empty = paramClass + "{}"
	case "class":
		tp.Type = paramClass
		tp.CType = fmt.Sprintf("C.%s_%s", namespace, paramClass)
		tp.CToGo = ""
		tp.GoToC = fmt.Sprintf("%s.Ref", paramName)
		tp.Empty = paramClass + "{}"
	case "optionalclass":
		tp.Type = "*" + paramClass
		tp.CType = fmt.Sprintf("*C.%s_%s", namespace, paramClass)
		tp.CToGo = ""
		tp.GoToC = fmt.Sprintf("%s.Ref", paramName)
		tp.Empty = "nil"
	case "functiontype":
		tp.Type = paramClass + "Func"
		tp.CType = fmt.Sprintf("C.%s%s", namespace, paramClass)
		tp.CToGo = ""
		tp.GoToC = fmt.Sprintf("(%s)(unsafe.Pointer(C.%s%s_cgo))", tp.CType, namespace, paramClass)
		tp.Empty = "0"
	case "structarray":
		tp.Type = fmt.Sprintf("[]%s", paramClass)
		tp.CType = fmt.Sprintf("*C.s%s%s", namespace, paramClass)
		tp.CToGo = fmt.Sprintf("(%s)(unsafe.Pointer(&%s[0]))", tp.Type, paramName)
		tp.GoToC = fmt.Sprintf("(%s)(unsafe.Pointer(&%s[0]))", tp.CType, paramName)
		tp.Empty = "nil"
	case "basicarray":
		btp, err := getGoType(paramClass, namespace, paramClass, paramName, false)
		if err != nil {
			return goType{}, err
		}
		tp.Type = ptrStr + fmt.Sprintf("[]%s", btp.Type)
		tp.CType = fmt.Sprintf("*%s", btp.CType)
		tp.CToGo = fmt.Sprintf("([]%s)(unsafe.Pointer(&%s[0]))", tp.Type, paramName)
		tp.GoToC = fmt.Sprintf("(%s)(unsafe.Pointer(&%s[0]))", tp.CType, paramName)
		tp.Empty = "nil"
	default:
		err = errors.New("Invalid basic type: " + paramType)
	}
	if isPtr {
		tp.Empty = "nil"
	}
	return
}

func endWithDot(s string) string {
	if !strings.HasSuffix(s, ".") {
		s += "."
	}
	return s
}

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}

func toGoParam(s string) string {
	s = lowerFirst(s)
	// https://golang.org/ref/spec#Keywords and ref
	switch s {
	case "break", "default", "func", "interface", "select", "case", "defer", "go", "map", "struct", "chan",
		"else", "goto", "package", "switch", "const", "fallthrough", "if", "range", "type", "continue", "for",
		"import", "return", "var", "ref":
		s = "_" + s
	}
	return s
}

func writeGoMethod(method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, packageName string, className string, isGlobal bool) error {

	var errorReturn []string
	var requiresInitCall bool
	var returnValues []string
	var callParameters []string
	var initCallParameters []string
	var initCallLines []string
	var classReturnTypes []string
	var parameters []string
	var declarations []string
	var preOKReturn []string

	for _, param := range method.Params {
		param.ParamName = toGoParam(param.ParamName)
		tp, err := getGoType(param.ParamType, NameSpace, param.ParamClass, param.ParamName, false)
		if err != nil {
			return err
		}
		switch param.ParamPass {
		case "in":
			parameters = append(parameters, fmt.Sprintf("%s %s", param.ParamName, tp.Type))
			if param.ParamType == "basicarray" || param.ParamType == "structarray" {
				callParam := fmt.Sprintf("C.uint64_t(len(%s))", param.ParamName)
				callParameters = append(callParameters, callParam)
				initCallParameters = append(initCallParameters, callParam)
			} else if param.ParamType == "functiontype" {
				preOKReturn = append(preOKReturn, fmt.Sprintf("%sFunc = %s", lowerFirst(param.ParamClass), param.ParamName))
			}
			callParameters = append(callParameters, tp.GoToC)
			initCallParameters = append(initCallParameters, tp.GoToC)

		case "out", "return":
			classReturnTypes = append(classReturnTypes, tp.Type)
			errorReturn = append(errorReturn, tp.Empty)
			switch param.ParamType {
			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64",
				"pointer", "bool", "single", "double", "enum", "functiontype", "struct":
				declarations = append(declarations, fmt.Sprintf("var %s %s", param.ParamName, tp.CType))
				callParam := fmt.Sprintf("&%s", param.ParamName)
				callParameters = append(callParameters, callParam)
				initCallParameters = append(initCallParameters, callParam)

				returnValues = append(returnValues, tp.CToGo)

			case "string":
				requiresInitCall = true
				declarations = append(declarations, fmt.Sprintf("var neededfor%s C.uint32_t", param.ParamName))
				declarations = append(declarations, fmt.Sprintf("var filledin%s C.uint32_t", param.ParamName))

				initCallParameters = append(initCallParameters, fmt.Sprintf("0, &neededfor%s, nil", param.ParamName))
				callParameters = append(callParameters, fmt.Sprintf("bufferSize%s, &filledin%s, (%s)(unsafe.Pointer(&buffer%s[0]))", param.ParamName, param.ParamName, tp.CType, param.ParamName))

				initCallLines = append(initCallLines, fmt.Sprintf("bufferSize%s := neededfor%s", param.ParamName, param.ParamName))
				initCallLines = append(initCallLines, fmt.Sprintf("buffer%s := make([]byte, bufferSize%s)", param.ParamName, param.ParamName))

				returnValues = append(returnValues, fmt.Sprintf("string(buffer%s[:(filledin%s-1)])", param.ParamName, param.ParamName))

			case "basicarray", "structarray":
				parameters = append(parameters, fmt.Sprintf("%s %s", param.ParamName, tp.Type))

				requiresInitCall = true
				needSizeVar := fmt.Sprintf("neededfor%s", param.ParamName)
				declarations = append(declarations, fmt.Sprintf("var %s C.uint64_t", needSizeVar))

				initCallLines = append(initCallLines, fmt.Sprintf("if len(%s) < int(%s) {", param.ParamName, needSizeVar))
				initCallLines = append(initCallLines, fmt.Sprintf(" %s = append(%s, make(%s, int(%s)-len(%s))...)", param.ParamName, param.ParamName, tp.Type, needSizeVar, param.ParamName))
				initCallLines = append(initCallLines, "}")
				initCallParameters = append(initCallParameters, fmt.Sprintf("0, &%s, nil", needSizeVar))
				callParameters = append(callParameters, fmt.Sprintf("%s, nil, (%s)(unsafe.Pointer(&%s[0]))", needSizeVar, tp.CType, param.ParamName))

				returnValues = append(returnValues, fmt.Sprintf("%s[:int(%s)]", param.ParamName, needSizeVar))

			case "class", "optionalclass":
				declarations = append(declarations, fmt.Sprintf("var %s ref", param.ParamName))
				callParam := fmt.Sprintf("&%s", param.ParamName)
				callParameters = append(callParameters, callParam)
				initCallParameters = append(initCallParameters, callParam)
				if param.ParamType == "optionalclass" {
					preOKReturn = append(preOKReturn, fmt.Sprintf("var _%sPtr %s", param.ParamName, tp.Type))
					preOKReturn = append(preOKReturn, fmt.Sprintf("if %s == nil {", param.ParamName))

					if isGlobal {
						preOKReturn = append(preOKReturn, fmt.Sprintf("  _%sPtrVal := wrapper.New%s(%s)", param.ParamName, param.ParamClass, param.ParamName))
					} else {
						preOKReturn = append(preOKReturn, fmt.Sprintf("  _%sPtrVal := inst.wrapperRef.New%s(%s)", param.ParamName, param.ParamClass, param.ParamName))
					}
					preOKReturn = append(preOKReturn, fmt.Sprintf("  _%sPtr = &_%sPtrVal", param.ParamName, param.ParamName))
					preOKReturn = append(preOKReturn, "}")

					returnValues = append(returnValues, fmt.Sprintf("_%sPtr", param.ParamName))
				} else {

					if isGlobal {
						returnValues = append(returnValues, fmt.Sprintf("wrapper.New%s(%s)", param.ParamClass, param.ParamName))
					} else {
						returnValues = append(returnValues, fmt.Sprintf("inst.wrapperRef.New%s(%s)", param.ParamClass, param.ParamName))
					}

				}
			default:
				return fmt.Errorf("invalid method parameter type \"%s\" for %s.%s (%s)", param.ParamType, className, method.MethodName, param.ParamName)
			}

		default:
			return fmt.Errorf("invalid method parameter passing \"%s\" for %s.%s (%s)", param.ParamPass, className, method.MethodName, param.ParamName)
		}
	}

	// Implementation
	implmethodname := "C.CCall_" + packageName + "_"
	returnValues = append(returnValues, "nil")
	classReturnTypes = append(classReturnTypes, "error")
	errorReturn = append(errorReturn, "makeError(uint32(ret))")

	var returnString string
	if len(classReturnTypes) == 1 {
		returnString = "error"
	} else {
		returnString = fmt.Sprintf("(%s)", strings.Join(classReturnTypes, ", "))
	}

	w.Writeln("// %s %s", method.MethodName, endWithDot(lowerFirst(method.MethodDescription)))
	if isGlobal {
		w.Writeln("func (wrapper Wrapper) %s(%s) %s {", method.MethodName, strings.Join(parameters, ", "), returnString)
	} else {
		w.Writeln("func (inst %s) %s(%s) %s {", className, method.MethodName, strings.Join(parameters, ", "), returnString)
	}
	if !isGlobal {
		initCallParameters = append([]string{"inst.Ref"}, initCallParameters...)
		callParameters = append([]string{"inst.Ref"}, callParameters...)
		implmethodname += strings.ToLower(className) + "_"
	}
	implmethodname += strings.ToLower(method.MethodName)
	w.Writelns("  ", declarations)
	retInst := ":"
	if requiresInitCall {
		if isGlobal {
			w.Writeln("  ret := %s(wrapper.LibraryHandle, %s)", implmethodname, strings.Join(initCallParameters, ", "))
		} else {
			w.Writeln("  ret := %s(inst.wrapperRef.LibraryHandle, %s)", implmethodname, strings.Join(initCallParameters, ", "))
		}

		w.Writeln("  if ret != 0 {")
		w.Writeln("    return %s", strings.Join(errorReturn, ", "))
		w.Writeln("  }")
		w.Writelns("  ", initCallLines)
		retInst = ""
	}

	if isGlobal {
		w.Writeln("  ret %s= %s(wrapper.LibraryHandle, %s)", retInst, implmethodname, strings.Join(callParameters, ", "))
	} else {
		w.Writeln("  ret %s= %s(inst.wrapperRef.LibraryHandle, %s)", retInst, implmethodname, strings.Join(callParameters, ", "))
	}

	w.Writeln("  if ret != 0 {")
	w.Writeln("    return %s", strings.Join(errorReturn, ", "))
	w.Writeln("  }")
	w.Writelns("  ", preOKReturn)
	w.Writeln("  return %s", strings.Join(returnValues, ", "))
	w.Writeln("}")
	w.Writeln("")

	return nil
}
