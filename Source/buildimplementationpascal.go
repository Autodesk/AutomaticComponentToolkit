/*++

Copyright (C) 2018 Autodesk Inc. (Original Author)

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--*/

//////////////////////////////////////////////////////////////////////////////////////////////////////
// buildimplementationpascal .go
// functions to generate Pascal interface classes, implementation stubs and wrapper code that maps to
// the Pascal header.
//////////////////////////////////////////////////////////////////////////////////////////////////////

package main

import (
	"fmt"
	"log"
	"errors"
	"path"
	"math/rand"
	"strings"
)


// BuildImplementationPascal builds Pascal interface classes, implementation stubs and wrapper code that maps to the Pascal header
func BuildImplementationPascal(component ComponentDefinition, outputFolder string, stubOutputFolder string, projectOutputFolder string, implementation ComponentDefinitionImplementation) error {
	//doJournal := len (component.Global.JournalMethod) > 0;
	forceRecreation := false

	namespace := component.NameSpace;
	libraryname := component.LibraryName;
	baseName := component.BaseName;

	indentString := getIndentationString(implementation.Indentation)
	stubIdentifier := ""
	if len(implementation.StubIdentifier) > 0 {
		stubIdentifier = "_" + strings.ToLower(implementation.StubIdentifier)
	}
	
	if (stubIdentifier == "") {
		return errors.New ("pascal Stub Identifier must not be empty");
	}
	

	IntfWrapperTypesName := path.Join(outputFolder, baseName+"_types.pas");
	log.Printf("Creating \"%s\"", IntfWrapperTypesName)
	typesWrapperfile, err := CreateLanguageFile(IntfWrapperTypesName, indentString)
	if err != nil {
		return err
	}
	typesWrapperfile.WritePascalLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Pascal type definition file in order to allow easy\ndevelopment of %s. The functions in this file need to be implemented. It needs to be generated only once.", libraryname),
		true)
	buildPascalTypeDefinition (component, typesWrapperfile, namespace, baseName);


	IntfWrapperExceptionName := path.Join(outputFolder, baseName+"_exception.pas");
	log.Printf("Creating \"%s\"", IntfWrapperExceptionName)
	exceptionWrapperfile, err := CreateLanguageFile(IntfWrapperExceptionName, indentString)
	if err != nil {
		return err
	}
	exceptionWrapperfile.WritePascalLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Pascal exception class definition file in order to allow easy\ndevelopment of %s. The functions in this file need to be implemented. It needs to be generated only once.", libraryname),
		true)
	buildPascalExceptionDefinition (component, exceptionWrapperfile, namespace, baseName);
	

	IntfWrapperInterfaceName := path.Join(outputFolder, baseName+"_interfaces.pas");
	log.Printf("Creating \"%s\"", IntfWrapperInterfaceName)
	interfaceWrapperfile, err := CreateLanguageFile(IntfWrapperInterfaceName, indentString)
	if err != nil {
		return err
	}
	interfaceWrapperfile.WritePascalLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Pascal interface definition file in order to allow easy\ndevelopment of %s. The functions in this file need to be implemented. It needs to be generated only once.", libraryname),
		true)
	buildPascalInterfaceDefinition (component, interfaceWrapperfile, namespace, baseName);


	IntfWrapperExportName := path.Join(outputFolder, baseName+"_exports.pas");
	log.Printf("Creating \"%s\"", IntfWrapperExportName)
	exportWrapperfile, err := CreateLanguageFile(IntfWrapperExportName, indentString)
	if err != nil {
		return err
	}
	exportWrapperfile.WritePascalLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Pascal export implementation file in order to allow easy\ndevelopment of %s. The functions in this file need to be implemented. It needs to be generated only once.", libraryname),
		true)
		
	buildPascalExportsDefinition (component, exportWrapperfile, namespace, baseName, stubIdentifier, implementation.ClassIdentifier);
	
	IntfWrapperStubName := path.Join(stubOutputFolder, baseName + stubIdentifier + ".pas")
	if forceRecreation || (!FileExists(IntfWrapperStubName) ) {
		log.Printf("Creating \"%s\"", IntfWrapperStubName)
		templatefile, err := CreateLanguageFile (IntfWrapperStubName, indentString)
		if err != nil {
			return err
		}
		templatefile.WritePascalLicenseHeader(component,
			fmt.Sprintf("This is an autogenerated Pascal implementation file in order to allow easy\ndevelopment of %s. It needs to be generated only once.", libraryname),
			true)
		
		err = buildStubImplementation (component, templatefile, namespace, baseName, stubIdentifier);
		if err != nil {
			return err
		}
	} else {
		log.Printf("Omitting recreation of Stub implementation \"%s\"", IntfWrapperStubName)
	}
	
	
	IntfWrapperLPIName := path.Join(projectOutputFolder, baseName+".lpi");
	log.Printf("Creating \"%s\"", IntfWrapperLPIName)
	lpifile, err := CreateLanguageFile (IntfWrapperLPIName, indentString)
	if err != nil {
		return err
	}
	err = buildLPIImplementation (component, lpifile, namespace, baseName);
	if err != nil {
		return err
	}

	
	IntfWrapperLPRName := path.Join(outputFolder, baseName+".lpr");
	log.Printf("Creating \"%s\"", IntfWrapperLPRName)
	lprfile, err := CreateLanguageFile (IntfWrapperLPRName, indentString)
	if err != nil {
		return err
	}
	lprfile.WritePascalLicenseHeader(component,
		fmt.Sprintf("This is an autogenerated Pascal project file in order to allow easy\ndevelopment of %s.", libraryname),
		true);
	err = buildLPRImplementation (component, lprfile, namespace, baseName);
	if err != nil {
		return err
	}

	defFileName := path.Join(projectOutputFolder, baseName+".def");
	log.Printf("Creating \"%s\"", defFileName)
	defFile, err := CreateLanguageFile (defFileName, "")
	if err != nil {
		return err
	}
	err = buildDefFile(component, defFile, namespace)
	if err != nil {
		return err
	}

	err = buildPascalStub(component, namespace, implementation.ClassIdentifier, baseName, stubOutputFolder, indentString, stubIdentifier, forceRecreation)
	if err != nil {
		return err
	}

	return nil
}

// buildDefFile writes a module definition file with all exported functions
func buildDefFile(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string) error {
	w.Writeln("EXPORTS")
	global := componentdefinition.Global;
	for _, method := range global.Methods {
		w.Writeln("%s_%s", strings.ToLower(NameSpace), strings.ToLower(method.MethodName))
	}
	for _, class := range componentdefinition.Classes {
		for _, method := range class.Methods {
			w.Writeln("%s_%s_%s", strings.ToLower(NameSpace), strings.ToLower(class.ClassName), strings.ToLower(method.MethodName))
		}
	}
	return nil
}


func buildPascalTypeDefinition(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln ("{$MODE DELPHI}");
	w.Writeln ("unit %s_types;", BaseName);
	w.Writeln ("");
	w.Writeln ("interface");
	w.Writeln ("");
	w.Writeln ("uses");

	w.Writeln ("  Classes,");
	w.Writeln ("  sysutils;");
	w.Writeln ("");
	
	err := writePascalBaseTypeDefinitions (componentdefinition, w, NameSpace, BaseName);
	if (err != nil) {
		return err;
	}
	
	w.Writeln ("implementation");
	w.Writeln ("");
	
	w.Writeln ("end.");
	
	return nil;

}



func buildPascalExceptionDefinition(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln ("{$MODE DELPHI}");
	w.Writeln ("unit %s_exception;", BaseName);
	w.Writeln ("");
	w.Writeln ("interface");
	w.Writeln ("");
	w.Writeln ("uses");

	w.Writeln ("  %s_types,", BaseName);
	w.Writeln ("  Classes,");
	w.Writeln ("  sysutils;");
	w.Writeln ("");
	w.Writeln ("type");
	w.Writeln ("  E%sException = class (Exception)", NameSpace);
	w.Writeln ("  private");
	w.Writeln ("    FErrorCode: T%sResult;", NameSpace);
	w.Writeln ("    FCustomMessage: String;");	
	w.Writeln ("  public");
	w.Writeln ("    property ErrorCode: T%sResult read FErrorCode;", NameSpace);
	w.Writeln ("    property CustomMessage: String read FCustomMessage;");	
	w.Writeln ("    constructor Create (AErrorCode: T%sResult);", NameSpace);
	w.Writeln ("    constructor CreateCustomMessage (AErrorCode: T%sResult; AMessage: String);", NameSpace);	
	w.Writeln ("  end;");
	w.Writeln ("")
	w.Writeln ("")
		
	w.Writeln ("implementation");
	w.Writeln ("");
	w.Writeln ("  constructor E%sException.Create (AErrorCode: T%sResult);", NameSpace, NameSpace);
	w.Writeln ("  var");	
	w.Writeln ("    ADescription: String;");	
	w.Writeln ("  begin");	
	w.Writeln ("    FErrorCode := AErrorCode;");	
	w.Writeln ("    case FErrorCode of");	
	
	for _, error := range componentdefinition.Errors.Errors {
		w.Writeln ("      %s_ERROR_%s: ADescription := '%s';", strings.ToUpper (NameSpace), error.Name, error.Description);		
	}
	
	w.Writeln ("      else");		
	w.Writeln ("        ADescription := 'unknown';");	
	w.Writeln ("    end;");	
	w.Writeln ("")
	w.Writeln ("    inherited Create (Format ('%s Error - %%s (#%%d)', [ ADescription, AErrorCode ]));", componentdefinition.LibraryName);	
	w.Writeln ("  end;");	
	w.Writeln ("")
	w.Writeln ("  constructor E%sException.CreateCustomMessage (AErrorCode: T%sResult; AMessage: String);", NameSpace, NameSpace);	
	w.Writeln ("  begin");	
	w.Writeln ("    FCustomMessage := AMessage;");	
	w.Writeln ("    FErrorCode := AErrorCode;");	
	w.Writeln ("    inherited Create (Format ('%%s (%%d)', [FCustomMessage, AErrorCode]));");	
	w.Writeln ("  end;");	
	w.Writeln ("")

	w.Writeln ("end.");
	
	return nil;

}


func createRandomUUID () (string, error) {

	u := make([]byte, 16)
	
	_, err := rand.Read(u)
	if err != nil {
		return "", err
	}

	u[8] = (u[8] | 0x80) & 0xBF // what does this do?
	u[6] = (u[6] | 0x40) & 0x4F // what does this do?

	uuid := fmt.Sprintf("%X-%X-%X-%X-%X", u[0:4], u[4:6], u[6:8], u[8:10], u[10:]);
	
	return uuid, nil;
	
}

func buildPascalInterfaceDefinition(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln ("{$MODE DELPHI}");
	w.Writeln ("{$INTERFACES CORBA}");
	
	w.Writeln ("unit %s_interfaces;", BaseName);
	w.Writeln ("");
	w.Writeln ("interface");
	w.Writeln ("");
	w.Writeln ("uses");

	w.Writeln ("  %s_types,", BaseName);
	if (len(componentdefinition.Enums) > 0) {
		// Unit contains enums conversion that may raise exceptions
		w.Writeln ("  %s_exception,", BaseName);
	}
	w.Writeln ("  Classes,");
	w.Writeln ("  sysutils;");
	w.Writeln ("");
	
	writeEnumConversionInterface (componentdefinition, w, NameSpace);

	w.Writeln ("")
	w.Writeln ("(*************************************************************************************************************************")
	w.Writeln (" Interface definition for BaseClass")
	w.Writeln ("**************************************************************************************************************************)")
	w.Writeln ("");
	w.Writeln ("type");
	w.Writeln ("  I%sBaseClass = interface", NameSpace);	
	
	uuid, err := createRandomUUID ();
	if err != nil {
		return err
	}	
	w.Writeln ("    ['{%s}']", uuid);
	
	w.Writeln ("  end;");
	w.Writeln ("")

	
	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		w.Writeln ("")
		w.Writeln ("(*************************************************************************************************************************")
		w.Writeln (" Interface definition for %s", class.ClassName)
		w.Writeln ("**************************************************************************************************************************)")
		w.Writeln ("");
		
		parentClassName := class.ParentClass
		if parentClassName == "" {
			parentClassName = "BaseClass"
		}
		

		w.Writeln ("  I%s%s = interface (I%s%s)", NameSpace, class.ClassName, NameSpace, parentClassName);	
		uuid, err := createRandomUUID ();
		if err != nil {
			return err
		}	
		w.Writeln ("    ['{%s}']", uuid);
		w.Writeln ("");
		
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			w.AddIndentationLevel(2)
			err := writePascalImplClassMethodDefinition(method, w, NameSpace, class.ClassName, false)
			w.AddIndentationLevel(-2)
			if err != nil {
				return err;
			}
		}
		
		w.Writeln ("  end;");	
		w.Writeln ("")

	}
	
	w.Writeln ("implementation");
	w.Writeln ("");

	writeEnumConversionImplementation (componentdefinition, w, NameSpace);
	
	w.Writeln ("end.");
	
	return nil;

}


func writePascalExportDefinition (method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, isGlobal bool, doComment bool) (error) {

	PascalExportName := GetCExportName (NameSpace, ClassName, method, isGlobal);

	parameters := "";
	if (isGlobal) {
	} else {
		parameters = fmt.Sprintf ("p%s: T%sHandle", ClassName, NameSpace);
	}

	if (doComment) {
		w.Writeln("(**");
		w.Writeln("* %s", method.MethodDescription);
		w.Writeln("*");
		if (!isGlobal) {
			w.Writeln("* @param[in] p%s - %s instance.", ClassName, ClassName);
		}
	}
	

	for k := 0; k < len(method.Params); k++ {
		param := method.Params [k];
		
		pascalParams, err := generatePlainPascalParameter(param, ClassName, method.MethodName, NameSpace);
		if (err != nil) {
			return err;
		}

		for _, pascalParam := range pascalParams {
			if (doComment) {
				w.Writeln(pascalParam.ParamComment);
			}
			if (parameters != "") {
				parameters = parameters + "; ";
			}
			parameters = parameters + pascalParam.ParamName + ": " + pascalParam.ParamTypeNoConvention;
		}

	}

	if (doComment) {
		w.Writeln("* @return error code or 0 (success)");
		w.Writeln("*)");
	}
	
	w.Writeln ("function %s (%s): T%sResult; cdecl;", PascalExportName, parameters, NameSpace);
	
	return nil;
}


func generatePrePostCallPascalFunctionCode(method ComponentDefinitionMethod, NameSpace string, ClassIdentifier string, ClassName string) ([]string, []string, []string, []string, string, string, error) {
	variableDefinitions := make([]string, 0);
	preCallCode := make([]string, 0);
	postCallCode := make([]string, 0);
	checkInputCode := make([]string, 0);	
	callParameters := "";
	resultVariable := "";
	
	for k := 0; k < len(method.Params); k++ {
		param := method.Params[k]
		
		pascalParams, err := generatePlainPascalParameter(param, ClassName, method.MethodName, NameSpace);
		if (err != nil) {
			return make([]string, 0), make([]string, 0), make([]string, 0), make([]string, 0), "", "", err;
		}

		switch param.ParamPass {
		case "in":
			if callParameters != "" {
				callParameters = callParameters + ", "
			}
			switch param.ParamType {
			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double":
				callParameters = callParameters + pascalParams[0].ParamName
			case "bool":
				callParameters = callParameters + pascalParams[0].ParamName + " <> 0"
			case "enum":
				callParameters = callParameters + "convertConstTo" + param.ParamClass + " (" + pascalParams[0].ParamName + ")"
			case "struct":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if not Assigned (%s) then", pascalParams[0].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))
				
				callParameters = callParameters + pascalParams[0].ParamName + "^";
				
			case "basicarray", "structarray":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if ((not Assigned (%s)) and (%s>0)) then", pascalParams[1].ParamName, pascalParams[0].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))
				
				callParameters = callParameters + fmt.Sprintf("%s, %s", pascalParams[0].ParamName, pascalParams[1].ParamName)

			case "handle":
				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Object%s: TObject;", param.ParamName));
				checkInputCode = append (checkInputCode, fmt.Sprintf("Object%s := TObject (%s);", param.ParamName, pascalParams[0].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("if (not Supports (Object%s, I%s%s)) then", param.ParamName, NameSpace, param.ParamClass))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDCAST);", NameSpace, strings.ToUpper(NameSpace)))
				checkInputCode = append (checkInputCode, "");
								
				callParameters = callParameters + fmt.Sprintf("Object%s", param.ParamName)
				
			case "string":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if (not Assigned (%s)) then", pascalParams[0].ParamName));
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)));
								
				callParameters = callParameters + "StrPas (" + pascalParams[0].ParamName + ")";

			case "functiontype":
				callParameters = callParameters + pascalParams[0].ParamName

			default:
				return make([]string, 0), make([]string, 0), make([]string, 0), make([]string, 0), "", "", fmt.Errorf("method parameter type \"%s\" of param pass \"%s\" is not implemented for %s::%s(%s) )", param.ParamType, param.ParamPass, ClassName, method.MethodName, param.ParamName)
			}

		case "out":
			if callParameters != "" {
				callParameters = callParameters + ", "
			}

			switch param.ParamType {

			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double", "struct":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if (not Assigned (%s)) then", pascalParams[0].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);\n", NameSpace, strings.ToUpper(NameSpace)))

				callParameters = callParameters + pascalParams[0].ParamName + "^";

			case "enum":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if not Assigned (%s) then", pascalParams[0].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))

				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Result%s: T%s%s;", param.ParamName, NameSpace, param.ParamClass));

				callParameters = callParameters + fmt.Sprintf ("Result%s", param.ParamName);

				postCallCode = append (postCallCode, fmt.Sprintf("%s^ := convert%sToConst (Result%s);", pascalParams[0].ParamName, param.ParamClass, param.ParamName))

			case "bool":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if not Assigned (%s) then", pascalParams[0].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))

				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Result%s: Boolean;", param.ParamName));

				callParameters = callParameters + fmt.Sprintf ("Result%s", param.ParamName);

				postCallCode = append (postCallCode, fmt.Sprintf("%s^ := Ord (Result%s);", pascalParams[0].ParamName, param.ParamName))
								
			case "basicarray", "structarray":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if ((not Assigned (%s)) and (not Assigned(%s))) then", pascalParams[1].ParamName, pascalParams[2].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))

				callParameters = callParameters + fmt.Sprintf("%s, %s, %s", pascalParams[0].ParamName, pascalParams[1].ParamName, pascalParams[2].ParamName)

			case "string":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if ((not Assigned (%s)) and (not Assigned(%s))) then", pascalParams[2].ParamName, pascalParams[1].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))

				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Result%s: String;", param.ParamName));
				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Len%s: Cardinal;", param.ParamName));
				
				callParameters = callParameters + "Result" + param.ParamName;

				postCallCode = append (postCallCode, fmt.Sprintf("Len%s := Length (Result%s);", param.ParamName, param.ParamName))
				postCallCode = append (postCallCode, fmt.Sprintf("if Assigned(%s) then", pascalParams[1].ParamName))
				postCallCode = append (postCallCode, fmt.Sprintf("  %s^ := Len%s;", pascalParams[1].ParamName, param.ParamName));

				postCallCode = append (postCallCode, fmt.Sprintf("if Assigned(%s) then begin", pascalParams[2].ParamName))
				postCallCode = append (postCallCode, fmt.Sprintf("  if (Len%s >= %s) then", param.ParamName, pascalParams[0].ParamName));
				postCallCode = append (postCallCode, fmt.Sprintf("    raise E%sException.Create (%s_ERROR_BUFFERTOOSMALL);", NameSpace, strings.ToUpper(NameSpace)))
				postCallCode = append (postCallCode, fmt.Sprintf("  Move (PAnsiChar (Result%s)^, %s^, Len%s + 1);", param.ParamName, pascalParams[2].ParamName, param.ParamName));
				postCallCode = append (postCallCode, fmt.Sprintf("end;"));
				
			default:
				return make([]string, 0), make([]string, 0), make([]string, 0), make([]string, 0), "", "", fmt.Errorf("method parameter type \"%s\" of param pass \"%s\" is not implemented for %s::%s(%s) )", param.ParamType, param.ParamPass, ClassName, method.MethodName, param.ParamName)
			}

		case "return":

			switch param.ParamType {

			case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "single", "double":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if not Assigned (%s) then", pascalParams[0].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))

				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Result%s: %s;", param.ParamName, pascalParams[0].ParamType));

				postCallCode = append (postCallCode, fmt.Sprintf("%s^ := Result%s;", pascalParams[0].ParamName, param.ParamName))
				
				resultVariable = fmt.Sprintf("Result%s", param.ParamName);

			case "bool":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if not Assigned (%s) then", pascalParams[0].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))

				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Result%s: Boolean;", param.ParamName));

				postCallCode = append (postCallCode, fmt.Sprintf("%s^ := Ord (Result%s);", pascalParams[0].ParamName, param.ParamName))
				
				resultVariable = fmt.Sprintf("Result%s", param.ParamName);
				
			case "enum":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if not Assigned (%s) then", pascalParams[0].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))

				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Result%s: T%s%s;", param.ParamName, NameSpace, param.ParamClass));

				postCallCode = append (postCallCode, fmt.Sprintf("%s^ := convert%sToConst (Result%s);", pascalParams[0].ParamName, param.ParamClass, param.ParamName))
				
				resultVariable = fmt.Sprintf("Result%s", param.ParamName);
				
			case "struct":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if not Assigned (%s) then", pascalParams[0].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))

				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Result%s: T%s%s;", param.ParamName, NameSpace, param.ParamClass));

				postCallCode = append (postCallCode, fmt.Sprintf("%s^ := Result%s;", pascalParams[0].ParamName, param.ParamName))
				
				resultVariable = fmt.Sprintf("Result%s", param.ParamName);

			case "string":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if ((not Assigned (%s)) and (not Assigned(%s))) then", pascalParams[2].ParamName, pascalParams[1].ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))

				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Result%s: String;", param.ParamName));
				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Len%s: Cardinal;", param.ParamName));
				
				resultVariable = fmt.Sprintf("Result%s", param.ParamName);

				postCallCode = append (postCallCode, fmt.Sprintf("Len%s := Length (Result%s);", param.ParamName, param.ParamName))
				postCallCode = append (postCallCode, fmt.Sprintf("if Assigned(%s) then", pascalParams[1].ParamName))
				postCallCode = append (postCallCode, fmt.Sprintf("  %s^ := Len%s;", pascalParams[1].ParamName, param.ParamName));

				postCallCode = append (postCallCode, fmt.Sprintf("if Assigned(%s) then begin", pascalParams[2].ParamName))
				postCallCode = append (postCallCode, fmt.Sprintf("  if (Len%s >= %s) then", param.ParamName, pascalParams[0].ParamName));
				postCallCode = append (postCallCode, fmt.Sprintf("    raise E%sException.Create (%s_ERROR_BUFFERTOOSMALL);", NameSpace, strings.ToUpper(NameSpace)))
				postCallCode = append (postCallCode, fmt.Sprintf("  Move (PAnsiChar (Result%s)^, %s^, Len%s + 1);", param.ParamName, pascalParams[2].ParamName, param.ParamName));
				postCallCode = append (postCallCode, fmt.Sprintf("end;"));

			case "handle":
				checkInputCode = append (checkInputCode, fmt.Sprintf("if not Assigned(p%s) then", param.ParamName))
				checkInputCode = append (checkInputCode, fmt.Sprintf("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper(NameSpace)))

				variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Result%s: TObject;", param.ParamName));

				resultVariable = fmt.Sprintf("Result%s", param.ParamName);

				postCallCode = append (postCallCode, fmt.Sprintf("%s^ := Result%s;", pascalParams[0].ParamName, param.ParamName))
				
			default:
				return make([]string, 0), make([]string, 0), make([]string, 0), make([]string, 0), "", "", fmt.Errorf("method parameter type \"%s\" of param pass \"%s\" is not implemented for %s::%s(%s) )", param.ParamType, param.ParamPass, ClassName, method.MethodName, param.ParamName)
			}

		default:
			return make([]string, 0), make([]string, 0), make([]string, 0), make([]string, 0), "", "", fmt.Errorf("invalid method parameter passing \"%s\" for %s.%s (%s)", param.ParamPass, ClassName, method.MethodName, param.ParamName)
		}
	}

	return variableDefinitions, checkInputCode, preCallCode, postCallCode, callParameters, resultVariable, nil
}



func writePascalClassExportImplementation (method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, isGlobal bool, ClassIdentifier string) (error) {

/*var
  ANumberObject: TObject;
  AInterface: ILibNumbersNumber;
  AReturnValue: Double;
begin
  try
    if not Assigned (pNumber) then
      raise ELibNumbersException.Create (LIBNUMBERS_ERROR_INVALIDPARAM);
    if not Assigned (pValue) then
      raise ELibNumbersException.Create (LIBNUMBERS_ERROR_INVALIDPARAM);

    ANumberObject := TObject (pNumber);
    if Supports (ANumberObject, ILibNumbersNumber) then begin
      AInterface := ANumberObject as ILibNumbersNumber;
      AReturnValue := AInterface.Value ();

      PValue^ := AReturnValue;
    end;

    Result := LIBNUMBERS_SUCCESS;

  except
    On E: ELibNumbersException do begin
      Result := E.getErrorCode ();
    end;
    On E: Exception do begin
      Result := LIBNUMBERS_ERROR_GENERICEXCEPTION;
    end;
  end;
end; */


	variableDefinitions, parameterChecks, preCallCode, postCallCode, callParameters, resultVariable, err := generatePrePostCallPascalFunctionCode (method, NameSpace, ClassIdentifier, ClassName)
	if (err != nil) {
		return err;
	}
	
	
	if (!isGlobal) {
		// Define variables
		variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Object%s: TObject;", ClassName));
		variableDefinitions = append (variableDefinitions, fmt.Sprintf ("  Intf%s: I%s%s;", ClassName, NameSpace, ClassName));	
	
		parameterChecks = append (parameterChecks, fmt.Sprintf ("if not Assigned (p%s) then", ClassName));
		parameterChecks = append (parameterChecks, fmt.Sprintf ("  raise E%sException.Create (%s_ERROR_INVALIDPARAM);", NameSpace, strings.ToUpper (NameSpace)));
	}
	
	
	if (len (variableDefinitions) > 0) {
		w.Writeln("var");
		w.Writelns("", variableDefinitions);
	}
	w.Writeln("begin");
	w.Writeln("  try");
	w.Writelns ("    ", parameterChecks);
	
	w.Writeln ("");
	if (!isGlobal) {
		w.Writeln ("    Object%s := TObject (p%s);", ClassName, ClassName);
		w.Writeln ("    if Supports (Object%s, I%s%s) then begin", ClassName, NameSpace, ClassName);
		w.Writeln ("      Intf%s := Object%s as I%s%s;", ClassName, ClassName, NameSpace, ClassName);
	}
	
	w.Writelns("", preCallCode);

	resultVariableAssignment := "";
	if (resultVariable != "") {
		resultVariableAssignment = resultVariable + " := ";
	}

	classInstanceSpacing := "      ";
	classInstanceToCall := "Intf" + ClassName;
	postCallCodeSpacing := "      ";
	if (isGlobal) {
		classInstanceToCall = "T" + NameSpace + "Wrapper";
		classInstanceSpacing = "    ";
		postCallCodeSpacing = "    ";
	}
	
	w.Writeln(classInstanceSpacing + "%s%s.%s(%s);", resultVariableAssignment, classInstanceToCall, method.MethodName, callParameters);
	w.Writeln("");
	
	w.Writelns (postCallCodeSpacing, postCallCode);
	
	if (!isGlobal) {
		w.Writeln ("    end else");
		w.Writeln ("      raise E%sException.Create (%s_ERROR_INVALIDCAST);", NameSpace, strings.ToUpper (NameSpace));          
		w.Writeln ("");
	}
	
	w.Writeln ("    Result := %s_SUCCESS;", strings.ToUpper (NameSpace));
	w.Writeln ("  except");
    w.Writeln ("    On E: E%sException do begin", NameSpace);
    w.Writeln ("      Result := E.ErrorCode;");
    w.Writeln ("    end;");
    w.Writeln ("    On E: Exception do begin");
    w.Writeln ("      Result := %s_ERROR_GENERICEXCEPTION;", strings.ToUpper (NameSpace));
    w.Writeln ("    end;");
	w.Writeln ("  end;");
	w.Writeln ("end;");
	w.Writeln ("");
	
	return nil;
}



func buildPascalExportsDefinition(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string, stubIdentifier string, ClassIdentifier string) error {

	global := componentdefinition.Global;

	w.Writeln ("{$MODE DELPHI}");
	w.Writeln ("unit %s_exports;", BaseName);
	w.Writeln ("");
	w.Writeln ("interface");
	w.Writeln ("");
	w.Writeln ("uses");
	w.Writeln ("  %s%s,", BaseName, stubIdentifier);
	w.Writeln ("  %s_types,", BaseName);
	w.Writeln ("  %s_interfaces,", BaseName);
	w.Writeln ("  %s_exception,", BaseName);
	w.Writeln ("  Classes,");
	w.Writeln ("  sysutils;");
	w.Writeln ("");
	
	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		w.Writeln("(*************************************************************************************************************************")
		w.Writeln(" Class export definition of %s ", class.ClassName)
		w.Writeln("**************************************************************************************************************************)")
		w.Writeln("")
		
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			
			err := writePascalExportDefinition (method, w, NameSpace, class.ClassName, false, true);
			if (err != nil) {
				return err;
			}
			
			w.Writeln ("");
		}

	}

	w.Writeln("(*************************************************************************************************************************")
	w.Writeln(" Global function export definition")
	w.Writeln("**************************************************************************************************************************)")
	w.Writeln ("");

	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		
		err := writePascalExportDefinition (method, w, NameSpace, "Wrapper", true, true);
		if (err != nil) {
			return err;
		}
		
		w.Writeln ("");
	}

	
	w.Writeln ("implementation");
	w.Writeln ("");

	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		for j := 0; j < len(class.Methods); j++ {
						
			method := class.Methods[j]
			
			err := writePascalExportDefinition (method, w, NameSpace, class.ClassName, false, false);
			if (err != nil) {
				return err;
			}
			
			err = writePascalClassExportImplementation(method, w, NameSpace, class.ClassName, false, ClassIdentifier);
			if (err != nil) {
				return err;
			}
		}

	}


	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		
		err := writePascalExportDefinition (method, w, NameSpace, "Wrapper", true, false);
		if (err != nil) {
			return err;
		}
		
		err = writePascalClassExportImplementation(method, w, NameSpace, "Wrapper", true, ClassIdentifier);
		if (err != nil) {
			return err;
		}
		
	}
	
	w.Writeln ("");
	w.Writeln ("end.");
	w.Writeln ("");
	
	return nil;

}



func buildLPRImplementation(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	global := componentdefinition.Global;

	w.Writeln ("{$MODE DELPHI}");
	w.Writeln ("library %s;", BaseName);
	w.Writeln ("");
	w.Writeln ("uses");
	w.Writeln ("{$IFDEF UNIX}");
	w.Writeln ("  cthreads,");
	w.Writeln ("{$ENDIF UNIX}");
	w.Writeln ("  syncobjs,");
	w.Writeln ("  %s_types,", BaseName);
	w.Writeln ("  %s_exports,", BaseName);
	w.Writeln ("  Classes,");
	w.Writeln ("  sysutils;");
	w.Writeln ("");
	w.Writeln ("exports");
	
	for i := 0; i < len(componentdefinition.Classes); i++ {
		class := componentdefinition.Classes[i]

		for j := 0; j < len(class.Methods); j++ {
				
			commaString := ",";
			if ((j == (len(class.Methods) - 1)) && (len(global.Methods) == 0)) {
				commaString = ";";
			}
		
			method := class.Methods[j]
			w.Writeln ("  %s%s", GetCExportName (NameSpace, class.ClassName, method, false), commaString);
		}

	}


	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		commaString := ",";
		if (j == (len(global.Methods) - 1)) {
			commaString = ";";
		}
		
		w.Writeln ("  %s%s", GetCExportName (NameSpace, "Wrapper", method, true), commaString);
	}
	
	w.Writeln ("");
	w.Writeln ("begin");
	w.Writeln ("");
	w.Writeln ("end.");
	
	return nil;
       
}




func buildLPIImplementation(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string) error {

	w.Writeln ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
	w.Writeln ("<CONFIG>");
	w.Writeln ("  <ProjectOptions>");
	w.Writeln ("    <Version Value=\"%d\"/>", 10);
	
	
	w.Writeln ("    <PathDelim Value=\"\\\"/>");
	w.Writeln ("    <General>");
	w.Writeln ("      <Flags>");
	w.Writeln ("        <MainUnitHasCreateFormStatements Value=\"False\" />");
	w.Writeln ("        <MainUnitHasTitleStatement Value=\"False\" />");
	w.Writeln ("        <MainUnitHasScaledStatement Value=\"False\" />");
	w.Writeln ("      </Flags>");
	w.Writeln ("      <SessionStorage Value=\"InProjectDir\" />");
	w.Writeln ("      <MainUnit Value=\"%d\"/>", 0);
	w.Writeln ("      <Title Value=\"%s\" />", NameSpace);
	w.Writeln ("      <UseAppBundle Value=\"False\" />");
	w.Writeln ("      <ResourceType Value=\"res\" />");
	w.Writeln ("    </General>");
	w.Writeln ("    <BuildModes Count=\"%d\">", 2);
	w.Writeln ("      <Item1 Name=\"Release\" Default=\"True\"/>");
	w.Writeln ("      <Item2 Name=\"Debug\">");
	w.Writeln ("        <CompilerOptions>");
	w.Writeln ("          <Version Value=\"11\" />");
	w.Writeln ("          <PathDelim Value=\"\\\"/>");
	w.Writeln ("          <Target>");
	w.Writeln ("            <Filename Value=\"bin\\$(TargetCPU)-$(TargetOS)\\Release\\project%s\"/>", BaseName);
	w.Writeln ("          </Target>");
	w.Writeln ("          <SearchPaths>");
	w.Writeln ("            <IncludeFiles Value=\"$(ProjOutDir)\"/>");
	w.Writeln ("            <OtherUnitFiles Value=\"Stub;Interfaces\"/>");
	w.Writeln ("            <UnitOutputDirectory Value=\"lib\\$(TargetCPU)-$(TargetOS)\"/>");
	w.Writeln ("          </SearchPaths>");
	w.Writeln ("          <Parsing>");
	w.Writeln ("            <SyntaxOptions>");
	w.Writeln ("              <IncludeAssertionCode Value=\"True\"/>");
	w.Writeln ("            </SyntaxOptions>");
	w.Writeln ("          </Parsing>");
	w.Writeln ("          <CodeGeneration>");
	w.Writeln ("            <RelocatableUnit Value=\"True\" />");
	w.Writeln ("          </CodeGeneration>");
	w.Writeln ("          <Linking>");
	w.Writeln ("            <Debugging>");
	w.Writeln ("              <UseExternalDbgSyms Value=\"True\"/>");
	w.Writeln ("            </Debugging>");
	w.Writeln ("            <Options>");
	w.Writeln ("              <ExecutableType Value=\"Library\"/>");
	w.Writeln ("            </Options>");
	w.Writeln ("          </Linking>");
	w.Writeln ("        </CompilerOptions>");
	w.Writeln ("      </Item2>");
	w.Writeln ("    </BuildModes>");
	w.Writeln ("    <PublishOptions>");
	w.Writeln ("      <Version Value=\"%d\"/>", 2);
	w.Writeln ("    </PublishOptions>");
	w.Writeln ("    <RunParams>");
	w.Writeln ("      <local>");
	w.Writeln ("        <FormatVersion Value=\"1\"/>");
	w.Writeln ("      </local>");
	w.Writeln ("    </RunParams>");
	w.Writeln ("    <Units Count=\"%d\">", 2);
	w.Writeln ("      <Unit0>");
	w.Writeln ("        <Filename Value=\"Interfaces\\%s.lpr\"/>", BaseName);
	w.Writeln ("        <IsPartOfProject Value=\"True\"/>");	
	w.Writeln ("      </Unit0>");
	w.Writeln ("      <Unit1>");
	w.Writeln ("        <Filename Value=\"Stub\\%s.pas\"/>", BaseName);
	w.Writeln ("        <IsPartOfProject Value=\"True\"/>");	
	w.Writeln ("      </Unit1>");
	w.Writeln ("    </Units>");
	w.Writeln ("  </ProjectOptions>");
	w.Writeln ("  <CompilerOptions>");
	w.Writeln ("    <Version Value=\"%d\"/>", 11);
	w.Writeln ("    <PathDelim Value=\"\\\"/>");
	w.Writeln ("    <Target>");
	w.Writeln ("      <Filename Value=\"bin\\$(TargetCPU)-$(TargetOS)\\Release\\%s\"/>", BaseName);
	w.Writeln ("    </Target>");
	w.Writeln ("    <SearchPaths>");
	w.Writeln ("      <IncludeFiles Value=\"$(ProjOutDir)\"/>");	
	w.Writeln ("      <OtherUnitFiles Value=\"Stub;Interfaces\"/>");
	w.Writeln ("      <UnitOutputDirectory Value=\"lib\\$(TargetCPU)-$(TargetOS)\"/>");
	w.Writeln ("    </SearchPaths>");
	w.Writeln ("    <Parsing>");
	w.Writeln ("      <SyntaxOptions>");
	w.Writeln ("        <IncludeAssertionCode Value=\"True\"/>");
	w.Writeln ("      </SyntaxOptions>");
	w.Writeln ("    </Parsing>");
	w.Writeln ("    <CodeGeneration>");
	w.Writeln ("      <RelocatableUnit Value=\"True\"/>");
	w.Writeln ("    </CodeGeneration>");
	w.Writeln ("    <Linking>");
	w.Writeln ("      <Debugging>");
	w.Writeln ("        <StripSymbols Value=\"True\"/>");
	w.Writeln ("        <UseExternalDbgSyms Value=\"True\"/>");
	w.Writeln ("      </Debugging>");
	w.Writeln ("      <Options>");
	w.Writeln ("        <ExecutableType Value=\"Library\"/>");
	w.Writeln ("      </Options>");
	w.Writeln ("    </Linking>");
	w.Writeln ("  </CompilerOptions>");
	w.Writeln ("  <Debugging>");
	w.Writeln ("    <Exceptions Count=\"%d\">", 3);
	w.Writeln ("      <Item1>");
	w.Writeln ("        <Name Value=\"EAbort\"/>");
	w.Writeln ("      </Item1>");
	w.Writeln ("      <Item2>");
	w.Writeln ("        <Name Value=\"ECodetoolError\"/>");
 	w.Writeln ("      </Item2>");
	w.Writeln ("      <Item3>");
	w.Writeln ("        <Name Value=\"EFOpenError\"/>");
	w.Writeln ("      </Item3>");
	w.Writeln ("    </Exceptions>");     
	w.Writeln ("  </Debugging>");
	w.Writeln ("</CONFIG>");    	
	w.Writeln ("");

	return nil;
	
}


func getPascalImplClassParameters(method ComponentDefinitionMethod, NameSpace string, ClassName string, isGlobal bool, isImplementation bool) (string, string, error) {
	parameters := "";
	returnType := "";
	
	for k := 0; k < len(method.Params); k++ {
		param := method.Params [k];
		ParamTypeName, err := getPascalParameterType(param.ParamType, NameSpace, param.ParamClass, false, isImplementation);
		if err != nil {
			return "", "", err;
		}
		
		switch (param.ParamPass) {
			case "in":
				switch (param.ParamType) {
					case "basicarray", "structarray":
						if (parameters != "") {
							parameters = parameters + "; ";
						}
						parameters = parameters + "const A" + param.ParamName  + "Count: QWord"
						parameters = parameters + "; const A" + param.ParamName + ": " + ParamTypeName
					case "handle":
						if (parameters != "") {
							parameters = parameters + "; ";
						}
						parameters = parameters + "A" + param.ParamName + ": " + ParamTypeName;
					default:
						if (parameters != "") {
							parameters = parameters + "; ";
						}
						parameters = parameters + "const A" + param.ParamName + ": " + ParamTypeName;
				}
				

			case "out":
				switch (param.ParamType) {
					case "basicarray", "structarray":
						if (parameters != "") {
							parameters = parameters + "; ";
						}
						parameters = parameters + "const A" + param.ParamName  + "Count: QWord"
						parameters = parameters + "; P" + param.ParamName  + "NeededCount: PQWord"
						parameters = parameters + "; A" + param.ParamName + ": " + ParamTypeName
					default:
						if (parameters != "") {
							parameters = parameters + "; ";
						}
						parameters = parameters + "out A" + param.ParamName + ": " + ParamTypeName;
				}

			case "return":
				if param.ParamType == "basicarray" || param.ParamType == "structarray" {
					return "", "", fmt.Errorf ("return value \"%s\" is not supported for Pascal method \"%s\"", param.ParamName, method.MethodName);
				}
				if (returnType != "") {
					return "", "", fmt.Errorf ("duplicate return value \"%s\" for Pascal method \"%s\"", param.ParamName, method.MethodName);
				}
				returnType = ParamTypeName;
		}
	}

	return parameters, returnType, nil;
}

func writePascalClassMethodDummyStub (method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, outClassName string, isGlobal bool) (error) {
	parameters, returnType, err := getPascalImplClassParameters (method, NameSpace, ClassName, isGlobal, true);
	if (err != nil) {
		return err;
	}
	
	classPrefix := "";
	if (isGlobal) {
		classPrefix = "class ";
	}

	if (returnType == "") {
		w.Writeln("%sprocedure %s.%s(%s);", classPrefix, outClassName, method.MethodName, parameters);
	} else {
		w.Writeln("%sfunction %s.%s(%s): %s;", classPrefix, outClassName, method.MethodName, parameters, returnType);
	}
	
	w.Writeln("begin");
	w.Writeln("  raise E%sException.Create (%s_ERROR_NOTIMPLEMENTED);", NameSpace, strings.ToUpper (NameSpace));
	w.Writeln("end;");
	w.Writeln("");
	
	return nil;
}




func buildPascalStub(component ComponentDefinition, NameSpace string, ClassIdentifier string, BaseName string, outputFolder string, indentString string, stubIdentifier string, forceRecreation bool) error {

	baseClassName := "T" + ClassIdentifier + NameSpace + "BaseClass"
	StubFileName := path.Join(outputFolder, BaseName + stubIdentifier + "_" +"baseclass.pas");
	if forceRecreation || !FileExists(StubFileName) {
		log.Printf("Creating \"%s\"", StubFileName)
		w, err := CreateLanguageFile(StubFileName, indentString)
		if err != nil {
			return err
		}
		w.WritePascalLicenseHeader(component,
			fmt.Sprintf("This is the class declaration of %s", baseClassName),
			false)
		
		w.Writeln ("{$MODE DELPHI}");
		w.Writeln ("unit %s%s_%s;", BaseName, stubIdentifier, strings.ToLower("BaseClass"));
		w.Writeln ("");
		w.Writeln ("interface");
		w.Writeln ("");
		w.Writeln ("uses");
		w.Writeln ("  %s_interfaces,", BaseName);
		w.Writeln ("  Classes,");
		w.Writeln ("  sysutils;");
		w.Writeln ("");

		w.Writeln ("type");
		w.Writeln ("  %s = class (TObject, I%sBaseClass)", baseClassName, NameSpace);
		w.Writeln ("  end;");
		w.Writeln ("")

		w.Writeln ("implementation");
		w.Writeln ("");
		w.Writeln ("end.");
	} else {
		log.Printf("Omitting recreation of Stub implementation for \"%s\"", baseClassName)
	}
	

	for i := 0; i < len(component.Classes); i++ {
		class := component.Classes[i]
		outClassName := "T" + ClassIdentifier + NameSpace + class.ClassName
		
		outparentClassName := "";
		
		if class.ParentClass != "" {
			outparentClassName = "T" + ClassIdentifier + NameSpace + class.ParentClass;
		} else {
			outparentClassName = baseClassName;
		}

		StubFileName := path.Join(outputFolder, BaseName + stubIdentifier + "_" +strings.ToLower(class.ClassName)+".pas");
		if !forceRecreation && ( FileExists(StubFileName) ) {
			log.Printf("Omitting recreation of Stub implementation for \"%s\"", outClassName)
			continue;
		}

		log.Printf("Creating \"%s\"", StubFileName)
		w, err := CreateLanguageFile(StubFileName, indentString)
		if err != nil {
			return err
		}
		w.WritePascalLicenseHeader(component,
			fmt.Sprintf("This is the class declaration of %s", outClassName),
			false)

		w.Writeln ("{$MODE DELPHI}");
		w.Writeln ("unit %s%s_%s;", BaseName, stubIdentifier, strings.ToLower(class.ClassName));
		w.Writeln ("");
		w.Writeln ("interface");
		w.Writeln ("");
		w.Writeln ("uses");
		w.Writeln ("  %s_types,", BaseName);
		w.Writeln ("  %s_interfaces,", BaseName);
		w.Writeln ("  %s_exception,", BaseName);
		
		if (class.ParentClass != "") {
			w.Writeln ("  %s%s_%s,", BaseName, stubIdentifier, strings.ToLower(class.ParentClass));
		} else {
			w.Writeln ("  %s%s_%s,", BaseName, stubIdentifier, strings.ToLower("BaseClass"));
		}
		
		w.Writeln ("  Classes,");
		w.Writeln ("  sysutils;");
		w.Writeln ("");
		

		w.Writeln ("type");
		w.Writeln ("  %s = class (%s, I%s%s)", outClassName, outparentClassName, NameSpace, class.ClassName);
		w.Writeln ("    private");
		w.Writeln ("");
		w.Writeln ("    protected");
		w.Writeln ("");
		w.Writeln ("    public");
		
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			w.AddIndentationLevel(3)
			err := writePascalImplClassMethodDefinition(method, w, NameSpace, class.ClassName, false)
			w.AddIndentationLevel(-3)
			if err != nil {
				return err;
			}
		}
		
		w.Writeln ("  end;");	
		w.Writeln ("")


		w.Writeln ("implementation");
		w.Writeln ("");
		
		for j := 0; j < len(class.Methods); j++ {
			method := class.Methods[j]
			err := writePascalClassMethodDummyStub(method, w, NameSpace, class.ClassName, outClassName, false);
			if err != nil {
				return err;
			}
		}

		w.Writeln ("end.");
	}

	return nil
}


func writePascalImplClassMethodDefinition (method ComponentDefinitionMethod, w LanguageWriter, NameSpace string, ClassName string, isGlobal bool) (error) {

	parameters, returnType, err := getPascalImplClassParameters (method, NameSpace, ClassName, isGlobal, true);
	if (err != nil) {
		return err;
	}
	
	classPrefix := "";
	if (isGlobal) {
		classPrefix = "class ";
	}

	if (returnType == "") {
		w.Writeln("%sprocedure %s(%s);", classPrefix, method.MethodName, parameters);
	} else {
		w.Writeln("%sfunction %s(%s): %s;", classPrefix, method.MethodName, parameters, returnType);
	}
	
	return nil;
}


func buildStubImplementation(componentdefinition ComponentDefinition, w LanguageWriter, NameSpace string, BaseName string, stubIdentifier string) error {

	global := componentdefinition.Global;

	w.Writeln ("{$MODE DELPHI}");
	w.Writeln ("Unit %s%s;", BaseName, stubIdentifier);
	w.Writeln ("");
	w.Writeln ("interface");
	w.Writeln ("");
	w.Writeln ("uses");
	w.Writeln ("  %s_types,", BaseName);
	w.Writeln ("  %s_exception,", BaseName);
	w.Writeln ("  Classes,");
	w.Writeln ("  sysutils;");
	w.Writeln ("");
	w.Writeln ("type");
	w.Writeln ("  T%sWrapper = class (TObject)", NameSpace);
	w.Writeln ("    public");
	
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		w.AddIndentationLevel(3)
		err := writePascalImplClassMethodDefinition(method, w, NameSpace, "Wrapper", true)
		w.AddIndentationLevel(-3)
		if err != nil {
			return err;
		}
	}
	
	w.Writeln ("  end;");
	w.Writeln ("");
	w.Writeln ("");
	w.Writeln ("implementation");
	w.Writeln ("");
	
	for j := 0; j < len(global.Methods); j++ {
		method := global.Methods[j]
		err := writePascalClassMethodDummyStub(method, w, NameSpace, "Wrapper", "T" + NameSpace + "Wrapper", true)
		if err != nil {
			return err;
		}
	}
	w.Writeln ("");
	
	
	w.Writeln ("end.");
	
	return nil;
}

