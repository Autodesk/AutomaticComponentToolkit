'''++

Copyright (C) 2019 Special Numbers developers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 2.0.0-develop.

Abstract: This is an autogenerated Python file in order to allow an easy
 use of Special Numbers library

Interface version: 1.0.0

'''


import ctypes
import platform
import enum
import os

import sys
# Injected Components
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), "..", "..", "..", "Numbers_component", "Bindings", "Python"))
import Numbers

name = "special"

'''Definition of domain specific exception
'''
class ESpecialException(Exception):
	def __init__(self, code, message = ''):
		self._code = code
		self._message = message
	
	def __str__(self):
		if self._message:
			return 'SpecialException ' + str(self._code) + ': '+ str(self._message)
		return 'SpecialException ' + str(self._code)

'''Definition of binding API version
'''
class BindingVersion(enum.IntEnum):
	MAJOR = 1
	MINOR = 0
	MICRO = 0

'''Definition Error Codes
'''
class ErrorCodes(enum.IntEnum):
	SUCCESS = 0
	NOTIMPLEMENTED = 1
	INVALIDPARAM = 2
	INVALIDCAST = 3
	BUFFERTOOSMALL = 4
	GENERICEXCEPTION = 5
	COULDNOTLOADLIBRARY = 6
	COULDNOTFINDLIBRARYEXPORT = 7
	INCOMPATIBLEBINARYVERSION = 8

'''Definition of Function Tables
'''
class FunctionTable:
	special_createspecialvariableasvariable = None
	special_createspecialvariable = None
	special_getsymbollookupmethod = None
	special_getlasterror = None
	special_getversion = None
	special_base_getsymbollookupmethod = None
	special_base_releaseinstance = None
	special_base_acquireinstance = None
	special_base_getversion = None
	special_base_getlasterror = None
	special_specialvariable_getspecialvalue = None

class FunctionTableBase:
	special_base_getsymbollookupmethod = None
	special_base_releaseinstance = None
	special_base_acquireinstance = None
	special_base_getversion = None
	special_base_getlasterror = None

class FunctionTableSpecialVariable:
	special_specialvariable_getspecialvalue = None


'''Extended handle type
'''
class SpecialExtendedHandle(ctypes.Structure):
	_pack_ = 1
	_fields_ = [
		('handle', ctypes.c_void_p),
		('symbolLookupMethod', ctypes.c_void_p)
	]

'''Wrapper Class Implementation
'''
class Wrapper:

# Injected Components
	_NumbersWrapper = None

	def __init__(self, libraryName = None, symbolLookupMethodAddress = None):
		ending = ''
		if platform.system() == 'Windows':
			ending = 'dll'
		elif platform.system() == 'Linux':
			ending = 'so'
		elif platform.system() == 'Darwin':
			ending = 'dylib'
		else:
			raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY)
		
		if (not libraryName) and (not symbolLookupMethodAddress):
			libraryName = os.path.join(os.path.dirname(os.path.realpath(__file__)),'special')
		
		if libraryName is not None:
			path = libraryName + '.' + ending
			try:
				self._functionTableWrapper = ctypes.CDLL(path)
			except Exception as e:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(e) + '| "'+path + '"' )
			
			self._loadFunctionTable()
		elif symbolLookupMethodAddress is not None:
				self._functionTableWrapper = self._loadFunctionTableFromMethod(symbolLookupMethodAddress)
		else:
			raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(e))
		
		self._checkBinaryVersion()
		self._SpecialWrapper = self
	
	def _loadFunctionTableFromMethod(self, symbolLookupMethodAddress):
		functionTable = FunctionTable()
		try:
			symbolLookupMethodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p))
			symbolLookupMethod = symbolLookupMethodType(int(symbolLookupMethodAddress))
			
			methodAddress = ctypes.c_void_p()
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_createspecialvariableasvariable")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_double, ctypes.POINTER(Numbers.NumbersExtendedHandle))
			functionTable.special_createspecialvariableasvariable = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_createspecialvariable")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_double, ctypes.POINTER(SpecialExtendedHandle))
			functionTable.special_createspecialvariable = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_getsymbollookupmethod")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(ctypes.c_void_p))
			functionTable.special_getsymbollookupmethod = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_getlasterror")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p, ctypes.POINTER(ctypes.c_bool))
			functionTable.special_getlasterror = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_getversion")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32))
			functionTable.special_getversion = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_base_getsymbollookupmethod")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle, ctypes.POINTER(ctypes.c_void_p))
			functionTable.special_base_getsymbollookupmethod = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_base_releaseinstance")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle)
			functionTable.special_base_releaseinstance = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_base_acquireinstance")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle)
			functionTable.special_base_acquireinstance = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_base_getversion")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle, ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32))
			functionTable.special_base_getversion = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_base_getlasterror")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p, ctypes.POINTER(ctypes.c_bool))
			functionTable.special_base_getlasterror = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_specialvariable_getspecialvalue")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle, ctypes.POINTER(ctypes.c_int64))
			functionTable.special_specialvariable_getspecialvalue = methodType(int(methodAddress.value))
			
		except AttributeError as ae:
			raise ESpecialException(ErrorCodes.COULDNOTFINDLIBRARYEXPORT, ae.args[0])
		return functionTable
		
	def _loadFunctionTable(self):
		try:
			self._functionTableWrapper.special_createspecialvariableasvariable.restype = ctypes.c_int32
			self._functionTableWrapper.special_createspecialvariableasvariable.argtypes = [ctypes.c_double, ctypes.POINTER(Numbers.NumbersExtendedHandle)]
			
			self._functionTableWrapper.special_createspecialvariable.restype = ctypes.c_int32
			self._functionTableWrapper.special_createspecialvariable.argtypes = [ctypes.c_double, ctypes.POINTER(SpecialExtendedHandle)]
			
			self._functionTableWrapper.special_getsymbollookupmethod.restype = ctypes.c_int32
			self._functionTableWrapper.special_getsymbollookupmethod.argtypes = [ctypes.POINTER(ctypes.c_void_p)]
			
			self._functionTableWrapper.special_getlasterror.restype = ctypes.c_int32
			self._functionTableWrapper.special_getlasterror.argtypes = [ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p, ctypes.POINTER(ctypes.c_bool)]
			
			self._functionTableWrapper.special_getversion.restype = ctypes.c_int32
			self._functionTableWrapper.special_getversion.argtypes = [ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32)]
			
			self._functionTableWrapper.special_base_getsymbollookupmethod.restype = ctypes.c_int32
			self._functionTableWrapper.special_base_getsymbollookupmethod.argtypes = [SpecialExtendedHandle, ctypes.POINTER(ctypes.c_void_p)]
			
			self._functionTableWrapper.special_base_releaseinstance.restype = ctypes.c_int32
			self._functionTableWrapper.special_base_releaseinstance.argtypes = [SpecialExtendedHandle]
			
			self._functionTableWrapper.special_base_acquireinstance.restype = ctypes.c_int32
			self._functionTableWrapper.special_base_acquireinstance.argtypes = [SpecialExtendedHandle]
			
			self._functionTableWrapper.special_base_getversion.restype = ctypes.c_int32
			self._functionTableWrapper.special_base_getversion.argtypes = [SpecialExtendedHandle, ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32)]
			
			self._functionTableWrapper.special_base_getlasterror.restype = ctypes.c_int32
			self._functionTableWrapper.special_base_getlasterror.argtypes = [SpecialExtendedHandle, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p, ctypes.POINTER(ctypes.c_bool)]
			
			self._functionTableWrapper.special_specialvariable_getspecialvalue.restype = ctypes.c_int32
			self._functionTableWrapper.special_specialvariable_getspecialvalue.argtypes = [SpecialExtendedHandle, ctypes.POINTER(ctypes.c_int64)]
			
		except AttributeError as ae:
			raise ESpecialException(ErrorCodes.COULDNOTFINDLIBRARYEXPORT, ae.args[0])
	
	def _checkBinaryVersion(self):
		nMajor, nMinor, _ = self.GetVersion()
		if (nMajor != BindingVersion.MAJOR) or (nMinor < BindingVersion.MINOR):
			raise ESpecialException(ErrorCodes.INCOMPATIBLEBINARYVERSION)
	
	def checkError(self, errorCode):
		if errorCode != ErrorCodes.SUCCESS.value:
			message,_ = self.GetLastError()
			raise ESpecialException(errorCode, message)
	
	def CreateSpecialVariableAsVariable(self, InitialValue):
		dInitialValue = ctypes.c_double(InitialValue)
		InstanceHandle = Numbers.NumbersExtendedHandle()
		self.checkError(self._functionTableWrapper.special_createspecialvariableasvariable(dInitialValue, InstanceHandle))
		if InstanceHandle:
			InstanceObject = Numbers.Variable(InstanceHandle)
		else:
			raise ESpecialException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return InstanceObject
	
	def CreateSpecialVariable(self, InitialValue):
		dInitialValue = ctypes.c_double(InitialValue)
		InstanceHandle = SpecialExtendedHandle()
		self.checkError(self._functionTableWrapper.special_createspecialvariable(dInitialValue, InstanceHandle))
		if InstanceHandle:
			InstanceObject = SpecialVariable(InstanceHandle)
		else:
			raise ESpecialException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return InstanceObject
	
	def GetSymbolLookupMethod(self):
		pSymbolLookupMethod = ctypes.c_void_p()
		self.checkError(self._functionTableWrapper.special_getsymbollookupmethod(pSymbolLookupMethod))
		
		return pSymbolLookupMethod.value
	
	def GetLastError(self):
		nErrorMessageBufferSize = ctypes.c_uint64(0)
		nErrorMessageNeededChars = ctypes.c_uint64(0)
		pErrorMessageBuffer = ctypes.c_char_p(None)
		pHasError = ctypes.c_bool()
		self.checkError(self._functionTableWrapper.special_getlasterror(nErrorMessageBufferSize, nErrorMessageNeededChars, pErrorMessageBuffer, pHasError))
		nErrorMessageBufferSize = ctypes.c_uint64(nErrorMessageNeededChars.value)
		pErrorMessageBuffer = (ctypes.c_char * (nErrorMessageNeededChars.value))()
		self.checkError(self._functionTableWrapper.special_getlasterror(nErrorMessageBufferSize, nErrorMessageNeededChars, pErrorMessageBuffer, pHasError))
		
		return pErrorMessageBuffer.value.decode(), pHasError.value
	
	def GetVersion(self):
		pMajor = ctypes.c_uint32()
		pMinor = ctypes.c_uint32()
		pMicro = ctypes.c_uint32()
		self.checkError(self._functionTableWrapper.special_getversion(pMajor, pMinor, pMicro))
		
		return pMajor.value, pMinor.value, pMicro.value
	


''' Class Implementation for Base
'''
class Base:
	_mapMethodToFunctionTableBase={}
	
	def __init__(self, handle):
		if not handle:
			raise ESpecialException(ErrorCodes.INVALIDPARAM)
		self._handle = handle
		self._functionTableBase = Base._lookupFunctionTableBase(handle)
		self.()
	
	def __del__(self):
		self.()
	
	def checkError(self, errorCode):
		if errorCode != ErrorCodes.SUCCESS.value:
			message,_ = self.GetLastError()
			raise ESpecialException(errorCode, message)
	

	@classmethod
	def _lookupFunctionTableBase(cls, handle):
		method = handle.symbolLookupMethod
		if not method in cls._mapMethodToFunctionTableBase:
			functionTable = cls._loadFunctionTableBaseFromMethod(method)
			cls._mapMethodToFunctionTableBase[method] = functionTable
		return cls._mapMethodToFunctionTableBase[method]

	@staticmethod
	def _loadFunctionTableBaseFromMethod(method):
		try:
			symbolLookupMethodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p))
			symbolLookupMethod = symbolLookupMethodType(int(method))
			methodAddress = ctypes.c_void_p()
			functionTable = FunctionTableBase()
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_base_getsymbollookupmethod")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle, ctypes.POINTER(ctypes.c_void_p))
			functionTable.special_base_getsymbollookupmethod = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_base_releaseinstance")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle)
			functionTable.special_base_releaseinstance = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_base_acquireinstance")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle)
			functionTable.special_base_acquireinstance = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_base_getversion")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle, ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32))
			functionTable.special_base_getversion = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_base_getlasterror")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p, ctypes.POINTER(ctypes.c_bool))
			functionTable.special_base_getlasterror = methodType(int(methodAddress.value))
			
		except AttributeError as ae:
			raise EDMKCalcException(ErrorCodes.COULDNOTFINDLIBRARYEXPORT, ae.args[0])
		return functionTable

	def GetSymbolLookupMethod(self):
		pSymbolLookupMethod = ctypes.c_void_p()
		self.checkError(self._functionTableBase.special_base_getsymbollookupmethod(self._handle, pSymbolLookupMethod))
		
		return pSymbolLookupMethod.value
	
	def ReleaseInstance(self):
		self.checkError(self._functionTableBase.special_base_releaseinstance(self._handle))
		
	
	def AcquireInstance(self):
		self.checkError(self._functionTableBase.special_base_acquireinstance(self._handle))
		
	
	def GetVersion(self):
		pMajor = ctypes.c_uint32()
		pMinor = ctypes.c_uint32()
		pMicro = ctypes.c_uint32()
		self.checkError(self._functionTableBase.special_base_getversion(self._handle, pMajor, pMinor, pMicro))
		
		return pMajor.value, pMinor.value, pMicro.value
	
	def GetLastError(self):
		nErrorMessageBufferSize = ctypes.c_uint64(0)
		nErrorMessageNeededChars = ctypes.c_uint64(0)
		pErrorMessageBuffer = ctypes.c_char_p(None)
		pHasError = ctypes.c_bool()
		self.checkError(self._functionTableBase.special_base_getlasterror(self._handle, nErrorMessageBufferSize, nErrorMessageNeededChars, pErrorMessageBuffer, pHasError))
		nErrorMessageBufferSize = ctypes.c_uint64(nErrorMessageNeededChars.value)
		pErrorMessageBuffer = (ctypes.c_char * (nErrorMessageNeededChars.value))()
		self.checkError(self._functionTableBase.special_base_getlasterror(self._handle, nErrorMessageBufferSize, nErrorMessageNeededChars, pErrorMessageBuffer, pHasError))
		
		return pErrorMessageBuffer.value.decode(), pHasError.value
	


''' Class Implementation for SpecialVariable
'''
class SpecialVariable(Numbers:Variable):
	_mapMethodToFunctionTableSpecialVariable={}
	
	def __init__(self, handle):
		Numbers:Variable.__init__(self, handle)
		self._functionTableSpecialVariable = SpecialVariable._lookupFunctionTableSpecialVariable(handle)

	@classmethod
	def _lookupFunctionTableSpecialVariable(cls, handle):
		method = handle.symbolLookupMethod
		if not method in cls._mapMethodToFunctionTableSpecialVariable:
			functionTable = cls._loadFunctionTableSpecialVariableFromMethod(method)
			cls._mapMethodToFunctionTableSpecialVariable[method] = functionTable
		return cls._mapMethodToFunctionTableSpecialVariable[method]

	@staticmethod
	def _loadFunctionTableSpecialVariableFromMethod(method):
		try:
			symbolLookupMethodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p))
			symbolLookupMethod = symbolLookupMethodType(int(method))
			methodAddress = ctypes.c_void_p()
			functionTable = FunctionTableSpecialVariable()
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("special_specialvariable_getspecialvalue")), methodAddress)
			if err != 0:
				raise ESpecialException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, SpecialExtendedHandle, ctypes.POINTER(ctypes.c_int64))
			functionTable.special_specialvariable_getspecialvalue = methodType(int(methodAddress.value))
			
		except AttributeError as ae:
			raise EDMKCalcException(ErrorCodes.COULDNOTFINDLIBRARYEXPORT, ae.args[0])
		return functionTable

	def GetSpecialValue(self):
		pValue = ctypes.c_int64()
		self.checkError(self._functionTableSpecialVariable.special_specialvariable_getspecialvalue(self._handle, pValue))
		
		return pValue.value
	
		
