/*++

Copyright (C) 2019 PrimeDevelopers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.6.0-develop.

Abstract: This is an autogenerated Go implementation file in order to allow an easy
 use of Prime Numbers Library

Interface version: 1.2.0

*/


package libprimes

// #include <string.h>
import "C"

import (
		"fmt"
		"errors"
		"syscall"
		"unsafe"
)

type LibPrimesImplementation struct {
	Initialized bool
	DLLHandle syscall.Handle
	LibPrimes_calculator_getvalue uintptr
	LibPrimes_calculator_setvalue uintptr
	LibPrimes_calculator_calculate uintptr
	LibPrimes_calculator_setprogresscallback uintptr
	LibPrimes_factorizationcalculator_getprimefactors uintptr
	LibPrimes_sievecalculator_getprimes uintptr
	LibPrimes_getversion uintptr
	LibPrimes_getlasterror uintptr
	LibPrimes_releaseinstance uintptr
	LibPrimes_createfactorizationcalculator uintptr
	LibPrimes_createsievecalculator uintptr
	LibPrimes_setjournal uintptr
}

type LibPrimesImplementationHandle interface {
	LibPrimesHandle

	GetDLLInHandle() (uintptr)
	GetDLLOutHandle() (uintptr)
	GetWrapper() (*LibPrimesImplementation)
}

type LibPrimesImplementationHandleStruct struct {
	Implementation * LibPrimesImplementation
	DLLhandle uintptr
}

func (handle *LibPrimesImplementationHandleStruct) Close() (error) {
	if (handle.DLLhandle != 0) {
		if (handle.Implementation == nil) {
			return errors.New ("Uninitialized DLL Implementation Handle")
		}
		
		dllhandle := handle.DLLhandle
		handle.DLLhandle = 0;
		
		return handle.Implementation.CallFunction(handle.Implementation.LibPrimes_releaseinstance, dllhandle)
	}
	
	return nil
}

func (handle *LibPrimesImplementationHandleStruct) GetDLLInHandle() (uintptr) {
	return handle.DLLhandle;
}

func (handle *LibPrimesImplementationHandleStruct) GetDLLOutHandle() (uintptr) {
	return uintptr (unsafe.Pointer (&handle.DLLhandle));
}

func (handle *LibPrimesImplementationHandleStruct) GetWrapper() (*LibPrimesImplementation) {
	return handle.Implementation;
}

func Int8OutValue(reference * int8) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Int8InValue(value int8) uintptr {
	return uintptr(value)
}
func Int16OutValue(reference * int16) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Int16InValue(value int16) uintptr {
	return uintptr(value)
}
func Int32OutValue(reference * int32) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Int32InValue(value int32) uintptr {
	return uintptr(value)
}
func Int64OutValue(reference * int64) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Int64InValue(value int64) uintptr {
	return uintptr(value)
}
func UInt8OutValue(reference * uint8) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func UInt8InValue(value uint8) uintptr {
	return uintptr(value)
}
func UInt16OutValue(reference * uint16) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func UInt16InValue(value uint16) uintptr {
	return uintptr(value)
}
func UInt32OutValue(reference * uint32) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func UInt32InValue(value uint32) uintptr {
	return uintptr(value)
}
func UInt64OutValue(reference * uint64) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func UInt64InValue(value uint64) uintptr {
	return uintptr(value)
}
func Float32OutValue(reference * float32) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Float32InValue(value float32) uintptr {
	return uintptr(value)
}
func Float64OutValue(reference * float64) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Float64InValue(value float64) uintptr {
	return uintptr(value)
}
func StringInValue (value string) uintptr {
	bytePtr, err := syscall.BytePtrFromString (value)
	if err != nil {
		return 0
	}
	return uintptr(unsafe.Pointer(bytePtr))
}

func PtrOutValue(ptr * uintptr) uintptr {
		return uintptr(unsafe.Pointer(ptr))
}

func BytesOutValue(bytePtr * []byte) uintptr {
		return uintptr(unsafe.Pointer(bytePtr))
}


func GetLibPrimesErrorMessage(errorcode uint32) (string) {
	switch (errorcode) {
	case 1: return "NOTIMPLEMENTED";
	case 2: return "INVALIDPARAM";
	case 3: return "INVALIDCAST";
	case 4: return "BUFFERTOOSMALL";
	case 5: return "GENERICEXCEPTION";
	case 6: return "COULDNOTLOADLIBRARY";
	case 7: return "COULDNOTFINDLIBRARYEXPORT";
	case 8: return "INCOMPATIBLEBINARYVERSION";
	case 9: return "NORESULTAVAILABLE";
	case 10: return "CALCULATIONABORTED";
	default:
		return "unknown";
	}
}


func (implementation *LibPrimesImplementation) GetWrapperHandle(handle LibPrimesHandle) (LibPrimesImplementationHandle, error) {
	implementation_handle, ok := handle.(LibPrimesImplementationHandle)
	if ok {
		handle_implementation := implementation_handle.GetWrapper()
		if (handle_implementation == implementation) {
			return implementation_handle, nil
		}
		return nil, errors.New ("Invalid Implementation for DLL handle.")
	}
	return nil, errors.New ("Could not cast DLL handle.")
}

func (implementation *LibPrimesImplementation) Initialize(DLLFileName string) error {
	implementation.Initialized = false;
	implementation.DLLHandle = 0;

	dllHandle, err := syscall.LoadLibrary(DLLFileName);
	if (err != nil) {
		return err;
	}

	implementation.LibPrimes_calculator_getvalue, err = syscall.GetProcAddress(dllHandle, "libprimes_calculator_getvalue")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_calculator_getvalue: " + err.Error())
	}
	
	implementation.LibPrimes_calculator_setvalue, err = syscall.GetProcAddress(dllHandle, "libprimes_calculator_setvalue")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_calculator_setvalue: " + err.Error())
	}
	
	implementation.LibPrimes_calculator_calculate, err = syscall.GetProcAddress(dllHandle, "libprimes_calculator_calculate")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_calculator_calculate: " + err.Error())
	}
	
	implementation.LibPrimes_calculator_setprogresscallback, err = syscall.GetProcAddress(dllHandle, "libprimes_calculator_setprogresscallback")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_calculator_setprogresscallback: " + err.Error())
	}
	
	implementation.LibPrimes_factorizationcalculator_getprimefactors, err = syscall.GetProcAddress(dllHandle, "libprimes_factorizationcalculator_getprimefactors")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_factorizationcalculator_getprimefactors: " + err.Error())
	}
	
	implementation.LibPrimes_sievecalculator_getprimes, err = syscall.GetProcAddress(dllHandle, "libprimes_sievecalculator_getprimes")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_sievecalculator_getprimes: " + err.Error())
	}
	
	implementation.LibPrimes_getversion, err = syscall.GetProcAddress(dllHandle, "libprimes_getversion")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_getversion: " + err.Error())
	}
	
	implementation.LibPrimes_getlasterror, err = syscall.GetProcAddress(dllHandle, "libprimes_getlasterror")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_getlasterror: " + err.Error())
	}
	
	implementation.LibPrimes_releaseinstance, err = syscall.GetProcAddress(dllHandle, "libprimes_releaseinstance")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_releaseinstance: " + err.Error())
	}
	
	implementation.LibPrimes_createfactorizationcalculator, err = syscall.GetProcAddress(dllHandle, "libprimes_createfactorizationcalculator")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_createfactorizationcalculator: " + err.Error())
	}
	
	implementation.LibPrimes_createsievecalculator, err = syscall.GetProcAddress(dllHandle, "libprimes_createsievecalculator")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_createsievecalculator: " + err.Error())
	}
	
	implementation.LibPrimes_setjournal, err = syscall.GetProcAddress(dllHandle, "libprimes_setjournal")
	if (err != nil) {
		return errors.New ("Could not get function libprimes_setjournal: " + err.Error())
	}
	
	implementation.DLLHandle =  dllHandle
	implementation.Initialized = true
	return nil
}

func (implementation *LibPrimesImplementation) NewHandle() (LibPrimesImplementationHandle) {
	handle := new (LibPrimesImplementationHandleStruct)
	handle.Implementation = implementation
	handle.DLLhandle = 0
	return handle
}

func (implementation *LibPrimesImplementation) CallFunction(funcptr uintptr, parameters ... uintptr) (error) {
	var ret uintptr;
	if (!implementation.Initialized) {
		return errors.New ("LibPrimes Implementation has not been initialized!")
	}
	
	switch len(parameters) { 
		case 0: ret, _, _ = syscall.Syscall (funcptr, 0, 0, 0, 0)
		case 1: ret, _, _ = syscall.Syscall (funcptr, 1, uintptr (parameters[0]), 0, 0)
		case 2: ret, _, _ = syscall.Syscall (funcptr, 2, uintptr (parameters[0]), uintptr (parameters[1]), 0)
		case 3: ret, _, _ = syscall.Syscall (funcptr, 3, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]))
		case 4: ret, _, _ = syscall.Syscall6 (funcptr, 4, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), 0, 0)
		case 5: ret, _, _ = syscall.Syscall6 (funcptr, 5, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), 0)
		case 6: ret, _, _ = syscall.Syscall6 (funcptr, 6, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]))
		case 7: ret, _, _ = syscall.Syscall9 (funcptr, 7, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), 0, 0)
		case 8: ret, _, _ = syscall.Syscall9 (funcptr, 8, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), uintptr (parameters[7]), 0)
		case 9: ret, _, _ = syscall.Syscall9 (funcptr, 9, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), uintptr (parameters[7]), uintptr (parameters[8]))
		case 10: ret, _, _ = syscall.Syscall12 (funcptr, 10, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), uintptr (parameters[7]), uintptr (parameters[8]), uintptr (parameters[9]), 0, 0)
		case 11: ret, _, _ = syscall.Syscall12 (funcptr, 11, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), uintptr (parameters[7]), uintptr (parameters[8]), uintptr (parameters[9]), uintptr (parameters[10]), 0)
		case 12: ret, _, _ = syscall.Syscall12 (funcptr, 12, uintptr (parameters[0]), uintptr (parameters[1]), uintptr (parameters[2]), uintptr (parameters[3]), uintptr (parameters[4]), uintptr (parameters[5]), uintptr (parameters[6]), uintptr (parameters[7]), uintptr (parameters[8]), uintptr (parameters[9]), uintptr (parameters[10]), uintptr (parameters[11]))
		default: 
			return errors.New ("Invalid DLL function parameter count!");
	}
	
	if (int(ret) != 0) {
		return errors.New (fmt.Sprintf ("LibPrimes Error: %.04x (%s)", int(ret), GetLibPrimesErrorMessage(uint32(ret))))
	}
	
	return nil
}


func (implementation *LibPrimesImplementation) Calculator_GetValue(Calculator LibPrimesHandle) (uint64, error) {
	var err error = nil
	var nValue uint64 = 0
	
	implementation_calculator, err := implementation.GetWrapperHandle(Calculator)
	if (err != nil) {
		return 0, err
	}

	err = implementation.CallFunction(implementation.LibPrimes_calculator_getvalue, implementation_calculator.GetDLLInHandle(), UInt64OutValue(&nValue))
	if (err != nil) {
		return 0, err
	}
	
	return uint64(nValue), err
}

func (implementation *LibPrimesImplementation) Calculator_SetValue(Calculator LibPrimesHandle, nValue uint64) (error) {
	var err error = nil
	
	implementation_calculator, err := implementation.GetWrapperHandle(Calculator)
	if (err != nil) {
		return err
	}

	err = implementation.CallFunction(implementation.LibPrimes_calculator_setvalue, implementation_calculator.GetDLLInHandle(), UInt64InValue(nValue))
	if (err != nil) {
		return err
	}
	
	return err
}

func (implementation *LibPrimesImplementation) Calculator_Calculate(Calculator LibPrimesHandle) (error) {
	var err error = nil
	
	implementation_calculator, err := implementation.GetWrapperHandle(Calculator)
	if (err != nil) {
		return err
	}

	err = implementation.CallFunction(implementation.LibPrimes_calculator_calculate, implementation_calculator.GetDLLInHandle())
	if (err != nil) {
		return err
	}
	
	return err
}

func (implementation *LibPrimesImplementation) Calculator_SetProgressCallback(Calculator LibPrimesHandle, pProgressCallback int64) (error) {
	var err error = nil
	
	implementation_calculator, err := implementation.GetWrapperHandle(Calculator)
	if (err != nil) {
		return err
	}

	err = implementation.CallFunction(implementation.LibPrimes_calculator_setprogresscallback, implementation_calculator.GetDLLInHandle(), 0)
	if (err != nil) {
		return err
	}
	
	return err
}

func (implementation *LibPrimesImplementation) FactorizationCalculator_GetPrimeFactors(FactorizationCalculator LibPrimesHandle) ([]sLibPrimesPrimeFactor, error) {
	var err error = nil
	arrayPrimeFactors := make ([]sLibPrimesPrimeFactor, 0)
	
	implementation_factorizationcalculator, err := implementation.GetWrapperHandle(FactorizationCalculator)
	if (err != nil) {
		return make ([]sLibPrimesPrimeFactor, 0), err
	}

	err = implementation.CallFunction(implementation.LibPrimes_factorizationcalculator_getprimefactors, implementation_factorizationcalculator.GetDLLInHandle(), 0, 0, 0)
	if (err != nil) {
		return make ([]sLibPrimesPrimeFactor, 0), err
	}
	err = implementation.CallFunction(implementation.LibPrimes_factorizationcalculator_getprimefactors, implementation_factorizationcalculator.GetDLLInHandle(), 0, 0, 0)
	if (err != nil) {
		return make ([]sLibPrimesPrimeFactor, 0), err
	}
	
	return arrayPrimeFactors, err
}

func (implementation *LibPrimesImplementation) SieveCalculator_GetPrimes(SieveCalculator LibPrimesHandle) ([]uint64, error) {
	var err error = nil
	var neededforPrimes int64 = 0
	var filledinPrimes int64 = 0
	bufferPrimes := make ([]uint64, 0)
	
	implementation_sievecalculator, err := implementation.GetWrapperHandle(SieveCalculator)
	if (err != nil) {
		return make ([]uint64, 0), err
	}

	err = implementation.CallFunction(implementation.LibPrimes_sievecalculator_getprimes, implementation_sievecalculator.GetDLLInHandle(), Int64InValue(0), Int64OutValue(&neededforPrimes), Int64InValue(0))
	if (err != nil) {
		return make ([]uint64, 0), err
	}
	bufferSizePrimes := neededforPrimes
	bufferPrimes = make([]uint64, bufferSizePrimes)
	err = implementation.CallFunction(implementation.LibPrimes_sievecalculator_getprimes, implementation_sievecalculator.GetDLLInHandle(), Int64InValue(bufferSizePrimes), Int64OutValue(&filledinPrimes), uintptr(unsafe.Pointer(&bufferPrimes[0])))
	if (err != nil) {
		return make ([]uint64, 0), err
	}
	
	return bufferPrimes, err
}


/*************************************************************************************************************************
	Class definition LibPrimesWrapper
**************************************************************************************************************************/
	type LibPrimesWrapper struct {
		Interface LibPrimesGoInterface
	}
func (implementation *LibPrimesImplementation) GetVersion() (uint32, uint32, uint32, error) {
	var err error = nil
	var nMajor uint32 = 0
	var nMinor uint32 = 0
	var nMicro uint32 = 0

	err = implementation.CallFunction(implementation.LibPrimes_getversion, UInt32OutValue(&nMajor), UInt32OutValue(&nMinor), UInt32OutValue(&nMicro))
	if (err != nil) {
		return 0, 0, 0, err
	}
	
	return uint32(nMajor), uint32(nMinor), uint32(nMicro), err
}

func (implementation *LibPrimesImplementation) GetLastError(Instance LibPrimesHandle) (string, bool, error) {
	var err error = nil
	var neededforErrorMessage int64 = 0
	var filledinErrorMessage int64 = 0
	var bHasError int64 = 0
	implementation_instance, err := implementation.GetWrapperHandle(Instance)
	if (err != nil) {
		return "", false, err
	}
	

	err = implementation.CallFunction(implementation.LibPrimes_getlasterror, implementation_instance.GetDLLInHandle (), Int64InValue(0), Int64OutValue(&neededforErrorMessage), Int64InValue(0), Int64OutValue(&bHasError))
	if (err != nil) {
		return "", false, err
	}
	bufferSizeErrorMessage := neededforErrorMessage + 1
	bufferErrorMessage := make([]byte, bufferSizeErrorMessage)
	err = implementation.CallFunction(implementation.LibPrimes_getlasterror, implementation_instance.GetDLLInHandle (), Int64InValue(bufferSizeErrorMessage), Int64OutValue(&filledinErrorMessage), uintptr(unsafe.Pointer(&bufferErrorMessage[0])), Int64OutValue(&bHasError))
	if (err != nil) {
		return "", false, err
	}
	
	return string (bufferErrorMessage[:filledinErrorMessage]), (bHasError != 0), err
}

func (implementation *LibPrimesImplementation) ReleaseInstance(Instance LibPrimesHandle) (error) {
	var err error = nil
	implementation_instance, err := implementation.GetWrapperHandle(Instance)
	if (err != nil) {
		return err
	}
	

	err = implementation.CallFunction(implementation.LibPrimes_releaseinstance, implementation_instance.GetDLLInHandle ())
	if (err != nil) {
		return err
	}
	
	return err
}

func (implementation *LibPrimesImplementation) CreateFactorizationCalculator() (LibPrimesHandle, error) {
	var err error = nil
	hInstance := implementation.NewHandle()

	err = implementation.CallFunction(implementation.LibPrimes_createfactorizationcalculator, hInstance.GetDLLOutHandle())
	if (err != nil) {
		return hInstance, err
	}
	
	return hInstance, err
}

func (implementation *LibPrimesImplementation) CreateSieveCalculator() (LibPrimesHandle, error) {
	var err error = nil
	hInstance := implementation.NewHandle()

	err = implementation.CallFunction(implementation.LibPrimes_createsievecalculator, hInstance.GetDLLOutHandle())
	if (err != nil) {
		return hInstance, err
	}
	
	return hInstance, err
}

func (implementation *LibPrimesImplementation) SetJournal(sFileName string) (error) {
	var err error = nil

	err = implementation.CallFunction(implementation.LibPrimes_setjournal, StringInValue(sFileName))
	if (err != nil) {
		return err
	}
	
	return err
}


func (implementation *LibPrimesImplementation) checkBinaryVersion() (error) {
	var nBindingMajor uint32 = 1;
	var nBindingMinor uint32 = 2;
	nMajor, nMinor, _, err := implementation.GetVersion()
	if (err != nil) {
			return err;
	}
	if ( (nMajor != nBindingMajor) || (nMinor < nBindingMinor) ) {
		return fmt.Errorf("LibPrimes Error: 25 (%s)", int(0), GetLibPrimesErrorMessage (uint32(0)));
	}
	return nil
}

func LibPrimesLoadWrapper(DllFileName string) (LibPrimesWrapper, error) {
	var Wrapper LibPrimesWrapper;
	var Instance LibPrimesImplementation;
	
	err := Instance.Initialize(DllFileName);
	if (err != nil) {
			return Wrapper, err;
	}
	err = Instance.checkBinaryVersion()
	if (err != nil) {
			return Wrapper, err;
	}
	Wrapper.Interface = &Instance;
	
	return Wrapper, nil;
}

