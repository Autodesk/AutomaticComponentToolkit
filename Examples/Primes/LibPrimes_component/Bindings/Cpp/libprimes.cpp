/*++

Copyright (C) 2018 PrimeDevelopers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.5.0-develop2.

Abstract: This is an autogenerated C++ Wrapper Implementation file in order to allow 
an easy use of Prime Numbers Library

Interface version: 1.2.0

*/

#include "libprimes.hpp"

#include <vector>

namespace LibPrimes {

/*************************************************************************************************************************
 Class ELibPrimesException 
**************************************************************************************************************************/
	ELibPrimesException::ELibPrimesException(LibPrimesResult errorCode, const std::string & sErrorMessage)
		: m_errorMessage("LibPrimes Error " + std::to_string (errorCode) + " (" + sErrorMessage + ")")
	{
		m_errorCode = errorCode;
	}

	LibPrimesResult ELibPrimesException::getErrorCode () const noexcept
	{
		return m_errorCode;
	}

	const char* ELibPrimesException::what () const noexcept
	{
		return m_errorMessage.c_str();
	}
		 
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
/**
* CBase::CBase - Constructor for Base class.
*/
void CBase::CheckError(LibPrimesResult nResult)
{
	CWrapper::CheckError(this, nResult);
}

CBase::CBase(LibPrimesHandle pHandle)
	: m_pHandle (pHandle)
{
}

CBase::~CBase()
{
	CWrapper::ReleaseInstance(this);
}

LibPrimesHandle CBase::GetHandle()
{
	return m_pHandle;
}

		 
/*************************************************************************************************************************
 Class CCalculator 
**************************************************************************************************************************/
/**
* CCalculator::CCalculator - Constructor for Calculator class.
*/
CCalculator::CCalculator (LibPrimesHandle pHandle)
	: CBase (pHandle)
{ }

/**
* CCalculator::GetValue - Returns the current value of this Calculator
* @return The current value of this Calculator
*/
LibPrimes_uint64 CCalculator::GetValue ()
{
	LibPrimes_uint64 resultValue = 0;
	CheckError ( libprimes_calculator_getvalue (m_pHandle, &resultValue) );
	return resultValue;
}

/**
* CCalculator::GetSelf - Returns the current value of this Calculator
* @return The current value of this Calculator
*/
PCalculator CCalculator::GetSelf ()
{
	LibPrimesHandle hValue = nullptr;
	CheckError ( libprimes_calculator_getself (m_pHandle, &hValue) );
	return std::make_shared<CCalculator> (hValue);
}

/**
* CCalculator::SetValue - Sets the value to be factorized
* @param[in] nValue - The value to be factorized
*/
void CCalculator::SetValue (const LibPrimes_uint64 nValue)
{
	CheckError ( libprimes_calculator_setvalue (m_pHandle, nValue) );
}

/**
* CCalculator::Calculate - Performs the specific calculation of this Calculator
*/
void CCalculator::Calculate ()
{
	CheckError ( libprimes_calculator_calculate (m_pHandle) );
}

/**
* CCalculator::SetProgressCallback - Sets the progress callback function
* @param[in] pProgressCallback - The progress callback
*/
void CCalculator::SetProgressCallback (const ProgressCallback pProgressCallback)
{
	CheckError ( libprimes_calculator_setprogresscallback (m_pHandle, pProgressCallback) );
}
		 
/*************************************************************************************************************************
 Class CFactorizationCalculator 
**************************************************************************************************************************/
/**
* CFactorizationCalculator::CFactorizationCalculator - Constructor for FactorizationCalculator class.
*/
CFactorizationCalculator::CFactorizationCalculator (LibPrimesHandle pHandle)
	: CCalculator (pHandle)
{ }

/**
* CFactorizationCalculator::GetPrimeFactors - Returns the prime factors of this number (without multiplicity)
* @param[out] PrimeFactorsBuffer - The prime factors of this number
*/
void CFactorizationCalculator::GetPrimeFactors (std::vector<sPrimeFactor> & PrimeFactorsBuffer)
{
	LibPrimes_uint64 elementsNeededPrimeFactors = 0;
	LibPrimes_uint64 elementsWrittenPrimeFactors = 0;
	CheckError ( libprimes_factorizationcalculator_getprimefactors (m_pHandle, 0, &elementsNeededPrimeFactors, nullptr) );
	PrimeFactorsBuffer.resize(elementsNeededPrimeFactors);
	CheckError ( libprimes_factorizationcalculator_getprimefactors (m_pHandle, elementsNeededPrimeFactors, &elementsWrittenPrimeFactors, PrimeFactorsBuffer.data()) );
}
		 
/*************************************************************************************************************************
 Class CSieveCalculator 
**************************************************************************************************************************/
/**
* CSieveCalculator::CSieveCalculator - Constructor for SieveCalculator class.
*/
CSieveCalculator::CSieveCalculator (LibPrimesHandle pHandle)
	: CCalculator (pHandle)
{ }

/**
* CSieveCalculator::GetPrimes - Returns all prime numbers lower or equal to the sieve's value
* @param[out] PrimesBuffer - The primes lower or equal to the sieve's value
*/
void CSieveCalculator::GetPrimes (std::vector<LibPrimes_uint64> & PrimesBuffer)
{
	LibPrimes_uint64 elementsNeededPrimes = 0;
	LibPrimes_uint64 elementsWrittenPrimes = 0;
	CheckError ( libprimes_sievecalculator_getprimes (m_pHandle, 0, &elementsNeededPrimes, nullptr) );
	PrimesBuffer.resize(elementsNeededPrimes);
	CheckError ( libprimes_sievecalculator_getprimes (m_pHandle, elementsNeededPrimes, &elementsWrittenPrimes, PrimesBuffer.data()) );
}

/**
* CWrapper::GetLastError - Returns the last error recorded on this object
* @param[in] pInstance - Instance Handle
* @param[out] sErrorMessage - Message of the last error
* @return Is there a last error to query
*/
bool CWrapper::GetLastError (CBase * pInstance, std::string & sErrorMessage)
{
	LibPrimesHandle hInstance = nullptr;
	if (pInstance != nullptr) {
		hInstance = pInstance->GetHandle ();
	};
	LibPrimes_uint32 bytesNeededErrorMessage = 0;
	LibPrimes_uint32 bytesWrittenErrorMessage = 0;
	bool resultHasError = 0;
	CheckError (nullptr, libprimes_getlasterror (hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError) );
	std::vector<char> bufferErrorMessage;
	bufferErrorMessage.resize(bytesNeededErrorMessage + 2);
	CheckError (nullptr, libprimes_getlasterror (hInstance, bytesNeededErrorMessage + 2, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError) );
	bufferErrorMessage[bytesNeededErrorMessage + 1] = 0;
	sErrorMessage = std::string(&bufferErrorMessage[0]);
	return resultHasError;
}

/**
* CWrapper::ReleaseInstance - Releases the memory of an Instance
* @param[in] pInstance - Instance Handle
*/
void CWrapper::ReleaseInstance (CBase * pInstance)
{
	LibPrimesHandle hInstance = nullptr;
	if (pInstance != nullptr) {
		hInstance = pInstance->GetHandle ();
	};
	CheckError (nullptr, libprimes_releaseinstance (hInstance) );
}

/**
* CWrapper::GetLibraryVersion - retrieves the binary version of this library.
* @param[out] nMajor - returns the major version of this library
* @param[out] nMinor - returns the minor version of this library
* @param[out] nMicro - returns the micro version of this library
* @param[out] sPreReleaseInfo - returns pre-release info of this library (if this is a pre-release binary)
* @param[out] sBuildInfo - returns build-information of this library (optional)
*/
void CWrapper::GetLibraryVersion (LibPrimes_uint32 & nMajor, LibPrimes_uint32 & nMinor, LibPrimes_uint32 & nMicro, std::string & sPreReleaseInfo, std::string & sBuildInfo)
{
	LibPrimes_uint32 bytesNeededPreReleaseInfo = 0;
	LibPrimes_uint32 bytesWrittenPreReleaseInfo = 0;
	LibPrimes_uint32 bytesNeededBuildInfo = 0;
	LibPrimes_uint32 bytesWrittenBuildInfo = 0;
	CheckError (nullptr, libprimes_getlibraryversion (&nMajor, &nMinor, &nMicro, 0, &bytesNeededPreReleaseInfo, nullptr, 0, &bytesNeededBuildInfo, nullptr) );
	std::vector<char> bufferPreReleaseInfo;
	bufferPreReleaseInfo.resize(bytesNeededPreReleaseInfo + 2);
	std::vector<char> bufferBuildInfo;
	bufferBuildInfo.resize(bytesNeededBuildInfo + 2);
	CheckError (nullptr, libprimes_getlibraryversion (&nMajor, &nMinor, &nMicro, bytesNeededPreReleaseInfo + 2, &bytesWrittenPreReleaseInfo, &bufferPreReleaseInfo[0], bytesNeededBuildInfo + 2, &bytesWrittenBuildInfo, &bufferBuildInfo[0]) );
	bufferPreReleaseInfo[bytesNeededPreReleaseInfo + 1] = 0;
	sPreReleaseInfo = std::string(&bufferPreReleaseInfo[0]);
	bufferBuildInfo[bytesNeededBuildInfo + 1] = 0;
	sBuildInfo = std::string(&bufferBuildInfo[0]);
}

/**
* CWrapper::CreateFactorizationCalculator - Creates a new FactorizationCalculator instance
* @return New FactorizationCalculator instance
*/
PFactorizationCalculator CWrapper::CreateFactorizationCalculator ()
{
	LibPrimesHandle hInstance = nullptr;
	CheckError (nullptr, libprimes_createfactorizationcalculator (&hInstance) );
	return std::make_shared<CFactorizationCalculator> (hInstance);
}

/**
* CWrapper::CreateSieveCalculator - Creates a new SieveCalculator instance
* @return New SieveCalculator instance
*/
PSieveCalculator CWrapper::CreateSieveCalculator ()
{
	LibPrimesHandle hInstance = nullptr;
	CheckError (nullptr, libprimes_createsievecalculator (&hInstance) );
	return std::make_shared<CSieveCalculator> (hInstance);
}

/**
* CWrapper::SetJournal - Handles Library Journaling
* @param[in] sFileName - Journal FileName
*/
void CWrapper::SetJournal (const std::string & sFileName)
{
	CheckError (nullptr, libprimes_setjournal (sFileName.c_str()) );
}

void CWrapper::CheckError(CBase * pBaseClass, LibPrimesResult nResult)
{
	if (nResult != 0) {
		std::string sErrorMessage;
		if (pBaseClass != nullptr)
			GetLastError(pBaseClass, sErrorMessage);
		throw ELibPrimesException (nResult, sErrorMessage);
	}
}


}; // end namespace LibPrimes

