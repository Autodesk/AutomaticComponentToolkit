/*++

Copyright (C) 2019 PrimeDevelopers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated Rust implementation file in order to allow easy
development of Prime Numbers Library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.2.0

*/


// Calls from the C-Interface to the Rust traits via the CWrapper
// These are the symbols exposed in the shared object interface

use libprimes_interfaces::*;
use libprimes::CWrapper;
use std::ffi::{c_char, CStr};

#[no_mangle]
pub fn libprimes_getversion(major : *mut u32, minor : *mut u32, micro : *mut u32) -> i32 {
  // Convert parameter major to be used as an argument
  if major.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _major = unsafe {&mut *major};
  
  // Convert parameter minor to be used as an argument
  if minor.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _minor = unsafe {&mut *minor};
  
  // Convert parameter micro to be used as an argument
  if micro.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _micro = unsafe {&mut *micro};
  
  // Call into wrapper for global
  CWrapper::get_version(_major, _minor, _micro);
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

#[no_mangle]
pub fn libprimes_getlasterror(instance : BaseHandle, error_message_buffer_size : usize, error_message_needed_chars : *mut usize, error_message_buffer : *mut u8, has_error : *mut u8) -> i32 {
  // Convert parameter instance to be used as an argument
  if instance.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_instance = unsafe {&mut *instance};
  let _optional_instance = _handle_instance.as_mut_base();
  if _optional_instance.is_none() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _instance = _optional_instance.unwrap();
  
  // Convert parameter error_message to be used as an argument
  let mut _string_error_message = String::new();
  let _error_message = &mut _string_error_message;
  
  // Call into wrapper for global
  let _return_has_error = CWrapper::get_last_error(_instance, _error_message);
  
  // Pass the string error_message via output parameters
  let _slice_error_message = _string_error_message.as_bytes();
  if error_message_buffer_size > _slice_error_message.len() { return LIBPRIMES_ERROR_BUFFERTOOSMALL; }
  if error_message_buffer.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  if error_message_needed_chars.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let mut _buffer_slice_error_message = unsafe {  std::slice::from_raw_parts_mut(error_message_buffer, _slice_error_message.len()) };
  _buffer_slice_error_message.clone_from_slice(_slice_error_message);
  let mut _error_message_needed_chars = unsafe { &mut *error_message_needed_chars };
  *_error_message_needed_chars = _slice_error_message.len();
  
  // Pass the return value has_error via output parameters
  if has_error.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let mut _ref_has_error = unsafe{&mut *has_error};
  *_ref_has_error = _return_has_error as u8;
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

#[no_mangle]
fn libprimes_acquireinstance(instance : BaseHandle) -> i32 {
  if instance.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_instance = unsafe {&mut *instance};
  _handle_instance.inc_ref_count();
  LIBPRIMES_SUCCESS
}
#[no_mangle]
fn libprimes_releaseinstance(instance : BaseHandle) -> i32 {
  if instance.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_instance = unsafe {&mut *instance};
  let free = _handle_instance.dec_ref_count();
  if free {
    unsafe { let _ = Box::from_raw(instance); }
  }
  LIBPRIMES_SUCCESS
}
#[no_mangle]
pub fn libprimes_createfactorizationcalculator(instance : *mut FactorizationCalculatorHandle) -> i32 {
  // Call into wrapper for global
  let _return_instance = CWrapper::create_factorization_calculator();
  
  // Pass the return value instance via output parameters
  if instance.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_instance = Box::new(HandleImpl::TFactorizationCalculator(1, _return_instance));
  let mut _ref_instance = unsafe{&mut *instance};
  *_ref_instance = Box::into_raw(_handle_instance);
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

#[no_mangle]
pub fn libprimes_createsievecalculator(instance : *mut SieveCalculatorHandle) -> i32 {
  // Call into wrapper for global
  let _return_instance = CWrapper::create_sieve_calculator();
  
  // Pass the return value instance via output parameters
  if instance.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_instance = Box::new(HandleImpl::TSieveCalculator(1, _return_instance));
  let mut _ref_instance = unsafe{&mut *instance};
  *_ref_instance = Box::into_raw(_handle_instance);
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

#[no_mangle]
pub fn libprimes_setjournal(file_name : *const c_char) -> i32 {
  // Convert parameter file_name to be used as an argument
  if file_name.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _str_file_name = unsafe{ CStr::from_ptr(file_name) };
  let _optional_file_name = _str_file_name.to_str();
  if _optional_file_name.is_err() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _file_name = _optional_file_name.unwrap();
  
  // Call into wrapper for global
  CWrapper::set_journal(_file_name);
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

#[no_mangle]
pub fn libprimes_base_classtypeid(self_ : BaseHandle, class_type_id : *mut u64) -> i32 {
  // Convert parameter self_ to be used as an argument
  if self_.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_self_ = unsafe {&mut *self_};
  let _optional_self_ = _handle_self_.as_mut_base();
  if _optional_self_.is_none() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _self_ = _optional_self_.unwrap();
  
  // Call into trait class
  let _return_class_type_id = _self_.class_type_id();
  
  // Pass the return value class_type_id via output parameters
  if class_type_id.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let mut _ref_class_type_id = unsafe{&mut *class_type_id};
  *_ref_class_type_id = _return_class_type_id;
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

#[no_mangle]
pub fn libprimes_calculator_getvalue(self_ : CalculatorHandle, value : *mut u64) -> i32 {
  // Convert parameter self_ to be used as an argument
  if self_.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_self_ = unsafe {&mut *self_};
  let _optional_self_ = _handle_self_.as_mut_calculator();
  if _optional_self_.is_none() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _self_ = _optional_self_.unwrap();
  
  // Call into trait class
  let _return_value = _self_.get_value();
  
  // Pass the return value value via output parameters
  if value.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let mut _ref_value = unsafe{&mut *value};
  *_ref_value = _return_value;
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

#[no_mangle]
pub fn libprimes_calculator_setvalue(self_ : CalculatorHandle, value : u64) -> i32 {
  // Convert parameter self_ to be used as an argument
  if self_.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_self_ = unsafe {&mut *self_};
  let _optional_self_ = _handle_self_.as_mut_calculator();
  if _optional_self_.is_none() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _self_ = _optional_self_.unwrap();
  
  // Convert parameter value to be used as an argument
  let _value = value;
  
  // Call into trait class
  _self_.set_value(_value);
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

#[no_mangle]
pub fn libprimes_calculator_calculate(self_ : CalculatorHandle) -> i32 {
  // Convert parameter self_ to be used as an argument
  if self_.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_self_ = unsafe {&mut *self_};
  let _optional_self_ = _handle_self_.as_mut_calculator();
  if _optional_self_.is_none() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _self_ = _optional_self_.unwrap();
  
  // Call into trait class
  _self_.calculate();
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

#[no_mangle]
pub fn libprimes_calculator_setprogresscallback(self_ : CalculatorHandle, progress_callback : ProgressCallback) -> i32 {
  // Convert parameter self_ to be used as an argument
  if self_.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_self_ = unsafe {&mut *self_};
  let _optional_self_ = _handle_self_.as_mut_calculator();
  if _optional_self_.is_none() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _self_ = _optional_self_.unwrap();
  
  // Convert parameter progress_callback to be used as an argument
  let _progress_callback = progress_callback;
  
  // Call into trait class
  _self_.set_progress_callback(_progress_callback);
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

#[no_mangle]
pub fn libprimes_factorizationcalculator_getprimefactors(self_ : FactorizationCalculatorHandle, prime_factors_buffer_size : usize, prime_factors_count : *mut usize, prime_factors_buffer : *mut PrimeFactor) -> i32 {
  // Convert parameter self_ to be used as an argument
  if self_.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_self_ = unsafe {&mut *self_};
  let _optional_self_ = _handle_self_.as_mut_factorization_calculator();
  if _optional_self_.is_none() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _self_ = _optional_self_.unwrap();
  
  // Convert parameter prime_factors to be used as an argument
  let mut _array_prime_factors : Vec<PrimeFactor> = Vec::new();
  let _prime_factors = &mut _array_prime_factors;
  
  // Call into trait class
  _self_.get_prime_factors(_prime_factors);
  
  // Pass the array prime_factors via output parameters
  let _slice_prime_factors = _array_prime_factors.as_slice();
  if prime_factors_buffer_size > _slice_prime_factors.len() { return LIBPRIMES_ERROR_BUFFERTOOSMALL; }
  if prime_factors_buffer.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  if prime_factors_count.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let mut _buffer_slice_prime_factors = unsafe {  std::slice::from_raw_parts_mut(prime_factors_buffer, _slice_prime_factors.len()) };
  _buffer_slice_prime_factors.clone_from_slice(_slice_prime_factors);
  let mut _prime_factors_count = unsafe { &mut *prime_factors_count };
  *_prime_factors_count = _slice_prime_factors.len();
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

#[no_mangle]
pub fn libprimes_sievecalculator_getprimes(self_ : SieveCalculatorHandle, primes_buffer_size : usize, primes_count : *mut usize, primes_buffer : *mut u64) -> i32 {
  // Convert parameter self_ to be used as an argument
  if self_.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _handle_self_ = unsafe {&mut *self_};
  let _optional_self_ = _handle_self_.as_mut_sieve_calculator();
  if _optional_self_.is_none() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let _self_ = _optional_self_.unwrap();
  
  // Convert parameter primes to be used as an argument
  let mut _array_primes : Vec<u64> = Vec::new();
  let _primes = &mut _array_primes;
  
  // Call into trait class
  _self_.get_primes(_primes);
  
  // Pass the array primes via output parameters
  let _slice_primes = _array_primes.as_slice();
  if primes_buffer_size > _slice_primes.len() { return LIBPRIMES_ERROR_BUFFERTOOSMALL; }
  if primes_buffer.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  if primes_count.is_null() { return LIBPRIMES_ERROR_INVALIDPARAM; }
  let mut _buffer_slice_primes = unsafe {  std::slice::from_raw_parts_mut(primes_buffer, _slice_primes.len()) };
  _buffer_slice_primes.clone_from_slice(_slice_primes);
  let mut _primes_count = unsafe { &mut *primes_count };
  *_primes_count = _slice_primes.len();
  
  // All ok - return success
  LIBPRIMES_SUCCESS
}

