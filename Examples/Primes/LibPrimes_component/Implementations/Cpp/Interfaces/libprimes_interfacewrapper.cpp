/*++

Copyright (C) 2018 PrimeDevelopers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.3.2.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Prime Numbers Library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.2.0

*/

#include "libprimes.h"
#include "libprimes_interfaces.hpp"
#include "libprimes_interfaceexception.hpp"
#include "libprimes_interfacejournal.hpp"

using namespace LibPrimes::Impl;

PLibPrimesInterfaceJournal m_GlobalJournal;

extern "C" {


/*************************************************************************************************************************
 Class implementation for Calculator
**************************************************************************************************************************/
LibPrimesResult libprimes_calculator_getvalue (LibPrimes_Calculator pCalculator, LibPrimes_uint64 * pValue)
{
	PLibPrimesInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pCalculator, "Calculator", "GetValue");
		}

		if (pValue == nullptr)
			throw ELibPrimesInterfaceException (LIBPRIMES_ERROR_INVALIDPARAM);

		ILibPrimesBaseClass* pIBaseClass = (ILibPrimesBaseClass *)pCalculator;
		ILibPrimesCalculator* pICalculator = dynamic_cast<ILibPrimesCalculator*>(pIBaseClass);
		if (!pICalculator)
			throw ELibPrimesInterfaceException(LIBPRIMES_ERROR_INVALIDCAST);


		*pValue = pICalculator->GetValue();


		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt64Result ("Value", *pValue);
			pJournalEntry->writeSuccess();
		}

		return LIBPRIMES_SUCCESS;
	}
	catch (ELibPrimesInterfaceException & E) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(E.getErrorCode());
		return E.getErrorCode();
	}
	catch (...) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(LIBPRIMES_ERROR_GENERICEXCEPTION);
		return LIBPRIMES_ERROR_GENERICEXCEPTION;
	}
}

LibPrimesResult libprimes_calculator_setvalue (LibPrimes_Calculator pCalculator, LibPrimes_uint64 nValue)
{
	PLibPrimesInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pCalculator, "Calculator", "SetValue");
			pJournalEntry->addUInt64Parameter ("Value", nValue);
		}


		ILibPrimesBaseClass* pIBaseClass = (ILibPrimesBaseClass *)pCalculator;
		ILibPrimesCalculator* pICalculator = dynamic_cast<ILibPrimesCalculator*>(pIBaseClass);
		if (!pICalculator)
			throw ELibPrimesInterfaceException(LIBPRIMES_ERROR_INVALIDCAST);


		pICalculator->SetValue(nValue);


		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}

		return LIBPRIMES_SUCCESS;
	}
	catch (ELibPrimesInterfaceException & E) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(E.getErrorCode());
		return E.getErrorCode();
	}
	catch (...) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(LIBPRIMES_ERROR_GENERICEXCEPTION);
		return LIBPRIMES_ERROR_GENERICEXCEPTION;
	}
}

LibPrimesResult libprimes_calculator_calculate (LibPrimes_Calculator pCalculator)
{
	PLibPrimesInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pCalculator, "Calculator", "Calculate");
		}


		ILibPrimesBaseClass* pIBaseClass = (ILibPrimesBaseClass *)pCalculator;
		ILibPrimesCalculator* pICalculator = dynamic_cast<ILibPrimesCalculator*>(pIBaseClass);
		if (!pICalculator)
			throw ELibPrimesInterfaceException(LIBPRIMES_ERROR_INVALIDCAST);


		pICalculator->Calculate();


		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}

		return LIBPRIMES_SUCCESS;
	}
	catch (ELibPrimesInterfaceException & E) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(E.getErrorCode());
		return E.getErrorCode();
	}
	catch (...) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(LIBPRIMES_ERROR_GENERICEXCEPTION);
		return LIBPRIMES_ERROR_GENERICEXCEPTION;
	}
}

LibPrimesResult libprimes_calculator_setprogresscallback (LibPrimes_Calculator pCalculator, LibPrimesProgressCallback pProgressCallback)
{
	PLibPrimesInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pCalculator, "Calculator", "SetProgressCallback");
		}


		ILibPrimesBaseClass* pIBaseClass = (ILibPrimesBaseClass *)pCalculator;
		ILibPrimesCalculator* pICalculator = dynamic_cast<ILibPrimesCalculator*>(pIBaseClass);
		if (!pICalculator)
			throw ELibPrimesInterfaceException(LIBPRIMES_ERROR_INVALIDCAST);


		pICalculator->SetProgressCallback(pProgressCallback);


		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}

		return LIBPRIMES_SUCCESS;
	}
	catch (ELibPrimesInterfaceException & E) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(E.getErrorCode());
		return E.getErrorCode();
	}
	catch (...) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(LIBPRIMES_ERROR_GENERICEXCEPTION);
		return LIBPRIMES_ERROR_GENERICEXCEPTION;
	}
}


/*************************************************************************************************************************
 Class implementation for FactorizationCalculator
**************************************************************************************************************************/
LibPrimesResult libprimes_factorizationcalculator_getprimefactors (LibPrimes_FactorizationCalculator pFactorizationCalculator, const LibPrimes_uint64 nPrimeFactorsBufferSize, LibPrimes_uint64* pPrimeFactorsNeededCount, sLibPrimesPrimeFactor * pPrimeFactorsBuffer)
{
	PLibPrimesInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pFactorizationCalculator, "FactorizationCalculator", "GetPrimeFactors");
		}

		if ((!pPrimeFactorsBuffer) && !(pPrimeFactorsNeededCount))
			throw ELibPrimesInterfaceException (LIBPRIMES_ERROR_INVALIDPARAM);

		ILibPrimesBaseClass* pIBaseClass = (ILibPrimesBaseClass *)pFactorizationCalculator;
		ILibPrimesFactorizationCalculator* pIFactorizationCalculator = dynamic_cast<ILibPrimesFactorizationCalculator*>(pIBaseClass);
		if (!pIFactorizationCalculator)
			throw ELibPrimesInterfaceException(LIBPRIMES_ERROR_INVALIDCAST);


		pIFactorizationCalculator->GetPrimeFactors(nPrimeFactorsBufferSize, pPrimeFactorsNeededCount, pPrimeFactorsBuffer);


		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}

		return LIBPRIMES_SUCCESS;
	}
	catch (ELibPrimesInterfaceException & E) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(E.getErrorCode());
		return E.getErrorCode();
	}
	catch (...) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(LIBPRIMES_ERROR_GENERICEXCEPTION);
		return LIBPRIMES_ERROR_GENERICEXCEPTION;
	}
}


/*************************************************************************************************************************
 Class implementation for SieveCalculator
**************************************************************************************************************************/
LibPrimesResult libprimes_sievecalculator_getprimes (LibPrimes_SieveCalculator pSieveCalculator, const LibPrimes_uint64 nPrimesBufferSize, LibPrimes_uint64* pPrimesNeededCount, LibPrimes_uint64 * pPrimesBuffer)
{
	PLibPrimesInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pSieveCalculator, "SieveCalculator", "GetPrimes");
		}

		if ((!pPrimesBuffer) && !(pPrimesNeededCount))
			throw ELibPrimesInterfaceException (LIBPRIMES_ERROR_INVALIDPARAM);

		ILibPrimesBaseClass* pIBaseClass = (ILibPrimesBaseClass *)pSieveCalculator;
		ILibPrimesSieveCalculator* pISieveCalculator = dynamic_cast<ILibPrimesSieveCalculator*>(pIBaseClass);
		if (!pISieveCalculator)
			throw ELibPrimesInterfaceException(LIBPRIMES_ERROR_INVALIDCAST);


		pISieveCalculator->GetPrimes(nPrimesBufferSize, pPrimesNeededCount, pPrimesBuffer);


		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}

		return LIBPRIMES_SUCCESS;
	}
	catch (ELibPrimesInterfaceException & E) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(E.getErrorCode());
		return E.getErrorCode();
	}
	catch (...) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(LIBPRIMES_ERROR_GENERICEXCEPTION);
		return LIBPRIMES_ERROR_GENERICEXCEPTION;
	}
}


/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibPrimesResult libprimes_releaseinstance (LibPrimes_BaseClass pInstance)
{
	PLibPrimesInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("ReleaseInstance");
			pJournalEntry->addHandleParameter ("Instance", pInstance);
		}


		ILibPrimesBaseClass* pIBaseClassInstance = (ILibPrimesBaseClass *)pInstance;
		ILibPrimesBaseClass* pIInstance = dynamic_cast<ILibPrimesBaseClass*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibPrimesInterfaceException (LIBPRIMES_ERROR_INVALIDCAST);


		CLibPrimesWrapper::ReleaseInstance(pIInstance);


		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}

		return LIBPRIMES_SUCCESS;
	}
	catch (ELibPrimesInterfaceException & E) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(E.getErrorCode());
		return E.getErrorCode();
	}
	catch (...) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(LIBPRIMES_ERROR_GENERICEXCEPTION);
		return LIBPRIMES_ERROR_GENERICEXCEPTION;
	}
}

LibPrimesResult libprimes_getlibraryversion (LibPrimes_uint32 * pMajor, LibPrimes_uint32 * pMinor, LibPrimes_uint32 * pMicro)
{
	PLibPrimesInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetLibraryVersion");
		}

		if (!pMajor)
			throw ELibPrimesInterfaceException (LIBPRIMES_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibPrimesInterfaceException (LIBPRIMES_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibPrimesInterfaceException (LIBPRIMES_ERROR_INVALIDPARAM);

		LibPrimes_uint32 nMajor;
		LibPrimes_uint32 nMinor;
		LibPrimes_uint32 nMicro;

		CLibPrimesWrapper::GetLibraryVersion(nMajor, nMinor, nMicro);

		*pMajor = nMajor;
		*pMinor = nMinor;
		*pMicro = nMicro;

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result ("Major", *pMajor);
			pJournalEntry->addUInt32Result ("Minor", *pMinor);
			pJournalEntry->addUInt32Result ("Micro", *pMicro);
			pJournalEntry->writeSuccess();
		}

		return LIBPRIMES_SUCCESS;
	}
	catch (ELibPrimesInterfaceException & E) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(E.getErrorCode());
		return E.getErrorCode();
	}
	catch (...) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(LIBPRIMES_ERROR_GENERICEXCEPTION);
		return LIBPRIMES_ERROR_GENERICEXCEPTION;
	}
}

LibPrimesResult libprimes_createfactorizationcalculator (LibPrimes_FactorizationCalculator * pInstance)
{
	PLibPrimesInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("CreateFactorizationCalculator");
		}

		if (pInstance == nullptr)
			throw ELibPrimesInterfaceException (LIBPRIMES_ERROR_INVALIDPARAM);

		ILibPrimesBaseClass* pBaseInstance(nullptr);

		pBaseInstance = CLibPrimesWrapper::CreateFactorizationCalculator();

		*pInstance = (ILibPrimesBaseClass*)(pBaseInstance);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult ("Instance", *pInstance);
			pJournalEntry->writeSuccess();
		}

		return LIBPRIMES_SUCCESS;
	}
	catch (ELibPrimesInterfaceException & E) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(E.getErrorCode());
		return E.getErrorCode();
	}
	catch (...) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(LIBPRIMES_ERROR_GENERICEXCEPTION);
		return LIBPRIMES_ERROR_GENERICEXCEPTION;
	}
}

LibPrimesResult libprimes_createsievecalculator (LibPrimes_SieveCalculator * pInstance)
{
	PLibPrimesInterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("CreateSieveCalculator");
		}

		if (pInstance == nullptr)
			throw ELibPrimesInterfaceException (LIBPRIMES_ERROR_INVALIDPARAM);

		ILibPrimesBaseClass* pBaseInstance(nullptr);

		pBaseInstance = CLibPrimesWrapper::CreateSieveCalculator();

		*pInstance = (ILibPrimesBaseClass*)(pBaseInstance);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult ("Instance", *pInstance);
			pJournalEntry->writeSuccess();
		}

		return LIBPRIMES_SUCCESS;
	}
	catch (ELibPrimesInterfaceException & E) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(E.getErrorCode());
		return E.getErrorCode();
	}
	catch (...) {
		if (pJournalEntry.get() != nullptr)
			pJournalEntry->writeError(LIBPRIMES_ERROR_GENERICEXCEPTION);
		return LIBPRIMES_ERROR_GENERICEXCEPTION;
	}
}

LibPrimesResult libprimes_setjournal (const char * pFileName)
{
	try {
		if (pFileName == nullptr) 
			throw ELibPrimesInterfaceException (LIBPRIMES_ERROR_INVALIDPARAM);

		std::string sFileName(pFileName);

		m_GlobalJournal = nullptr;
		if (sFileName != "") {
			m_GlobalJournal = std::make_shared<CLibPrimesInterfaceJournal> (sFileName);
		}


		return LIBPRIMES_SUCCESS;
	}
	catch (ELibPrimesInterfaceException & E) {
		return E.getErrorCode();
	}
	catch (...) {
		return LIBPRIMES_ERROR_GENERICEXCEPTION;
	}
}

}

