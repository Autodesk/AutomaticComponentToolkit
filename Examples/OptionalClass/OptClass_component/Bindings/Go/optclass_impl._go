/*++

Copyright (C) 2019 ACT Developers


This file has been generated by the Automatic Component Toolkit (ACT) version 1.6.0-develop.

Abstract: This is an autogenerated Go implementation file in order to allow an easy
 use of Optional Class Library

Interface version: 1.0.0

*/


package optclass

// #include <string.h>
import "C"

import (
		"fmt"
		"errors"
		"syscall"
		"unsafe"
)

type OptClassImplementation struct {
	Initialized bool
	DLLHandle syscall.Handle
	OptClass_acquireinstance uintptr
	OptClass_releaseinstance uintptr
	OptClass_getversion uintptr
	OptClass_getlasterror uintptr
	OptClass_setjournal uintptr
	OptClass_createinstancewithname uintptr
	OptClass_findinstancea uintptr
	OptClass_findinstanceb uintptr
	OptClass_useinstancemaybe uintptr
}

type OptClassImplementationHandle interface {
	OptClassHandle

	GetDLLInHandle() (uintptr)
	GetDLLOutHandle() (uintptr)
	GetWrapper() (*OptClassImplementation)
}

type OptClassImplementationHandleStruct struct {
	Implementation * OptClassImplementation
	DLLhandle uintptr
}

func (handle *OptClassImplementationHandleStruct) Close() (error) {
	if (handle.DLLhandle != 0) {
		if (handle.Implementation == nil) {
			return errors.New("Uninitialized DLL Implementation Handle")
		}
		
		dllhandle := handle.DLLhandle
		handle.DLLhandle = 0;
		
		return handle.Implementation.CallFunction(handle.Implementation.OptClass_releaseinstance, dllhandle)
	}
	
	return nil
}

func (handle *OptClassImplementationHandleStruct) IsValid() (bool) {
	return (handle.DLLhandle != 0)
}

func (handle *OptClassImplementationHandleStruct) GetDLLInHandle() (uintptr) {
	return handle.DLLhandle;
}

func (handle *OptClassImplementationHandleStruct) GetDLLOutHandle() (uintptr) {
	return uintptr(unsafe.Pointer(&handle.DLLhandle));
}

func (handle *OptClassImplementationHandleStruct) GetWrapper() (*OptClassImplementation) {
	return handle.Implementation;
}

func Int8OutValue(reference * int8) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Int8InValue(value int8) uintptr {
	return uintptr(value)
}
func Int16OutValue(reference * int16) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Int16InValue(value int16) uintptr {
	return uintptr(value)
}
func Int32OutValue(reference * int32) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Int32InValue(value int32) uintptr {
	return uintptr(value)
}
func Int64OutValue(reference * int64) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Int64InValue(value int64) uintptr {
	return uintptr(value)
}
func UInt8OutValue(reference * uint8) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func UInt8InValue(value uint8) uintptr {
	return uintptr(value)
}
func UInt16OutValue(reference * uint16) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func UInt16InValue(value uint16) uintptr {
	return uintptr(value)
}
func UInt32OutValue(reference * uint32) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func UInt32InValue(value uint32) uintptr {
	return uintptr(value)
}
func UInt64OutValue(reference * uint64) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func UInt64InValue(value uint64) uintptr {
	return uintptr(value)
}
func Float32OutValue(reference * float32) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Float32InValue(value float32) uintptr {
	return uintptr(value)
}
func Float64OutValue(reference * float64) uintptr {
	return uintptr(unsafe.Pointer(reference))
}
func Float64InValue(value float64) uintptr {
	return uintptr(value)
}
func StringInValue (value string) uintptr {
	bytePtr, err := syscall.BytePtrFromString(value)
	if err != nil {
		return 0
	}
	return uintptr(unsafe.Pointer(bytePtr))
}

func PtrOutValue(ptr * uintptr) uintptr {
		return uintptr(unsafe.Pointer(ptr))
}

func BytesOutValue(bytePtr * []byte) uintptr {
		return uintptr(unsafe.Pointer(bytePtr))
}


func GetOptClassErrorMessage(errorcode uint32) (string) {
	switch (errorcode) {
	case 1: return "NOTIMPLEMENTED";
	case 2: return "INVALIDPARAM";
	case 3: return "INVALIDCAST";
	case 4: return "BUFFERTOOSMALL";
	case 5: return "GENERICEXCEPTION";
	case 6: return "COULDNOTLOADLIBRARY";
	case 7: return "COULDNOTFINDLIBRARYEXPORT";
	case 8: return "INCOMPATIBLEBINARYVERSION";
	default:
		return "unknown";
	}
}


func (implementation *OptClassImplementation) GetWrapperHandle(handle OptClassHandle) (OptClassImplementationHandle, error) {
	implementation_handle, ok := handle.(OptClassImplementationHandle)
	if ok {
		handle_implementation := implementation_handle.GetWrapper()
		if (handle_implementation == implementation) {
			return implementation_handle, nil
		}
		return nil, errors.New("Invalid Implementation for DLL handle.")
	}
	return nil, errors.New("Could not cast DLL handle.")
}

func (implementation *OptClassImplementation) Initialize(DLLFileName string) error {
	implementation.Initialized = false;
	implementation.DLLHandle = 0;

	dllHandle, err := syscall.LoadLibrary(DLLFileName);
	if (err != nil) {
		return err;
	}

	implementation.OptClass_acquireinstance, err = syscall.GetProcAddress(dllHandle, "optclass_acquireinstance")
	if (err != nil) {
		return errors.New("Could not get function optclass_acquireinstance: " + err.Error())
	}
	
	implementation.OptClass_releaseinstance, err = syscall.GetProcAddress(dllHandle, "optclass_releaseinstance")
	if (err != nil) {
		return errors.New("Could not get function optclass_releaseinstance: " + err.Error())
	}
	
	implementation.OptClass_getversion, err = syscall.GetProcAddress(dllHandle, "optclass_getversion")
	if (err != nil) {
		return errors.New("Could not get function optclass_getversion: " + err.Error())
	}
	
	implementation.OptClass_getlasterror, err = syscall.GetProcAddress(dllHandle, "optclass_getlasterror")
	if (err != nil) {
		return errors.New("Could not get function optclass_getlasterror: " + err.Error())
	}
	
	implementation.OptClass_setjournal, err = syscall.GetProcAddress(dllHandle, "optclass_setjournal")
	if (err != nil) {
		return errors.New("Could not get function optclass_setjournal: " + err.Error())
	}
	
	implementation.OptClass_createinstancewithname, err = syscall.GetProcAddress(dllHandle, "optclass_createinstancewithname")
	if (err != nil) {
		return errors.New("Could not get function optclass_createinstancewithname: " + err.Error())
	}
	
	implementation.OptClass_findinstancea, err = syscall.GetProcAddress(dllHandle, "optclass_findinstancea")
	if (err != nil) {
		return errors.New("Could not get function optclass_findinstancea: " + err.Error())
	}
	
	implementation.OptClass_findinstanceb, err = syscall.GetProcAddress(dllHandle, "optclass_findinstanceb")
	if (err != nil) {
		return errors.New("Could not get function optclass_findinstanceb: " + err.Error())
	}
	
	implementation.OptClass_useinstancemaybe, err = syscall.GetProcAddress(dllHandle, "optclass_useinstancemaybe")
	if (err != nil) {
		return errors.New("Could not get function optclass_useinstancemaybe: " + err.Error())
	}
	
	implementation.DLLHandle =  dllHandle
	implementation.Initialized = true
	return nil
}

func (implementation *OptClassImplementation) NewHandle() (OptClassImplementationHandle) {
	handle := new (OptClassImplementationHandleStruct)
	handle.Implementation = implementation
	handle.DLLhandle = 0
	return handle
}

func (implementation *OptClassImplementation) CallFunction(funcptr uintptr, parameters ... uintptr) (error) {
	var ret uintptr;
	if (!implementation.Initialized) {
		return errors.New("OptClass Implementation has not been initialized!")
	}
	
	switch len(parameters) { 
		case 0: ret, _, _ = syscall.Syscall(funcptr, 0, 0, 0, 0)
		case 1: ret, _, _ = syscall.Syscall(funcptr, 1, uintptr(parameters[0]), 0, 0)
		case 2: ret, _, _ = syscall.Syscall(funcptr, 2, uintptr(parameters[0]), uintptr(parameters[1]), 0)
		case 3: ret, _, _ = syscall.Syscall(funcptr, 3, uintptr(parameters[0]), uintptr(parameters[1]), uintptr(parameters[2]))
		case 4: ret, _, _ = syscall.Syscall6(funcptr, 4, uintptr(parameters[0]), uintptr(parameters[1]), uintptr(parameters[2]), uintptr(parameters[3]), 0, 0)
		case 5: ret, _, _ = syscall.Syscall6(funcptr, 5, uintptr(parameters[0]), uintptr(parameters[1]), uintptr(parameters[2]), uintptr(parameters[3]), uintptr(parameters[4]), 0)
		case 6: ret, _, _ = syscall.Syscall6(funcptr, 6, uintptr(parameters[0]), uintptr(parameters[1]), uintptr(parameters[2]), uintptr(parameters[3]), uintptr(parameters[4]), uintptr(parameters[5]))
		case 7: ret, _, _ = syscall.Syscall9(funcptr, 7, uintptr(parameters[0]), uintptr(parameters[1]), uintptr(parameters[2]), uintptr(parameters[3]), uintptr(parameters[4]), uintptr(parameters[5]), uintptr(parameters[6]), 0, 0)
		case 8: ret, _, _ = syscall.Syscall9(funcptr, 8, uintptr(parameters[0]), uintptr(parameters[1]), uintptr(parameters[2]), uintptr(parameters[3]), uintptr(parameters[4]), uintptr(parameters[5]), uintptr(parameters[6]), uintptr(parameters[7]), 0)
		case 9: ret, _, _ = syscall.Syscall9(funcptr, 9, uintptr(parameters[0]), uintptr(parameters[1]), uintptr(parameters[2]), uintptr(parameters[3]), uintptr(parameters[4]), uintptr(parameters[5]), uintptr(parameters[6]), uintptr(parameters[7]), uintptr(parameters[8]))
		case 10: ret, _, _ = syscall.Syscall12(funcptr, 10, uintptr(parameters[0]), uintptr(parameters[1]), uintptr(parameters[2]), uintptr(parameters[3]), uintptr(parameters[4]), uintptr(parameters[5]), uintptr(parameters[6]), uintptr(parameters[7]), uintptr(parameters[8]), uintptr(parameters[9]), 0, 0)
		case 11: ret, _, _ = syscall.Syscall12(funcptr, 11, uintptr(parameters[0]), uintptr(parameters[1]), uintptr(parameters[2]), uintptr(parameters[3]), uintptr(parameters[4]), uintptr(parameters[5]), uintptr(parameters[6]), uintptr(parameters[7]), uintptr(parameters[8]), uintptr(parameters[9]), uintptr(parameters[10]), 0)
		case 12: ret, _, _ = syscall.Syscall12(funcptr, 12, uintptr(parameters[0]), uintptr(parameters[1]), uintptr(parameters[2]), uintptr(parameters[3]), uintptr(parameters[4]), uintptr(parameters[5]), uintptr(parameters[6]), uintptr(parameters[7]), uintptr(parameters[8]), uintptr(parameters[9]), uintptr(parameters[10]), uintptr(parameters[11]))
		default: 
			return errors.New("Invalid DLL function parameter count!");
	}
	
	if (int(ret) != 0) {
		return errors.New(fmt.Sprintf("OptClass Error: %.04x (%s)", int(ret), GetOptClassErrorMessage(uint32(ret))))
	}
	
	return nil
}



/*************************************************************************************************************************
	Class definition OptClassWrapper
**************************************************************************************************************************/
type OptClassWrapper struct {
	Interface OptClassGoInterface
}
func (implementation *OptClassImplementation) AcquireInstance(Instance OptClassHandle) (error) {
	var err error = nil
	implementation_instance, err := implementation.GetWrapperHandle(Instance)
	if (err != nil) {
		return err
	}
	
	InstanceDLLHandle := implementation_instance.GetDLLInHandle()
	if (InstanceDLLHandle == 0) {
		err := fmt.Errorf("Handle must not be 0.")
		return err
	}

	err = implementation.CallFunction(implementation.OptClass_acquireinstance, InstanceDLLHandle)
	if (err != nil) {
		return err
	}
	
	return err
}

func (implementation *OptClassImplementation) ReleaseInstance(Instance OptClassHandle) (error) {
	var err error = nil
	implementation_instance, err := implementation.GetWrapperHandle(Instance)
	if (err != nil) {
		return err
	}
	
	InstanceDLLHandle := implementation_instance.GetDLLInHandle()
	if (InstanceDLLHandle == 0) {
		err := fmt.Errorf("Handle must not be 0.")
		return err
	}

	err = implementation.CallFunction(implementation.OptClass_releaseinstance, InstanceDLLHandle)
	if (err != nil) {
		return err
	}
	
	return err
}

func (implementation *OptClassImplementation) GetVersion() (uint32, uint32, uint32, error) {
	var err error = nil
	var nMajor uint32 = 0
	var nMinor uint32 = 0
	var nMicro uint32 = 0

	err = implementation.CallFunction(implementation.OptClass_getversion, UInt32OutValue(&nMajor), UInt32OutValue(&nMinor), UInt32OutValue(&nMicro))
	if (err != nil) {
		return 0, 0, 0, err
	}
	
	return uint32(nMajor), uint32(nMinor), uint32(nMicro), err
}

func (implementation *OptClassImplementation) GetLastError(Instance OptClassHandle) (string, bool, error) {
	var err error = nil
	var neededforErrorMessage int64 = 0
	var filledinErrorMessage int64 = 0
	var bHasError int64 = 0
	implementation_instance, err := implementation.GetWrapperHandle(Instance)
	if (err != nil) {
		return "", false, err
	}
	
	InstanceDLLHandle := implementation_instance.GetDLLInHandle()
	if (InstanceDLLHandle == 0) {
		err := fmt.Errorf("Handle must not be 0.")
		return "", false, err
	}

	err = implementation.CallFunction(implementation.OptClass_getlasterror, InstanceDLLHandle, Int64InValue(0), Int64OutValue(&neededforErrorMessage), Int64InValue(0), Int64OutValue(&bHasError))
	if (err != nil) {
		return "", false, err
	}
	bufferSizeErrorMessage := neededforErrorMessage
	bufferErrorMessage := make([]byte, bufferSizeErrorMessage)
	err = implementation.CallFunction(implementation.OptClass_getlasterror, InstanceDLLHandle, Int64InValue(bufferSizeErrorMessage), Int64OutValue(&filledinErrorMessage), uintptr(unsafe.Pointer(&bufferErrorMessage[0])), Int64OutValue(&bHasError))
	if (err != nil) {
		return "", false, err
	}
	
	return string(bufferErrorMessage[:(filledinErrorMessage-1)]), (bHasError != 0), err
}

func (implementation *OptClassImplementation) SetJournal(sFileName string) (error) {
	var err error = nil

	err = implementation.CallFunction(implementation.OptClass_setjournal, StringInValue(sFileName))
	if (err != nil) {
		return err
	}
	
	return err
}

func (implementation *OptClassImplementation) CreateInstanceWithName(sIdentifier string) (error) {
	var err error = nil

	err = implementation.CallFunction(implementation.OptClass_createinstancewithname, StringInValue(sIdentifier))
	if (err != nil) {
		return err
	}
	
	return err
}

func (implementation *OptClassImplementation) FindInstanceA(sIdentifier string) (OptClassHandle, error) {
	var err error = nil
	hInstance := implementation.NewHandle()

	err = implementation.CallFunction(implementation.OptClass_findinstancea, StringInValue(sIdentifier), hInstance.GetDLLOutHandle())
	if (err != nil) {
		return hInstance, err
	}
	
	return hInstance, err
}

func (implementation *OptClassImplementation) FindInstanceB(sIdentifier string) (OptClassHandle, error) {
	var err error = nil
	hInstance := implementation.NewHandle()

	err = implementation.CallFunction(implementation.OptClass_findinstanceb, StringInValue(sIdentifier), hInstance.GetDLLOutHandle())
	if (err != nil) {
		return hInstance, err
	}
	
	return hInstance, err
}

func (implementation *OptClassImplementation) UseInstanceMaybe(Instance OptClassHandle) (bool, error) {
	var err error = nil
	var bIsUsed int64 = 0
	implementation_instance, err := implementation.GetWrapperHandle(Instance)
	if (err != nil) {
		return false, err
	}
	
	InstanceDLLHandle := implementation_instance.GetDLLInHandle()

	err = implementation.CallFunction(implementation.OptClass_useinstancemaybe, InstanceDLLHandle, Int64OutValue(&bIsUsed))
	if (err != nil) {
		return false, err
	}
	
	return (bIsUsed != 0), err
}


func (implementation *OptClassImplementation) checkBinaryVersion() (error) {
	var nBindingMajor uint32 = 1;
	var nBindingMinor uint32 = 0;
	nMajor, nMinor, _, err := implementation.GetVersion()
	if (err != nil) {
			return err;
	}
	if ( (nMajor != nBindingMajor) || (nMinor < nBindingMinor) ) {
		return fmt.Errorf("OptClass Error: 25 (%s)", int(0), GetOptClassErrorMessage(uint32(0)));
	}
	return nil
}

func OptClassLoadWrapper(DllFileName string) (OptClassWrapper, error) {
	var Wrapper OptClassWrapper;
	var Instance OptClassImplementation;
	
	err := Instance.Initialize(DllFileName);
	if (err != nil) {
			return Wrapper, err;
	}
	err = Instance.checkBinaryVersion()
	if (err != nil) {
			return Wrapper, err;
	}
	Wrapper.Interface = &Instance;
	
	return Wrapper, nil;
}

